//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _MSG_AUTH_H_INCLUDED
#define _MSG_AUTH_H_INCLUDED

#include "category.h"
#include "common/Message.h"

struct SvrInfo
{
public:
	SvrInfo()
	{
		SvrID = 0;
		m_PlayerCount = 0;
		SvrState = 0;
		SvrPort = 0;
		Region = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 8;
		length += sizeof(short) + SvrName.size();
		length += sizeof(short) + SvrIP.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << SvrID;
		s << SvrName;
		s << m_PlayerCount;
		s << SvrState;
		s << SvrIP;
		s << SvrPort;
		s << Region;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> SvrID;
		s >> SvrName;
		s >> m_PlayerCount;
		s >> SvrState;
		s >> SvrIP;
		s >> SvrPort;
		s >> Region;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "SvrID", SvrID);
		lua::settable(L, -1, "SvrName", SvrName);
		lua::settable(L, -1, "m_PlayerCount", m_PlayerCount);
		lua::settable(L, -1, "SvrState", SvrState);
		lua::settable(L, -1, "SvrIP", SvrIP);
		lua::settable(L, -1, "SvrPort", SvrPort);
		lua::settable(L, -1, "Region", Region);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "SvrID=" << SvrID;
		buffer << ",SvrName=" << SvrName;
		buffer << ",m_PlayerCount=" << m_PlayerCount;
		buffer << ",SvrState=" << SvrState;
		buffer << ",SvrIP=" << SvrIP;
		buffer << ",SvrPort=" << SvrPort;
		buffer << ",Region=" << Region;
	}

public:
	short SvrID;
	std::string SvrName;
	char m_PlayerCount;
	char SvrState;
	std::string SvrIP;
	short SvrPort;
	short Region;
};

class MsgAuthRegisterRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 2 };

	MsgAuthRegisterRequest() :
		Message(Category, Id)
	{
		version = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthRegisterRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 2;
		length += sizeof(short) + name.size();
		length += sizeof(short) + pwd.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << name;
		s << pwd;
		s << version;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> name;
		s >> pwd;
		s >> version;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "pwd", pwd);
		lua::settable(L, -1, "version", version);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "name=" << name;
		buffer << ",pwd=" << pwd;
		buffer << ",version=" << version;
	}

public:
	std::string name;
	std::string pwd;
	short version;
};

class MsgAuthResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 3 };

	MsgAuthResponse() :
		Message(Category, Id)
	{
		errcode = 0;
		aid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 6;
		length += sizeof(short);
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			length += SvrList[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << errcode;
		s << aid;
		short SvrList_vector_size = (short)SvrList.size();
		s << SvrList_vector_size;
		if (SvrList_vector_size > 0)
		{
			for (auto it = SvrList.begin(); it != SvrList.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> errcode;
		s >> aid;
		int SvrList_vector_size = s.read_int16();
		SvrList.clear();
		while (SvrList_vector_size > 0)
		{
			SvrList_vector_size--;
			SvrInfo val;
			val.unserialize(s, false);
			SvrList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "aid", aid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			SvrList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "SvrList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "errcode=" << errcode;
		buffer << ",aid=" << aid;
		buffer << ",SvrList=[";
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			SvrList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	short errcode;
	int aid;
	std::vector<SvrInfo> SvrList;
};

class MsgAuthRegisterResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 4 };

	MsgAuthRegisterResponse() :
		Message(Category, Id)
	{
		errcode = 0;
		aid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthRegisterResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 6;
		length += sizeof(short);
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			length += SvrList[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << errcode;
		s << aid;
		short SvrList_vector_size = (short)SvrList.size();
		s << SvrList_vector_size;
		if (SvrList_vector_size > 0)
		{
			for (auto it = SvrList.begin(); it != SvrList.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> errcode;
		s >> aid;
		int SvrList_vector_size = s.read_int16();
		SvrList.clear();
		while (SvrList_vector_size > 0)
		{
			SvrList_vector_size--;
			SvrInfo val;
			val.unserialize(s, false);
			SvrList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "aid", aid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			SvrList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "SvrList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "errcode=" << errcode;
		buffer << ",aid=" << aid;
		buffer << ",SvrList=[";
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			SvrList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	short errcode;
	int aid;
	std::vector<SvrInfo> SvrList;
};

class MsgAuthBindRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 5 };

	MsgAuthBindRequest() :
		Message(Category, Id)
	{
		channelId = 0;
		platformId = 0;
		loginType = 0;
		version = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthBindRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 14;
		length += sizeof(short) + uid.size();
		length += sizeof(short) + name.size();
		length += sizeof(short) + data.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << channelId;
		s << platformId;
		s << loginType;
		s << uid;
		s << name;
		s << data;
		s << version;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> channelId;
		s >> platformId;
		s >> loginType;
		s >> uid;
		s >> name;
		s >> data;
		s >> version;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelId", channelId);
		lua::settable(L, -1, "platformId", platformId);
		lua::settable(L, -1, "loginType", loginType);
		lua::settable(L, -1, "uid", uid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "data", data);
		lua::settable(L, -1, "version", version);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "channelId=" << channelId;
		buffer << ",platformId=" << platformId;
		buffer << ",loginType=" << loginType;
		buffer << ",uid=" << uid;
		buffer << ",name=" << name;
		buffer << ",data=" << data;
		buffer << ",version=" << version;
	}

public:
	int channelId;
	int platformId;
	int loginType;
	std::string uid;
	std::string name;
	std::string data;
	short version;
};

class MsgAuthBindExRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 14 };

	MsgAuthBindExRequest() :
		Message(Category, Id)
	{
		platformId = 0;
		loginType = 0;
		version = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthBindExRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 10;
		length += sizeof(short) + channelId.size();
		length += sizeof(short) + uid.size();
		length += sizeof(short) + name.size();
		length += sizeof(short) + data.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << channelId;
		s << platformId;
		s << loginType;
		s << uid;
		s << name;
		s << data;
		s << version;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> channelId;
		s >> platformId;
		s >> loginType;
		s >> uid;
		s >> name;
		s >> data;
		s >> version;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelId", channelId);
		lua::settable(L, -1, "platformId", platformId);
		lua::settable(L, -1, "loginType", loginType);
		lua::settable(L, -1, "uid", uid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "data", data);
		lua::settable(L, -1, "version", version);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "channelId=" << channelId;
		buffer << ",platformId=" << platformId;
		buffer << ",loginType=" << loginType;
		buffer << ",uid=" << uid;
		buffer << ",name=" << name;
		buffer << ",data=" << data;
		buffer << ",version=" << version;
	}

public:
	std::string channelId;
	int platformId;
	int loginType;
	std::string uid;
	std::string name;
	std::string data;
	short version;
};

class MsgAuthServerListNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 13 };

	MsgAuthServerListNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgAuthServerListNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			length += SvrList[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short SvrList_vector_size = (short)SvrList.size();
		s << SvrList_vector_size;
		if (SvrList_vector_size > 0)
		{
			for (auto it = SvrList.begin(); it != SvrList.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int SvrList_vector_size = s.read_int16();
		SvrList.clear();
		while (SvrList_vector_size > 0)
		{
			SvrList_vector_size--;
			SvrInfo val;
			val.unserialize(s, false);
			SvrList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			SvrList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "SvrList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "SvrList=[";
		for (size_t i = 0; i < SvrList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			SvrList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<SvrInfo> SvrList;
};

class MsgAuthCheckVersionRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 6 };

	MsgAuthCheckVersionRequest() :
		Message(Category, Id)
	{
		channelID = 0;
		gameVersion = 0;
		dataVersion = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthCheckVersionRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 6;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << channelID;
		s << gameVersion;
		s << dataVersion;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> channelID;
		s >> gameVersion;
		s >> dataVersion;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelID", channelID);
		lua::settable(L, -1, "gameVersion", gameVersion);
		lua::settable(L, -1, "dataVersion", dataVersion);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "channelID=" << channelID;
		buffer << ",gameVersion=" << gameVersion;
		buffer << ",dataVersion=" << dataVersion;
	}

public:
	short channelID;
	short gameVersion;
	short dataVersion;
};

class MsgAuthCheckVersionExRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 11 };

	MsgAuthCheckVersionExRequest() :
		Message(Category, Id)
	{
		gameVersion = 0;
		dataVersion = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthCheckVersionExRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + channelID.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << channelID;
		s << gameVersion;
		s << dataVersion;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> channelID;
		s >> gameVersion;
		s >> dataVersion;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelID", channelID);
		lua::settable(L, -1, "gameVersion", gameVersion);
		lua::settable(L, -1, "dataVersion", dataVersion);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "channelID=" << channelID;
		buffer << ",gameVersion=" << gameVersion;
		buffer << ",dataVersion=" << dataVersion;
	}

public:
	std::string channelID;
	short gameVersion;
	short dataVersion;
};

class MsgAuthCheckVersionResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 7 };

	MsgAuthCheckVersionResponse() :
		Message(Category, Id)
	{
		gameVersion = 0;
		dataVersion = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthCheckVersionResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + downloadURL.size();
		length += sizeof(short) + announcement.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << gameVersion;
		s << dataVersion;
		s << downloadURL;
		s << announcement;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> gameVersion;
		s >> dataVersion;
		s >> downloadURL;
		s >> announcement;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "gameVersion", gameVersion);
		lua::settable(L, -1, "dataVersion", dataVersion);
		lua::settable(L, -1, "downloadURL", downloadURL);
		lua::settable(L, -1, "announcement", announcement);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "gameVersion=" << gameVersion;
		buffer << ",dataVersion=" << dataVersion;
		buffer << ",downloadURL=" << downloadURL;
		buffer << ",announcement=" << announcement;
	}

public:
	short gameVersion;
	short dataVersion;
	std::string downloadURL;
	std::string announcement;
};

class MsgAccessTokenResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 8 };

	MsgAccessTokenResponse() :
		Message(Category, Id)
	{
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAccessTokenResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 2;
		length += sizeof(short) + accessToken.size();
		length += sizeof(short) + userId.size();
		length += sizeof(short) + userName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << errcode;
		s << accessToken;
		s << userId;
		s << userName;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> errcode;
		s >> accessToken;
		s >> userId;
		s >> userName;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "accessToken", accessToken);
		lua::settable(L, -1, "userId", userId);
		lua::settable(L, -1, "userName", userName);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "errcode=" << errcode;
		buffer << ",accessToken=" << accessToken;
		buffer << ",userId=" << userId;
		buffer << ",userName=" << userName;
	}

public:
	short errcode;
	std::string accessToken;
	std::string userId;
	std::string userName;
};

class MsgAuthCheckSVNVersionRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 9 };

	MsgAuthCheckSVNVersionRequest() :
		Message(Category, Id)
	{
		channelID = 0;
		svnVersion = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthCheckSVNVersionRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 6;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << channelID;
		s << svnVersion;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> channelID;
		s >> svnVersion;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelID", channelID);
		lua::settable(L, -1, "svnVersion", svnVersion);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "channelID=" << channelID;
		buffer << ",svnVersion=" << svnVersion;
	}

public:
	short channelID;
	int svnVersion;
};

class MsgAuthCheckSVNVersionExRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 12 };

	MsgAuthCheckSVNVersionExRequest() :
		Message(Category, Id)
	{
		svnVersion = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthCheckSVNVersionExRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + channelID.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << channelID;
		s << svnVersion;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> channelID;
		s >> svnVersion;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelID", channelID);
		lua::settable(L, -1, "svnVersion", svnVersion);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "channelID=" << channelID;
		buffer << ",svnVersion=" << svnVersion;
	}

public:
	std::string channelID;
	int svnVersion;
};

class MsgAuthCheckSVNVersionResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 10 };

	MsgAuthCheckSVNVersionResponse() :
		Message(Category, Id)
	{
		svnVersion = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthCheckSVNVersionResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + downloadURL.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << svnVersion;
		s << downloadURL;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> svnVersion;
		s >> downloadURL;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "svnVersion", svnVersion);
		lua::settable(L, -1, "downloadURL", downloadURL);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "svnVersion=" << svnVersion;
		buffer << ",downloadURL=" << downloadURL;
	}

public:
	int svnVersion;
	std::string downloadURL;
};

class MsgGSAuthToASRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 20 };

	MsgGSAuthToASRequest() :
		Message(Category, Id)
	{
		ServerPort = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGSAuthToASRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 2;
		length += sizeof(short) + ServerIP.size();
		length += sizeof(short) + lastpingID.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << ServerIP;
		s << ServerPort;
		s << lastpingID;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> ServerIP;
		s >> ServerPort;
		s >> lastpingID;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ServerIP", ServerIP);
		lua::settable(L, -1, "ServerPort", ServerPort);
		lua::settable(L, -1, "lastpingID", lastpingID);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "ServerIP=" << ServerIP;
		buffer << ",ServerPort=" << ServerPort;
		buffer << ",lastpingID=" << lastpingID;
	}

public:
	std::string ServerIP;
	short ServerPort;
	std::string lastpingID;
};

class MsgGSAuthToASResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 21 };

	MsgGSAuthToASResponse() :
		Message(Category, Id)
	{
		mID = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGSAuthToASResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << mID;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> mID;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "mID", mID);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "mID=" << mID;
	}

public:
	int mID;
};

class MsgServerInfoResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_AUTH, Id = 510 };

	MsgServerInfoResponse() :
		Message(Category, Id)
	{
		mID = 0;
	}

	virtual const char *getName() const
	{
		return "MsgServerInfoResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + serverName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << mID;
		s << serverName;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> mID;
		s >> serverName;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "mID", mID);
		lua::settable(L, -1, "serverName", serverName);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "mID=" << mID;
		buffer << ",serverName=" << serverName;
	}

public:
	int mID;
	std::string serverName;
};

#endif	//_MSG_AUTH_H_INCLUDED
