//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _DB_MSG_ITEM_H_INCLUDED
#define _DB_MSG_ITEM_H_INCLUDED

#include "category.h"
#include "common/MessageEx.h"

struct DBItem
{
public:
	DBItem()
	{
		pid = 0;
		iid = 0;
		sid = 0;
		bind = 0;
		count = 0;
		position = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 18;
		length += sizeof(short) + firstowner.size();
		length += sizeof(short) + appraiser.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << iid;
		s << sid;
		s << bind;
		s << count;
		s << position;
		s << firstowner;
		s << appraiser;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> iid;
		s >> sid;
		s >> bind;
		s >> count;
		s >> position;
		s >> firstowner;
		s >> appraiser;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "bind", bind);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "position", position);
		lua::settable(L, -1, "firstowner", firstowner);
		lua::settable(L, -1, "appraiser", appraiser);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",sid=" << sid;
		buffer << ",bind=" << bind;
		buffer << ",count=" << count;
		buffer << ",position=" << position;
		buffer << ",firstowner=" << firstowner;
		buffer << ",appraiser=" << appraiser;
	}

public:
	int pid; //角色ID或行会ID 
	int iid; //物品ID 
	int sid;
	short bind;
	short count;
	short position;
	std::string firstowner;
	std::string appraiser;
};

struct DBGJItem
{
public:
	DBGJItem()
	{
		pid = 0;
		iid = 0;
		sid = 0;
		bind = 0;
		count = 0;
		position = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += sizeof(short) + firstowner.size();
		length += sizeof(short) + appraiser.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << iid;
		s << sid;
		s << bind;
		s << count;
		s << position;
		s << firstowner;
		s << appraiser;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> iid;
		s >> sid;
		s >> bind;
		s >> count;
		s >> position;
		s >> firstowner;
		s >> appraiser;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "bind", bind);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "position", position);
		lua::settable(L, -1, "firstowner", firstowner);
		lua::settable(L, -1, "appraiser", appraiser);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",sid=" << sid;
		buffer << ",bind=" << bind;
		buffer << ",count=" << count;
		buffer << ",position=" << position;
		buffer << ",firstowner=" << firstowner;
		buffer << ",appraiser=" << appraiser;
	}

public:
	int pid; //角色ID或行会ID 
	int iid; //物品ID 
	int sid;
	short bind;
	int count;
	short position;
	std::string firstowner;
	std::string appraiser;
};

struct DBItemProp
{
public:
	DBItemProp()
	{
		pid = 0;
		iid = 0;
		idx = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 14;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << iid;
		s << idx;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> iid;
		s >> idx;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",idx=" << idx;
		buffer << ",data=" << data;
	}

public:
	int pid; //角色ID或行会ID 
	int iid;
	short idx;
	int data;
};

class MsgDBLoadItems : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 1 };

	MsgDBLoadItems() :
		MessageEx(Category, Id)
	{
		pid = 0;
		load_id = 0;
		load_reason = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadItems";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 9;
		length += sizeof(int);
		for (size_t i = 0; i < items.size(); ++i)
		{
			length += items[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << load_id;
		s << load_reason;
		int items_vector_size = (int)items.size();
		s << items_vector_size;
		if (items_vector_size > 0)
		{
			for (auto it = items.begin(); it != items.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> load_id;
		s >> load_reason;
		int items_vector_size = s.read_int32();
		items.clear();
		while (items_vector_size > 0)
		{
			items_vector_size--;
			DBItem val;
			val.unserialize(s, true);
			items.push_back(val);
		}
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBItemProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "load_id", load_id);
		lua::settable(L, -1, "load_reason", load_reason);
		lua::newtable(lua::L);
		for (size_t i = 0; i < items.size(); ++i)
		{
			items[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "items");
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",load_id=" << load_id;
		buffer << ",load_reason=" << load_reason;
		buffer << ",items=[";
		for (size_t i = 0; i < items.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			items[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int load_id;
	char load_reason;
	std::vector<DBItem> items;
	std::vector<DBItemProp> props;
};

class MsgDBLoadGuildItems : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 2 };

	MsgDBLoadGuildItems() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadGuildItems";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < items.size(); ++i)
		{
			length += items[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int items_vector_size = (int)items.size();
		s << items_vector_size;
		if (items_vector_size > 0)
		{
			for (auto it = items.begin(); it != items.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int items_vector_size = s.read_int32();
		items.clear();
		while (items_vector_size > 0)
		{
			items_vector_size--;
			DBItem val;
			val.unserialize(s, true);
			items.push_back(val);
		}
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBItemProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < items.size(); ++i)
		{
			items[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "items");
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",items=[";
		for (size_t i = 0; i < items.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			items[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBItem> items;
	std::vector<DBItemProp> props;
};

class MsgDBCreateItem : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 3 };

	MsgDBCreateItem() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBCreateItem";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += item.getLength(true);
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		item.serialize(s, true);
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		item.unserialize(s, true);
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBItemProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		item.push(L);
		lua::settable(L, -1, "item");
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",item={";
		item.dump(buffer);
		buffer << "}";
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	DBItem item;
	std::vector<DBItemProp> props;
};

class MsgDBDeleteItem : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 4 };

	MsgDBDeleteItem() :
		MessageEx(Category, Id)
	{
		pid = 0;
		iid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBDeleteItem";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << iid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> iid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",iid=" << iid;
	}

public:
	int pid;
	int iid;
};

class MsgDBUpdateItemBase : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 10 };

	MsgDBUpdateItemBase() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateItemBase";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += item.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		item.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		item.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		item.push(L);
		lua::settable(L, -1, "item");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",item={";
		item.dump(buffer);
		buffer << "}";
	}

public:
	int pid;
	DBItem item;
};

class MsgDBUpdateItemCount : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 11 };

	MsgDBUpdateItemCount() :
		MessageEx(Category, Id)
	{
		pid = 0;
		iid = 0;
		count = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateItemCount";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 10;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << iid;
		s << count;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> iid;
		s >> count;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "count", count);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",count=" << count;
	}

public:
	int pid;
	int iid;
	short count;
};

class MsgDBUpdateItemProp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 12 };

	MsgDBUpdateItemProp() :
		MessageEx(Category, Id)
	{
		pid = 0;
		iid = 0;
		idx = 0;
		data = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateItemProp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 14;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << iid;
		s << idx;
		s << data;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> iid;
		s >> idx;
		s >> data;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "data", data);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",idx=" << idx;
		buffer << ",data=" << data;
	}

public:
	int pid;
	int iid;
	short idx;
	int data;
};

class MsgDBUpdateItemPosition : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 13 };

	MsgDBUpdateItemPosition() :
		MessageEx(Category, Id)
	{
		pid = 0;
		iid = 0;
		position = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateItemPosition";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 10;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << iid;
		s << position;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> iid;
		s >> position;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "position", position);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",position=" << position;
	}

public:
	int pid;
	int iid;
	short position;
};

class MsgDBUpdateItemSid : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 14 };

	MsgDBUpdateItemSid() :
		MessageEx(Category, Id)
	{
		pid = 0;
		iid = 0;
		sid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateItemSid";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << iid;
		s << sid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> iid;
		s >> sid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "sid", sid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",sid=" << sid;
	}

public:
	int pid;
	int iid;
	int sid;
};

struct DBIncome
{
public:
	DBIncome()
	{
		pid = 0;
		iid = 0;
		sid = 0;
		count = 0;
		bind = 0;
		opcode = 0;
		data = 0;
		ctime = 0;
	}

	size_t getLength(bool ex) const
	{
		return 32;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << iid;
		s << sid;
		s << count;
		s << bind;
		s << opcode;
		s << data;
		s << ctime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> iid;
		s >> sid;
		s >> count;
		s >> bind;
		s >> opcode;
		s >> data;
		s >> ctime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "bind", bind);
		lua::settable(L, -1, "opcode", opcode);
		lua::settable(L, -1, "data", data);
		lua::settable(L, -1, "ctime", ctime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",bind=" << bind;
		buffer << ",opcode=" << opcode;
		buffer << ",data=" << data;
		buffer << ",ctime=" << ctime;
	}

public:
	int pid; //角色ID 
	int iid; //物品ID 
	int sid; //物品静态ID 
	int count; //物品数量 
	int bind; //物品绑定状态 
	int opcode; //操作码 
	int data; //操作附加数据 
	int ctime; //获得时间 
};

struct DBIncomeProp
{
public:
	DBIncomeProp()
	{
		pid = 0;
		iid = 0;
		idx = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 16;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << iid;
		s << idx;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> iid;
		s >> idx;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",idx=" << idx;
		buffer << ",data=" << data;
	}

public:
	int pid; //角色ID 
	int iid; //物品ID 
	int idx; //属性ID 
	int data; //属性值 
};

class MsgDBLoadIncome : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 21 };

	MsgDBLoadIncome() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadIncome";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < items.size(); ++i)
		{
			length += items[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		int items_vector_size = (int)items.size();
		s << items_vector_size;
		if (items_vector_size > 0)
		{
			for (auto it = items.begin(); it != items.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		int items_vector_size = s.read_int32();
		items.clear();
		while (items_vector_size > 0)
		{
			items_vector_size--;
			DBIncome val;
			val.unserialize(s, true);
			items.push_back(val);
		}
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBIncomeProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < items.size(); ++i)
		{
			items[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "items");
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",items=[";
		for (size_t i = 0; i < items.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			items[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid; //角色ID 
	std::vector<DBIncome> items;
	std::vector<DBIncomeProp> props;
};

class MsgDBCreateIncome : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 22 };

	MsgDBCreateIncome() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBCreateIncome";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += item.getLength(true);
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		item.serialize(s, true);
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		item.unserialize(s, true);
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBIncomeProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		item.push(L);
		lua::settable(L, -1, "item");
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",item={";
		item.dump(buffer);
		buffer << "}";
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	DBIncome item;
	std::vector<DBIncomeProp> props;
};

class MsgDBDeleteIncome : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 23 };

	MsgDBDeleteIncome() :
		MessageEx(Category, Id)
	{
		pid = 0;
		iid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBDeleteIncome";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << iid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> iid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",iid=" << iid;
	}

public:
	int pid;
	int iid;
};

class MsgDBUpdBagItems : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 25 };

	MsgDBUpdBagItems() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdBagItems";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		length += deleteItemList.size() * 4;
		length += sizeof(int);
		for (size_t i = 0; i < items.size(); ++i)
		{
			length += items[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		int deleteItemList_vector_size = (int)deleteItemList.size();
		s << deleteItemList_vector_size;
		if (deleteItemList_vector_size > 0)
		{
			for (auto it = deleteItemList.begin(); it != deleteItemList.end(); ++it)
			{
				s << *it;
			}
		}
		int items_vector_size = (int)items.size();
		s << items_vector_size;
		if (items_vector_size > 0)
		{
			for (auto it = items.begin(); it != items.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		int deleteItemList_vector_size = s.read_int32();
		deleteItemList.clear();
		while (deleteItemList_vector_size > 0)
		{
			deleteItemList_vector_size--;
			int val;
			s >> val;
			deleteItemList.push_back(val);
		}
		int items_vector_size = s.read_int32();
		items.clear();
		while (items_vector_size > 0)
		{
			items_vector_size--;
			DBItem val;
			val.unserialize(s, true);
			items.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < deleteItemList.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, deleteItemList[i]);
		}
		lua::settable(L, -2, "deleteItemList");
		lua::newtable(lua::L);
		for (size_t i = 0; i < items.size(); ++i)
		{
			items[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "items");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",deleteItemList=[";
		for (size_t i = 0; i < deleteItemList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << deleteItemList[i];
		}
		buffer << "]";
		buffer << ",items=[";
		for (size_t i = 0; i < items.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			items[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	std::vector<int> deleteItemList;
	std::vector<DBItem> items;
};

class MsgDBCreateAuctionItems : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 26 };

	MsgDBCreateAuctionItems() :
		MessageEx(Category, Id)
	{
		sid = 0;
		iid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBCreateAuctionItems";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sid;
		s << iid;
		s << serverid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sid;
		s >> iid;
		s >> serverid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "serverid", serverid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sid=" << sid;
		buffer << ",iid=" << iid;
		buffer << ",serverid=" << serverid;
	}

public:
	int sid;
	int iid;
	int serverid;
};

class MsgDBUpdateItemAppraiser : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 27 };

	MsgDBUpdateItemAppraiser() :
		MessageEx(Category, Id)
	{
		pid = 0;
		iid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateItemAppraiser";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(short) + appraiser.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << iid;
		s << appraiser;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> iid;
		s >> appraiser;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "appraiser", appraiser);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",appraiser=" << appraiser;
	}

public:
	int pid;
	int iid;
	std::string appraiser;
};

struct DBItemPropEx
{
public:
	DBItemPropEx()
	{
		idx = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 6;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << idx;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> idx;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "idx=" << idx;
		buffer << ",data=" << data;
	}

public:
	short idx;
	int data;
};

class MsgDBUpdateItemChangedProp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 28 };

	MsgDBUpdateItemChangedProp() :
		MessageEx(Category, Id)
	{
		pid = 0;
		iid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateItemChangedProp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << iid;
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> iid;
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBItemPropEx val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "iid", iid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",iid=" << iid;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int iid;
	std::vector<DBItemPropEx> props;
};

class MsgDBDeleteDBBKItems : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_ITEM, Id = 29 };

	MsgDBDeleteDBBKItems() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBDeleteDBBKItems";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength();
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
	}

public:
};

#endif	//_DB_MSG_ITEM_H_INCLUDED
