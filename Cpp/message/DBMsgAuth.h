//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _DB_MSG_AUTH_H_INCLUDED
#define _DB_MSG_AUTH_H_INCLUDED

#include "category.h"
#include "common/MessageEx.h"

struct DBAccount
{
public:
	DBAccount()
	{
		aid = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 4;
		length += sizeof(short) + account.size();
		length += sizeof(short) + passwd.size();
		length += sizeof(short) + data.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << aid;
		s << account;
		s << passwd;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> aid;
		s >> account;
		s >> passwd;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "account", account);
		lua::settable(L, -1, "passwd", passwd);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "aid=" << aid;
		buffer << ",account=" << account;
		buffer << ",passwd=" << passwd;
		buffer << ",data=" << data;
	}

public:
	int aid;
	std::string account;
	std::string passwd;
	std::string data;
};

struct DBRoleCount
{
public:
	DBRoleCount()
	{
		accid = 0;
		svrid = 0;
		count = 0;
	}

	size_t getLength(bool ex) const
	{
		return 12;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << accid;
		s << svrid;
		s << count;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> accid;
		s >> svrid;
		s >> count;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "accid", accid);
		lua::settable(L, -1, "svrid", svrid);
		lua::settable(L, -1, "count", count);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "accid=" << accid;
		buffer << ",svrid=" << svrid;
		buffer << ",count=" << count;
	}

public:
	int accid;
	int svrid;
	int count;
};

class MsgDBCreateAccount : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_AUTH, Id = 1 };

	MsgDBCreateAccount() :
		MessageEx(Category, Id)
	{
		flag = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBCreateAccount";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 1;
		length += m_account.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		m_account.serialize(s, true);
		s << flag;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		m_account.unserialize(s, true);
		s >> flag;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		m_account.push(L);
		lua::settable(L, -1, "m_account");
		lua::settable(L, -1, "flag", flag);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",m_account={";
		m_account.dump(buffer);
		buffer << "}";
		buffer << ",flag=" << flag;
	}

public:
	DBAccount m_account;
	char flag;
};

class MsgDBAuthAccount : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_AUTH, Id = 2 };

	MsgDBAuthAccount() :
		MessageEx(Category, Id)
	{
		flag = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBAuthAccount";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 1;
		length += m_account.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << flag;
		m_account.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> flag;
		m_account.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "flag", flag);
		m_account.push(L);
		lua::settable(L, -1, "m_account");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",flag=" << flag;
		buffer << ",m_account={";
		m_account.dump(buffer);
		buffer << "}";
	}

public:
	char flag;
	DBAccount m_account;
};

class MsgDBGetRoleCount : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_AUTH, Id = 3 };

	MsgDBGetRoleCount() :
		MessageEx(Category, Id)
	{
		aid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBGetRoleCount";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < RoleCounts.size(); ++i)
		{
			length += RoleCounts[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << aid;
		int RoleCounts_vector_size = (int)RoleCounts.size();
		s << RoleCounts_vector_size;
		if (RoleCounts_vector_size > 0)
		{
			for (auto it = RoleCounts.begin(); it != RoleCounts.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> aid;
		int RoleCounts_vector_size = s.read_int32();
		RoleCounts.clear();
		while (RoleCounts_vector_size > 0)
		{
			RoleCounts_vector_size--;
			DBRoleCount val;
			val.unserialize(s, true);
			RoleCounts.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < RoleCounts.size(); ++i)
		{
			RoleCounts[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "RoleCounts");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",aid=" << aid;
		buffer << ",RoleCounts=[";
		for (size_t i = 0; i < RoleCounts.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			RoleCounts[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int aid;
	std::vector<DBRoleCount> RoleCounts;
};

class MsgDBAuthBind : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_AUTH, Id = 4 };

	MsgDBAuthBind() :
		MessageEx(Category, Id)
	{
		flag = 0;
		type = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBAuthBind";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 5;
		length += m_account.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << flag;
		s << type;
		m_account.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> flag;
		s >> type;
		m_account.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "flag", flag);
		lua::settable(L, -1, "type", type);
		m_account.push(L);
		lua::settable(L, -1, "m_account");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",flag=" << flag;
		buffer << ",type=" << type;
		buffer << ",m_account={";
		m_account.dump(buffer);
		buffer << "}";
	}

public:
	char flag;
	int type;
	DBAccount m_account;
};

#endif	//_DB_MSG_AUTH_H_INCLUDED
