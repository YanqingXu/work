//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _DB_MSG_CENTER_H_INCLUDED
#define _DB_MSG_CENTER_H_INCLUDED

#include "category.h"
#include "common/MessageEx.h"

struct DBCrossWarSceneData
{
public:
	DBCrossWarSceneData()
	{
		kf_server_id = 0;
		kf_scene_index = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << kf_server_id;
		s << kf_scene_index;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> kf_server_id;
		s >> kf_scene_index;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "kf_server_id", kf_server_id);
		lua::settable(L, -1, "kf_scene_index", kf_scene_index);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "kf_server_id=" << kf_server_id;
		buffer << ",kf_scene_index=" << kf_scene_index;
	}

public:
	int kf_server_id;
	int kf_scene_index;
};

struct DBCenterWorldData
{
public:
	DBCenterWorldData()
	{
		wid = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
		uptime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += sizeof(short) + datas.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << wid;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		s << uptime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> wid;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		s >> uptime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "wid", wid);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
		lua::settable(L, -1, "uptime", uptime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "wid=" << wid;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
		buffer << ",uptime=" << uptime;
	}

public:
	int wid;
	int datax;
	int datay;
	int dataz;
	std::string datas;
	int uptime;
};

class MsgDBLoadCrossWarSceneIndex : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 1 };

	MsgDBLoadCrossWarSceneIndex() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadCrossWarSceneIndex";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < data.size(); ++i)
		{
			length += data[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int data_vector_size = (int)data.size();
		s << data_vector_size;
		if (data_vector_size > 0)
		{
			for (auto it = data.begin(); it != data.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int data_vector_size = s.read_int32();
		data.clear();
		while (data_vector_size > 0)
		{
			data_vector_size--;
			DBCrossWarSceneData val;
			val.unserialize(s, true);
			data.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < data.size(); ++i)
		{
			data[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "data");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",data=[";
		for (size_t i = 0; i < data.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			data[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBCrossWarSceneData> data;
};

class MsgDBUpdCrossWarSceneIndex : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 2 };

	MsgDBUpdCrossWarSceneIndex() :
		MessageEx(Category, Id)
	{
		kf_server_id = 0;
		kf_scene_index = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdCrossWarSceneIndex";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << kf_server_id;
		s << kf_scene_index;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> kf_server_id;
		s >> kf_scene_index;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "kf_server_id", kf_server_id);
		lua::settable(L, -1, "kf_scene_index", kf_scene_index);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",kf_server_id=" << kf_server_id;
		buffer << ",kf_scene_index=" << kf_scene_index;
	}

public:
	int kf_server_id; //跨服服务器id 
	int kf_scene_index; //场景索引 
};

class MsgDBLoadCenterWorldData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 9 };

	MsgDBLoadCenterWorldData() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadCenterWorldData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < data.size(); ++i)
		{
			length += data[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int data_vector_size = (int)data.size();
		s << data_vector_size;
		if (data_vector_size > 0)
		{
			for (auto it = data.begin(); it != data.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int data_vector_size = s.read_int32();
		data.clear();
		while (data_vector_size > 0)
		{
			data_vector_size--;
			DBCenterWorldData val;
			val.unserialize(s, true);
			data.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < data.size(); ++i)
		{
			data[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "data");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",data=[";
		for (size_t i = 0; i < data.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			data[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBCenterWorldData> data;
};

class MsgDBUpdCenterWorldData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 10 };

	MsgDBUpdCenterWorldData() :
		MessageEx(Category, Id)
	{
		wid = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdCenterWorldData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 16;
		length += sizeof(short) + datas.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << wid;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> wid;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "wid", wid);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",wid=" << wid;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
	}

public:
	int wid;
	int datax;
	int datay;
	int dataz;
	std::string datas;
};

struct DBWarZoneInfo
{
public:
	DBWarZoneInfo()
	{
		warZoneId = 0;
		warZonePreOpenTime = 0;
		warZoneOpenTime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += sizeof(short) + warZoneServerName.size();
		length += sizeof(short) + warZoneServerInfoStr.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << warZoneId;
		s << warZoneServerName;
		s << warZonePreOpenTime;
		s << warZoneOpenTime;
		s << warZoneServerInfoStr;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> warZoneId;
		s >> warZoneServerName;
		s >> warZonePreOpenTime;
		s >> warZoneOpenTime;
		s >> warZoneServerInfoStr;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "warZoneId", warZoneId);
		lua::settable(L, -1, "warZoneServerName", warZoneServerName);
		lua::settable(L, -1, "warZonePreOpenTime", warZonePreOpenTime);
		lua::settable(L, -1, "warZoneOpenTime", warZoneOpenTime);
		lua::settable(L, -1, "warZoneServerInfoStr", warZoneServerInfoStr);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "warZoneId=" << warZoneId;
		buffer << ",warZoneServerName=" << warZoneServerName;
		buffer << ",warZonePreOpenTime=" << warZonePreOpenTime;
		buffer << ",warZoneOpenTime=" << warZoneOpenTime;
		buffer << ",warZoneServerInfoStr=" << warZoneServerInfoStr;
	}

public:
	int warZoneId;
	std::string warZoneServerName; //战区所在的服务器的名称 
	long long warZonePreOpenTime; //战区的预开启时间 
	long long warZoneOpenTime; //战区的正式开启时间 
	std::string warZoneServerInfoStr; //战区内的服务器信息 
};

class MsgDBSaveWarZoneInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 11 };

	MsgDBSaveWarZoneInfo() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBSaveWarZoneInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += data.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		data.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		data.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		data.push(L);
		lua::settable(L, -1, "data");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",data={";
		data.dump(buffer);
		buffer << "}";
	}

public:
	DBWarZoneInfo data;
};

class MsgDBLoadWarZoneInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 12 };

	MsgDBLoadWarZoneInfo() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadWarZoneInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < data.size(); ++i)
		{
			length += data[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int data_vector_size = (int)data.size();
		s << data_vector_size;
		if (data_vector_size > 0)
		{
			for (auto it = data.begin(); it != data.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int data_vector_size = s.read_int32();
		data.clear();
		while (data_vector_size > 0)
		{
			data_vector_size--;
			DBWarZoneInfo val;
			val.unserialize(s, true);
			data.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < data.size(); ++i)
		{
			data[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "data");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",data=[";
		for (size_t i = 0; i < data.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			data[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBWarZoneInfo> data;
};

struct CrossMailInfo
{
public:
	CrossMailInfo()
	{
		mailIndex = 0;
		sourceServerId = 0;
		pid = 0;
		opcode = 0;
		ctime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += sizeof(short) + title.size();
		length += sizeof(short) + content.size();
		length += sizeof(short) + items.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << mailIndex;
		s << sourceServerId;
		s << pid;
		s << title;
		s << content;
		s << items;
		s << opcode;
		s << ctime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> mailIndex;
		s >> sourceServerId;
		s >> pid;
		s >> title;
		s >> content;
		s >> items;
		s >> opcode;
		s >> ctime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "mailIndex", mailIndex);
		lua::settable(L, -1, "sourceServerId", sourceServerId);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "title", title);
		lua::settable(L, -1, "content", content);
		lua::settable(L, -1, "items", items);
		lua::settable(L, -1, "opcode", opcode);
		lua::settable(L, -1, "ctime", ctime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "mailIndex=" << mailIndex;
		buffer << ",sourceServerId=" << sourceServerId;
		buffer << ",pid=" << pid;
		buffer << ",title=" << title;
		buffer << ",content=" << content;
		buffer << ",items=" << items;
		buffer << ",opcode=" << opcode;
		buffer << ",ctime=" << ctime;
	}

public:
	int mailIndex;
	int sourceServerId;
	int pid;
	std::string title;
	std::string content;
	std::string items;
	int opcode;
	int ctime;
};

class MsgDBSaveCrossMailInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 13 };

	MsgDBSaveCrossMailInfo() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBSaveCrossMailInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += mailInfo.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		mailInfo.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		mailInfo.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		mailInfo.push(L);
		lua::settable(L, -1, "mailInfo");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",mailInfo={";
		mailInfo.dump(buffer);
		buffer << "}";
	}

public:
	CrossMailInfo mailInfo;
};

class MsgDBDelteCrossMailInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 14 };

	MsgDBDelteCrossMailInfo() :
		MessageEx(Category, Id)
	{
		mailIndex = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBDelteCrossMailInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << mailIndex;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> mailIndex;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "mailIndex", mailIndex);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",mailIndex=" << mailIndex;
	}

public:
	int mailIndex;
};

class MsgDBLoadCrossMailInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DBCENTER, Id = 15 };

	MsgDBLoadCrossMailInfo() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadCrossMailInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < mailInfoList.size(); ++i)
		{
			length += mailInfoList[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int mailInfoList_vector_size = (int)mailInfoList.size();
		s << mailInfoList_vector_size;
		if (mailInfoList_vector_size > 0)
		{
			for (auto it = mailInfoList.begin(); it != mailInfoList.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int mailInfoList_vector_size = s.read_int32();
		mailInfoList.clear();
		while (mailInfoList_vector_size > 0)
		{
			mailInfoList_vector_size--;
			CrossMailInfo val;
			val.unserialize(s, true);
			mailInfoList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < mailInfoList.size(); ++i)
		{
			mailInfoList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "mailInfoList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",mailInfoList=[";
		for (size_t i = 0; i < mailInfoList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			mailInfoList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<CrossMailInfo> mailInfoList;
};

#endif	//_DB_MSG_CENTER_H_INCLUDED
