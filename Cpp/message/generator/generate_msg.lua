
require 'table'

simple_types_cpp =
{
	int8	= "char",
	uint8	= "unsigned char",
	int16	= "short",
	uint16	= "unsigned short",
	int32	= "int",
	uint32	= "unsigned int",
	int64	= "long long",
	uint64	= "unsigned long long",
	float	= "float",
	string	= "std::string",
}

simple_types_java =
{
	int8	= "byte",
	uint8	= "byte",
	int16	= "short",
	uint16	= "short",
	int32	= "int",
	uint32	= "int",
	int64	= "long",
	uint64	= "long",
	string	= "String",
}

simple_types = nil

function use_cpp_types()
	simple_types = simple_types_cpp
end

function use_java_types()
	simple_types = simple_types_java
end

function typename(param_type)
	return simple_types[param_type] or param_type
end

function typelength(param_type, param_name)
	if param_type == "int8" then
		return "sizeof(char)"
	elseif param_type == "uint8" then
		return "sizeof(unsigned char)"
	elseif param_type == "int16" then
		return "sizeof(short)"
	elseif param_type == "uint16" then
		return "sizeof(unsigned short)"
	elseif param_type == "int32" then
		return "sizeof(int)"
	elseif param_type == "uint32" then
		return "sizeof(unsigned int)"
	elseif param_type == "int64" then
		return "sizeof(long long)"
	elseif param_type == "uint64" then
		return "sizeof(unsigned long long)"
	elseif param_type == "string" then
		return "sizeof(short) + " .. param_name .. ".size()"
	elseif param_type == "ByteStream" then
		return "sizeof(int) + " .. param_name .. ".rsize()"
	else
		return param_name .. ".getLength()"
	end
end

use_cpp_types()

tags =
{
	--客户端服务器消息定义
	"Auth",
	"Login",
	"Scene",
	"Player",
	"Item",
	"Quest",
	"Guild",
	"Pet",
	"Test",
	"Shop",
	"Trade",
	"Team",
	"Activity",
	"World",
	"Relationship",
	"GMaster",
	"Mail",

	--数据库消息定义
	"DBAuth",
	"DBArena",
	"DBLogin",
	"DBPlayer",
	"DBItem",
	"DBQuest",
	"DBGuild",
	"DBPet",
	"DBTest",
	"DBWorld",
	"DBRelationship",
	"DBRecords",
	"DBMail",
	
	--跨服消息定义
	"Cross",
	"DBCross",
	"DBCenter",
}

messages = {}
messages_all = {}
messages_db = {}

--输出文件
local o = nil

--生成消息头文件
for _, tag in ipairs(tags) do
	local is_dbmsg = (string.sub(tag, 1, 2) == "DB")

	--编译消息定义文件, 返回chunck
	local define_filename = "define/" .. tag .. ".lua"
	local define_msg = loadfile(define_filename)
	if not define_msg then
		print ("compile messge define file failed ", define_filename)
		return
	end
	----执行消息定义文件
	define_msg()
	
	--打开输出文件
    local output_filename = "../Msg" .. tag .. ".h"
	local o = io.open(output_filename, "w")
	if not o then
		print ("cannot open output file ", output_filename)
		return
	end

	print("[", define_filename, "] -> [", output_filename, "]")

	--输出
    o:write("//\n")
	--o:write("//Generated by lua ", os.date("%Y-%m-%d, %H:%M:%S", os.time()), "\n")
	o:write("//Generated by lua\n")
	o:write("//2009-2012 (C) Ceapon Inc. Reserved\n")
	o:write("//\n")

	o:write("\n")
	o:write("#ifndef _MSG_", string.upper(tag), "_H_INCLUDED\n")
	o:write("#define _MSG_", string.upper(tag), "_H_INCLUDED\n")

	if not is_dbmsg then
		o:write("\n")
		o:write("#include \"common/Message.h\"\n")
		o:write("#include \"common/Logger.h\"\n")
		o:write("#include \"common/ByteStream.h\"\n")
		o:write("#include \"CommonType.h\"\n")
	else
		o:write("#include \"DBMessage.h\"\n")
	end

	o:write("\n")
	o:write("//#pragma pack(push, 1)\n")

	for _, msg in ipairs(messages) do
		o:write("\n")
		o:write("//\n")
		o:write("//Message Definition for ", msg.name, "\n")

		o:write("//\n")
		if msg.define == "struct" then
			o:write("struct ", msg.name)
		else
			o:write("class Msg", msg.name)
		end
		if msg.base then
			o:write(" : public ", msg.base, "\n")
		else
			o:write("\n")
		end

        o:write("{\n")
		o:write("public:\n")

		if msg.define == "class" then
			o:write("\tenum { Category = ", msg.category, ", Id = ", msg.id, " };\n")
		end

		--构造函数
		if msg.define == "struct" then
			o:write("\t", msg.name, "()\n")
		else
			o:write("\n")
			if msg.base then
				o:write("\tMsg", msg.name, "() :\n")
				o:write("\t\t", msg.base, "(Category, Id)\n")
			else
				o:write("\tMsg", msg.name, "()\n")
			end
		end
		o:write("\t{\n")
		for _, attr in ipairs(msg.attributes) do
			if attr.default then
				if attr.vector then
				elseif attr.array then
					o:write("\t\tfor (int i = 0; i < ", attr.array, "; ++i)\n")
					o:write("\t\t{\n")
					o:write("\t\t\t", attr.name, "[i] = ", attr.default, ";\n")
					o:write("\t\t}\n")
				else
					if attr.type ~= "ByteStream" then
						if attr.type == "string" then
							o:write("\t\t", attr.name, " = \"", attr.default, "\";\n")
						else
							o:write("\t\t", attr.name, " = ", attr.default, ";\n")
						end
					end
				end
			end
		end
		o:write("\t}\n")

		if msg.define == "class" then
			o:write("\n");
			o:write("\tvirtual const char *getName() const\n")
			o:write("\t{\n")
			o:write("\t\treturn \"Msg", msg.name, "\";\n")
			o:write("\t}\n")
		end

		if is_dbmsg then
			if msg.define == "class" then
				o:write("\n")
				o:write("\tvirtual int getThread()const\n")
				o:write("\t{\n")
				if not msg.thread then
					o:write("\t\treturn 3;\n")
				elseif msg.thread == "login" then
					o:write("\t\treturn 1;\n")
				elseif msg.thread == "load" then
					o:write("\t\treturn 2;\n")
				else
					o:write("\t\treturn 3;\n")
				end
				o:write("\t}\n")
			else
				o:write("\n")
				o:write("\t", msg.name, " &operator=(const ", msg.name, " &rhs)\n")
				o:write("\t{\n")
				if msg.base then
					o:write("\t\t(", msg.base, "&)(*this) = (", msg.base, "&) rhs;\n")
				end

				for _, attr in ipairs(msg.attributes) do
					if attr.array then
						o:write("\t\tfor (int i = 0; i < ", attr.array, "; ++i)\n")
						o:write("\t\t{\n")
						o:write("\t\t\t", attr.name, "[i] = rhs.", attr.name, "[i];\n")
						o:write("\t\t}\n")
					else
						o:write("\t\t", attr.name, " = rhs.", attr.name, ";\n")
					end
				end
				o:write("\t\treturn *this;\n")
				o:write("\t}\n")
			end
		end

		o:write("\n")
		if msg.define == "struct" then
			o:write("\tint getLength() const\n")
		else
			o:write("\tvirtual int getLength() const\n")
		end
		o:write("\t{\n")
		if msg.define == "struct" then
			o:write("\t\tint length = 0;\n")
		else
			if not is_dbmsg then
				o:write("\t\tint length = 6;\n")
			else
				o:write("\t\tint length = __super::getLength();\n")
			end
		end
		for _, attr in ipairs(msg.attributes) do
			if attr.vector then
				o:write("\t\tlength += sizeof(short);\n")
				o:write("\t\tfor (auto it = ", attr.name, ".begin(); it != ", attr.name, ".end(); ++it)\n")
				o:write("\t\t{\n")
				o:write("\t\t\tlength += ", typelength(attr.type, "(*it)"), ";\n")
				o:write("\t\t}\n")
			elseif attr.array then
				o:write("\t\tlength += sizeof(short);")
				o:write("\t\tfor (int i = 0; i < ", attr.array, "; ++i)\n")
				o:write("\t\t{\n")
				o:write("\t\t\tlength += ", typelength(attr.type, attr.name .. "[i]"), ";\n")
				o:write("\t\t}\n")
			else
				o:write("\t\tlength += ", typelength(attr.type, attr.name), ";\n")
			end
		end
		o:write("\t\treturn length;\n")
		o:write("\t}\n")

		o:write("\n")
		if msg.define == "struct" then
			o:write("\tbool serialize(ByteStream &s) const\n")
		else
			o:write("\tvirtual bool serialize(ByteStream &s) const\n")
		end
		o:write("\t{\n")
		if msg.define == "struct" then
			if msg.base then
				o:write("\t\t__super::serialize(s);\n")
			end
		else
		    if is_dbmsg then
    		    o:write("\t\t__super::serialize(s);\n")
		    end
		end
		for _,attr in ipairs(msg.attributes) do
			if attr.vector then
				o:write("\t\tshort ", attr.name, "_vector_size = ", attr.name, ".size();\n")
				o:write("\t\ts << ", attr.name, "_vector_size;\n")
				o:write("\t\tif (", attr.name, "_vector_size > 0)\n")
				o:write("\t\t{\n")
				o:write("\t\t\tfor (auto it = ", attr.name, ".begin(); it != ", attr.name, ".end(); ++it)\n")
				o:write("\t\t\t{\n")
				o:write("\t\t\t\ts << *it;\n")
				o:write("\t\t\t}\n")
				o:write("\t\t}\n")
			elseif attr.array then
				o:write("\t\tfor (int i = 0; i < ", attr.array, "; ++i)\n")
				o:write("\t\t{\n")
				o:write("\t\t\ts << ", attr.name, "[i];\n")
				o:write("\t\t}\n")
			elseif attr.type == "ByteStream" then
				o:write("\t\ts << (int)", attr.name, ".rsize();\n");
				o:write("\t\ts.write(", attr.name, ".rdata(), ", attr.name, ".rsize());\n");
			else
				o:write("\t\ts << ", attr.name, ";\n")
			end
		end
		o:write("\t\treturn true;\n")
		o:write("\t}\n")

		o:write("\n")
		if msg.define == "struct" then
			o:write("\tbool unserialize(ByteStream &s)\n")
		else
			o:write("\tvirtual bool unserialize(ByteStream &s)\n")
		end
		o:write("\t{\n")
		if msg.define=="struct" then
			if msg.base then
				o:write("\t\t__super::unserialize(s);\n")
			end
		else
		    if is_dbmsg then
    		    o:write("\t\t__super::unserialize(s);\n")
		    end
		end
		for _,attr in ipairs(msg.attributes) do
			if attr.vector then
				o:write("\t\tshort ", attr.name, "_vector_size = 0;\n")
				o:write("\t\ts >> ", attr.name, "_vector_size;\n")
				o:write("\t\t", attr.name, ".clear();\n")
				o:write("\t\twhile (", attr.name, "_vector_size > 0)\n")
				o:write("\t\t{\n")
				o:write("\t\t\t", attr.name, "_vector_size--;\n")
				o:write("\t\t\t", typename(attr.type), " val;\n")
				o:write("\t\t\t", "s >> val;\n")
				o:write("\t\t\t", attr.name, ".push_back(val);\n")
				o:write("\t\t}\n")
			elseif attr.array then
				o:write("\t\tfor (int i = 0; i < ", attr.array, "; ++i)\n")
				o:write("\t\t{\n")
				o:write("\t\t\ts >> ", attr.name, "[i];\n")
				o:write("\t\t}\n")
			elseif attr.type == "ByteStream" then
				o:write("\t\tint ", attr.name, "_size = 0;\n")
				o:write("\t\ts >> ", attr.name, "_size;\n")
				o:write("\t\t", attr.name, ".write(s.rdata(), ", attr.name, "_size);\n")
				o:write("\t\ts.read_skip(", attr.name, "_size);\n")
			else
				o:write("\t\ts >> ", attr.name, ";\n")
			end
		end
		o:write("\t\treturn true;\n")
		o:write("\t}\n")

		o:write("\n")
		if msg.define == "struct" then
			o:write("\tvoid dump()\n")
		else
			o:write("\tvirtual void dump()\n")
		end
		o:write("\t{\n")
		if msg.define == "struct" then
			if msg.base then
				o:write("\t\t__super::dump();\n")
			end
		else
			o:write("\t\tLOG_DEBUG(\"Msg", msg.name, "\");\n")
		end

		for _, attr in ipairs(msg.attributes) do
			if attr.dump then
				if attr.vector then
					o:write("\t\tLOG_DEBUG(\"", attr.name, " : \");\n")
					o:write("\t\tfor (auto it = ", attr.name, ".begin(); it != ", attr.name, ".end(); ++it)\n")
					o:write("\t\t{\n")
					o:write("\t\t\t*it.dump();\n")
					o:write("\t\t}\n")
				elseif attr.array then
					o:write("\t\tLOG_DEBUG(\"", attr.name, " : \");\n")
					o:write("\t\tfor (int i = 0; i < ", attr.array, "; ++i)\n")
					o:write("\t\t{\n")
					o:write("\t\t\t", attr.name, "[i].dump();\n")
					o:write("\t\t}\n")
				else
					if attr.type == "int8" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %d\", (int)", attr.name, ");\n")
					elseif attr.type == "uint8" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %u\", (unsigned int)", attr.name, ");\n")
					elseif attr.type == "int16" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %hd\", ", attr.name, ");\n")
					elseif attr.type == "uint16" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %hu\", ", attr.name, ");\n")
					elseif attr.type == "int32" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %d\", ", attr.name, ");\n")
					elseif attr.type == "uint32" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %u\", ", attr.name, ");\n")
					elseif attr.type == "int64" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %lld\", ", attr.name, ");\n")
					elseif attr.type == "uint64" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %llu\", ", attr.name, ");\n")
					elseif attr.type == "std::string" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %s\", ", attr.name, ".c_str());\n")
					elseif attr.type == "float" then
						o:write("\t\tLOG_DEBUG(\"", attr.name, " : %f\", ", attr.name, ");\n")
					end
				end
			end
		end
		o:write("\t}\n")
		
		--生成dump函数
		o:write("\n")
		if msg.define == "struct" then
			o:write("\tvoid dump(DumpBuffer &buffer)\n")
		else
			o:write("\tvirtual void dump(DumpBuffer &buffer)\n")
		end
		o:write("\t{\n")
		if msg.define == "struct" then
			if msg.base then
				o:write("\t\t__super::dump(buffer);\n")
			end
		--else
		--	o:write("\t\tLOG_DEBUG(\"Msg", msg.name, "\");\n")
		end
		local first_attr = true
		for _, attr in ipairs(msg.attributes) do
			if attr.vector then
				o:write("\t\tbuffer << \",", attr.name, "=[\";\n");
				o:write("\t\tfor (auto it = ", attr.name, ".begin(); it != ", attr.name, ".end(); ++it)\n")
				o:write("\t\t{\n")
				o:write("\t\t\tif (it == ", attr.name, ".begin())\n")
				o:write("\t\t\t{\n")
				o:write("\t\t\t\tbuffer << \"{\";\n");
				o:write("\t\t\t}\n")
				o:write("\t\t\telse\n")
				o:write("\t\t\t{\n")
				o:write("\t\t\t\tbuffer << \",{\";\n");
				o:write("\t\t\t}\n")
				if attr.type == "int8" or
				   attr.type == "uint8" or
				   attr.type == "int16" or
				   attr.type == "uint16" or
				   attr.type == "int32" or
				   attr.type == "uint32" or
				   attr.type == "int64" or
				   attr.type == "uint64" or
				   attr.type == "string" then
					o:write("\t\t\tbuffer << *it;\n")
				elseif attr.type == "ByteStream" then
				else
					o:write("\t\t\t(*it).dump(buffer);\n")
				end
				o:write("\t\t\tbuffer << \"}\";\n");
				o:write("\t\t}\n")
				o:write("\t\tbuffer << \"]\";\n");
			elseif attr.array then
				o:write("\t\tbuffer << \",", attr.name, "=[\";\n");
				o:write("\t\tfor (int i = 0; i < ", attr.array, "; ++i)\n")
				o:write("\t\t{\n")
				o:write("\t\t\tif (i == 0)\n")
				o:write("\t\t\t{\n")
				o:write("\t\t\t\tbuffer << \"{\";\n");
				o:write("\t\t\t}\n")
				o:write("\t\t\telse\n")
				o:write("\t\t\t{\n")
				o:write("\t\t\t\tbuffer << \",{\";\n");
				o:write("\t\t\t}\n")
				if attr.type == "int8" or
				   attr.type == "uint8" or
				   attr.type == "int16" or
				   attr.type == "uint16" or
				   attr.type == "int32" or
				   attr.type == "uint32" or
				   attr.type == "int64" or
				   attr.type == "uint64" or
				   attr.type == "string" then
					o:write("\t\t\tbuffer << ", attr.name, "[i];\n")
				elseif attr.type == "ByteStream" then
				else
					o:write("\t\t\t", attr.name, "[i].dump(buffer);\n")
				end
				o:write("\t\t\tbuffer << \"}\";\n");
				o:write("\t\t}\n")
				o:write("\t\tbuffer << \"]\";\n");
			else
				if attr.type == "int8" or
				   attr.type == "uint8" or
				   attr.type == "int16" or
				   attr.type == "uint16" or
				   attr.type == "int32" or
				   attr.type == "uint32" or
				   attr.type == "int64" or
				   attr.type == "uint64" or
				   attr.type == "string" then
					if first_attr and msg.define == "struct" then
						o:write("\t\tbuffer << \"", attr.name, "=\" << ", attr.name, ";\n")
					else
						o:write("\t\tbuffer << \",", attr.name, "=\" << ", attr.name, ";\n")
					end
				elseif attr.type == "ByteStream" then
				else
					if first_attr and msg.define == "struct" then
						o:write("\t\tbuffer << \"", attr.name, "={\";\n")
					else
						o:write("\t\tbuffer << \",", attr.name, "={\";\n")
					end
					o:write("\t\t", attr.name, ".dump(buffer);\n")
					o:write("\t\tbuffer << \"}\";\n")
				end
			end
			first_attr = false
		end
		o:write("\t}\n")

		--生成成员变量
		o:write("\n")
		o:write("public:\n")
		for _, attr in ipairs(msg.attributes) do
			if attr.vector then
				o:write("\tstd::vector<", typename(attr.type), "> ", attr.name, ";")
			elseif attr.array then
				o:write("\t", typename(attr.type), " ", attr.name, "[", attr.array, "];")
			else
				o:write("\t", typename(attr.type), " ", attr.name, ";")
			end
			
			if attr.desc then
				o:write("//", attr.desc, "\n")
			else
				o:write("\n")
			end
		end

		o:write("};\n")
	end

    o:write("\n")
	o:write("//#pragma pack(pop)\n")
    o:write("\n")
	o:write("#endif	//_MSG_", string.upper(tag), "_H_INCLUDED\n")

	o:close()

	table.insert(messages_all, messages)
end

messages = nil

--[[
--生成消息工厂头文件
local o = io.open("../message/MsgFactoryNetwork.h", "w")
if not o then
	print ("#####binding failed, invlaid output file : ", "../message/MsgFactoryNetwork.h")
	return
end
o:write("//\n")
o:write("//Generated by lua ", os.date("%Y-%m-%d, %H:%M:%S", os.time()), "\n")
o:write("//2009-2012 (C) Ceapon Inc. Reserved\n")
o:write("//\n")
o:write("#ifndef _MSG_FACTORY_NETWORK_H_INCLUDED\n")
o:write("#define _MSG_FACTORY_NETWORK_H_INCLUDED\n")
o:write("\n")
o:write("#include \"MsgFactory.h\"\n")
o:write("\n")
o:write("class MsgFactoryNetwork : public MsgFactory\n")
o:write("{\n")
o:write("public:\n")
o:write("		MsgFactoryNetwork();\n")
o:write("};\n")
o:write("\n")
o:write("extern MsgFactoryNetwork g_network_msg_factory;\n")
o:write("\n")
o:write("#endif	//_MSG_FACTORY_NETWORK_H_INCLUDED\n")
o:close()
--]]

--生成消息工厂实现文件
local o = io.open("../MsgFactory.cpp", "w")
if not o then
	print ("#####binding failed, invlaid output file : ", "../MsgFactory.cpp")
	return
end
o:write("//\n")
--o:write("//Generated by lua ", os.date("%Y-%m-%d, %H:%M:%S", os.time()), "\n")
o:write("//Generated by lua\n")
o:write("//2009-2012 (C) Ceapon Inc. Reserved\n")
o:write("//\n")
o:write("#include \"MsgFactory.h\"\n")
o:write("#include \"common/Logger.h\"\n")
for _, tag in ipairs(tags) do
	--local is_dbmsg = (string.sub(tag, 1, 2) == "DB")
	--if not is_dbmsg then
        o:write("#include \"Msg", tag, ".h\"\n")
    --end
end
o:write("\n")
o:write("MsgFactory g_msg_factory;\n")
o:write("\n")
o:write("MsgFactory::MsgFactory()\n")
o:write("{\n")
for _, messages in ipairs(messages_all) do
	for _, msg in ipairs(messages) do
		if msg.define == "class" then
			local msgname = "Msg"..msg.name
			local msgc = msgname.."::Category"
			local msgi = msgname.."::Id"
            o:write("\tregisterMsg(", msgc, ", ", msgi, ", create<", msgname, ">);\n")
		end
	end
end
o:write("}\n")
o:write("\n")
o:write("MsgFactory::~MsgFactory()\n")
o:write("{\n")
o:write("}\n")
o:write("\n")
o:write("Message *MsgFactory::createMsg(int category, int id)\n")
o:write("{\n")
o:write("\tint creator_id = (category << 16) | id;\n")
o:write("\n")
o:write("\tauto it = m_creator_map.find(creator_id);\n")
o:write("\tif (it == m_creator_map.end())\n")
o:write("\t{\n")
o:write("\t\treturn NULL;\n")
o:write("\t}\n")
o:write("\n")
o:write("\tMessageCreator func = it->second;\n")
o:write("\n")
o:write("\treturn func();\n")
o:write("}\n")
o:write("\n")
o:write("void MsgFactory::registerMsg(int category, int id, MessageCreator creator)\n")
o:write("{\n")
o:write("\tint creator_id = (category << 16) | id;\n")
o:write("\n")
o:write("\tif (m_creator_map.find(creator_id) != m_creator_map.end())\n")
o:write("\t{\n")
o:write("\t\tLOG_ERROR(\"MsgFactory::registerMsg, duplicate message cate: %d, id: %d !\", category, id);\n")
o:write("\treturn;\n")
o:write("\t}\n")
o:write("\n")
o:write("\tm_creator_map[creator_id] = creator;\n")
o:write("}\n")
o:write("\n")
o:close()
