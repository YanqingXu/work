//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _DB_MSG_LOGIN_H_INCLUDED
#define _DB_MSG_LOGIN_H_INCLUDED

#include "category.h"
#include "common/MessageEx.h"

struct DBPlayerData
{
public:
	DBPlayerData()
	{
		pid = 0;
		serverID = 0;
		mclass = 0;
		gender = 0;
		sceneid = 0;
		posx = 0;
		posy = 0;
		coin = 0;
		ingot = 0;
		boundingot = 0;
		boundcoin = 0;
		honor = 0;
		guildid = 0;
		ctime = 0;
		level = 0;
		reborn = 0;
		exp = 0;
		weapon = 0;
		wings = 0;
		cloth = 0;
		team = 0;
		is_transfer = 0;
		zhandui_id = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 95;
		length += sizeof(short) + name.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << serverID;
		s << mclass;
		s << name;
		s << gender;
		s << sceneid;
		s << posx;
		s << posy;
		s << coin;
		s << ingot;
		s << boundingot;
		s << boundcoin;
		s << honor;
		s << guildid;
		s << ctime;
		s << level;
		s << reborn;
		s << exp;
		s << weapon;
		s << wings;
		s << cloth;
		s << team;
		s << is_transfer;
		s << zhandui_id;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> serverID;
		s >> mclass;
		s >> name;
		s >> gender;
		s >> sceneid;
		s >> posx;
		s >> posy;
		s >> coin;
		s >> ingot;
		s >> boundingot;
		s >> boundcoin;
		s >> honor;
		s >> guildid;
		s >> ctime;
		s >> level;
		s >> reborn;
		s >> exp;
		s >> weapon;
		s >> wings;
		s >> cloth;
		s >> team;
		s >> is_transfer;
		s >> zhandui_id;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverID", serverID);
		lua::settable(L, -1, "mclass", mclass);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "sceneid", sceneid);
		lua::settable(L, -1, "posx", posx);
		lua::settable(L, -1, "posy", posy);
		lua::settable(L, -1, "coin", coin);
		lua::settable(L, -1, "ingot", ingot);
		lua::settable(L, -1, "boundingot", boundingot);
		lua::settable(L, -1, "boundcoin", boundcoin);
		lua::settable(L, -1, "honor", honor);
		lua::settable(L, -1, "guildid", guildid);
		lua::settable(L, -1, "ctime", ctime);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "reborn", reborn);
		lua::settable(L, -1, "exp", exp);
		lua::settable(L, -1, "weapon", weapon);
		lua::settable(L, -1, "wings", wings);
		lua::settable(L, -1, "cloth", cloth);
		lua::settable(L, -1, "team", team);
		lua::settable(L, -1, "is_transfer", is_transfer);
		lua::settable(L, -1, "zhandui_id", zhandui_id);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",serverID=" << serverID;
		buffer << ",mclass=" << mclass;
		buffer << ",name=" << name;
		buffer << ",gender=" << gender;
		buffer << ",sceneid=" << sceneid;
		buffer << ",posx=" << posx;
		buffer << ",posy=" << posy;
		buffer << ",coin=" << coin;
		buffer << ",ingot=" << ingot;
		buffer << ",boundingot=" << boundingot;
		buffer << ",boundcoin=" << boundcoin;
		buffer << ",honor=" << honor;
		buffer << ",guildid=" << guildid;
		buffer << ",ctime=" << ctime;
		buffer << ",level=" << level;
		buffer << ",reborn=" << reborn;
		buffer << ",exp=" << exp;
		buffer << ",weapon=" << weapon;
		buffer << ",wings=" << wings;
		buffer << ",cloth=" << cloth;
		buffer << ",team=" << team;
		buffer << ",is_transfer=" << is_transfer;
		buffer << ",zhandui_id=" << zhandui_id;
	}

public:
	int pid;
	int serverID;
	short mclass;
	std::string name;
	char gender;
	int sceneid;
	short posx;
	short posy;
	long long coin;
	int ingot;
	int boundingot;
	long long boundcoin;
	int honor;
	int guildid;
	int ctime;
	int level;
	int reborn;
	long long exp;
	int weapon;
	int wings;
	int cloth;
	int team;
	int is_transfer;
	int zhandui_id;
};

class MsgDBLoadPlayerList : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 1 };

	MsgDBLoadPlayerList() :
		MessageEx(Category, Id)
	{
		aid = 0;
		channelid = 0;
		platformid = 0;
		serverID = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerList";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return aid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 16;
		length += sizeof(int);
		for (size_t i = 0; i < players.size(); ++i)
		{
			length += players[i].getLength(true);
		}
		length += sizeof(short) + deviceid.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << aid;
		int players_vector_size = (int)players.size();
		s << players_vector_size;
		if (players_vector_size > 0)
		{
			for (auto it = players.begin(); it != players.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		s << channelid;
		s << deviceid;
		s << platformid;
		s << serverID;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> aid;
		int players_vector_size = s.read_int32();
		players.clear();
		while (players_vector_size > 0)
		{
			players_vector_size--;
			DBPlayerData val;
			val.unserialize(s, true);
			players.push_back(val);
		}
		s >> channelid;
		s >> deviceid;
		s >> platformid;
		s >> serverID;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < players.size(); ++i)
		{
			players[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "players");
		lua::settable(L, -1, "channelid", channelid);
		lua::settable(L, -1, "deviceid", deviceid);
		lua::settable(L, -1, "platformid", platformid);
		lua::settable(L, -1, "serverID", serverID);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",aid=" << aid;
		buffer << ",players=[";
		for (size_t i = 0; i < players.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			players[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",channelid=" << channelid;
		buffer << ",deviceid=" << deviceid;
		buffer << ",platformid=" << platformid;
		buffer << ",serverID=" << serverID;
	}

public:
	int aid;
	std::vector<DBPlayerData> players;
	int channelid;
	std::string deviceid;
	int platformid;
	int serverID;
};

class MsgDBLoadPlayer : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 2 };

	MsgDBLoadPlayer() :
		MessageEx(Category, Id)
	{
		channelid = 0;
		platformid = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 12;
		length += sizeof(short) + deviceid.size();
		length += player.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << channelid;
		s << deviceid;
		s << platformid;
		s << pid;
		player.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> channelid;
		s >> deviceid;
		s >> platformid;
		s >> pid;
		player.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelid", channelid);
		lua::settable(L, -1, "deviceid", deviceid);
		lua::settable(L, -1, "platformid", platformid);
		lua::settable(L, -1, "pid", pid);
		player.push(L);
		lua::settable(L, -1, "player");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",channelid=" << channelid;
		buffer << ",deviceid=" << deviceid;
		buffer << ",platformid=" << platformid;
		buffer << ",pid=" << pid;
		buffer << ",player={";
		player.dump(buffer);
		buffer << "}";
	}

public:
	int channelid;
	std::string deviceid;
	int platformid;
	int pid;
	DBPlayerData player;
};

class MsgDBCreatePlayer : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 3 };

	MsgDBCreatePlayer() :
		MessageEx(Category, Id)
	{
		pid = 0;
		aid = 0;
		channelid = 0;
		platformid = 0;
		serverID = 0;
		recharge_return_original_ingot = 0;
		recharge_return_ingot = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBCreatePlayer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 28;
		length += sizeof(short) + deviceid.size();
		length += sizeof(short) + code.size();
		length += player.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << aid;
		s << channelid;
		s << deviceid;
		s << platformid;
		s << serverID;
		s << recharge_return_original_ingot;
		s << recharge_return_ingot;
		s << code;
		player.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> aid;
		s >> channelid;
		s >> deviceid;
		s >> platformid;
		s >> serverID;
		s >> recharge_return_original_ingot;
		s >> recharge_return_ingot;
		s >> code;
		player.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "channelid", channelid);
		lua::settable(L, -1, "deviceid", deviceid);
		lua::settable(L, -1, "platformid", platformid);
		lua::settable(L, -1, "serverID", serverID);
		lua::settable(L, -1, "recharge_return_original_ingot", recharge_return_original_ingot);
		lua::settable(L, -1, "recharge_return_ingot", recharge_return_ingot);
		lua::settable(L, -1, "code", code);
		player.push(L);
		lua::settable(L, -1, "player");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",aid=" << aid;
		buffer << ",channelid=" << channelid;
		buffer << ",deviceid=" << deviceid;
		buffer << ",platformid=" << platformid;
		buffer << ",serverID=" << serverID;
		buffer << ",recharge_return_original_ingot=" << recharge_return_original_ingot;
		buffer << ",recharge_return_ingot=" << recharge_return_ingot;
		buffer << ",code=" << code;
		buffer << ",player={";
		player.dump(buffer);
		buffer << "}";
	}

public:
	int pid;
	int aid;
	int channelid;
	std::string deviceid;
	int platformid;
	int serverID;
	int recharge_return_original_ingot;
	int recharge_return_ingot;
	std::string code;
	DBPlayerData player;
};

class MsgDBDeletePlayer : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 4 };

	MsgDBDeletePlayer() :
		MessageEx(Category, Id)
	{
		aid = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBDeletePlayer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << aid;
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> aid;
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",aid=" << aid;
		buffer << ",pid=" << pid;
	}

public:
	int aid;
	int pid;
};

class MsgDBLoadPlayerByName : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 5 };

	MsgDBLoadPlayerByName() :
		MessageEx(Category, Id)
	{
		aid = 0;
		pid = 0;
		mclass = 0;
		gender = 0;
		sceneid = 0;
		coin = 0;
		ingot = 0;
		boundingot = 0;
		boundcoin = 0;
		honor = 0;
		guildid = 0;
		state = 0;
		ctime = 0;
		level = 0;
		reborn = 0;
		exp = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerByName";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 71;
		length += sizeof(short) + name.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << name;
		s << aid;
		s << pid;
		s << mclass;
		s << gender;
		s << sceneid;
		s << coin;
		s << ingot;
		s << boundingot;
		s << boundcoin;
		s << honor;
		s << guildid;
		s << state;
		s << ctime;
		s << level;
		s << reborn;
		s << exp;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> name;
		s >> aid;
		s >> pid;
		s >> mclass;
		s >> gender;
		s >> sceneid;
		s >> coin;
		s >> ingot;
		s >> boundingot;
		s >> boundcoin;
		s >> honor;
		s >> guildid;
		s >> state;
		s >> ctime;
		s >> level;
		s >> reborn;
		s >> exp;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "mclass", mclass);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "sceneid", sceneid);
		lua::settable(L, -1, "coin", coin);
		lua::settable(L, -1, "ingot", ingot);
		lua::settable(L, -1, "boundingot", boundingot);
		lua::settable(L, -1, "boundcoin", boundcoin);
		lua::settable(L, -1, "honor", honor);
		lua::settable(L, -1, "guildid", guildid);
		lua::settable(L, -1, "state", state);
		lua::settable(L, -1, "ctime", ctime);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "reborn", reborn);
		lua::settable(L, -1, "exp", exp);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",name=" << name;
		buffer << ",aid=" << aid;
		buffer << ",pid=" << pid;
		buffer << ",mclass=" << mclass;
		buffer << ",gender=" << gender;
		buffer << ",sceneid=" << sceneid;
		buffer << ",coin=" << coin;
		buffer << ",ingot=" << ingot;
		buffer << ",boundingot=" << boundingot;
		buffer << ",boundcoin=" << boundcoin;
		buffer << ",honor=" << honor;
		buffer << ",guildid=" << guildid;
		buffer << ",state=" << state;
		buffer << ",ctime=" << ctime;
		buffer << ",level=" << level;
		buffer << ",reborn=" << reborn;
		buffer << ",exp=" << exp;
	}

public:
	std::string name;
	int aid;
	int pid;
	short mclass;
	char gender;
	int sceneid;
	long long coin;
	int ingot;
	int boundingot;
	long long boundcoin;
	int honor;
	int guildid;
	int state;
	int ctime;
	int level;
	int reborn;
	long long exp;
};

class MsgDBSetPlayerState : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 6 };

	MsgDBSetPlayerState() :
		MessageEx(Category, Id)
	{
		pid = 0;
		aid = 0;
		state = 0;
		result = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBSetPlayerState";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << aid;
		s << state;
		s << result;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> aid;
		s >> state;
		s >> result;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "state", state);
		lua::settable(L, -1, "result", result);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",aid=" << aid;
		buffer << ",state=" << state;
		buffer << ",result=" << result;
	}

public:
	int pid;
	int aid;
	int state;
	int result;
};

class MsgDBLoadDummyPlayer : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 7 };

	MsgDBLoadDummyPlayer() :
		MessageEx(Category, Id)
	{
		scene_instance_id = 0;
		posx = 0;
		posy = 0;
		entity_id = 0;
		pid = 0;
		aid = 0;
		exercise = 0;
		taoweaplv = 0;
		taoweappro = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadDummyPlayer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 32;
		length += player.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << scene_instance_id;
		s << posx;
		s << posy;
		s << entity_id;
		s << pid;
		s << aid;
		s << exercise;
		s << taoweaplv;
		s << taoweappro;
		player.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> scene_instance_id;
		s >> posx;
		s >> posy;
		s >> entity_id;
		s >> pid;
		s >> aid;
		s >> exercise;
		s >> taoweaplv;
		s >> taoweappro;
		player.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "scene_instance_id", scene_instance_id);
		lua::settable(L, -1, "posx", posx);
		lua::settable(L, -1, "posy", posy);
		lua::settable(L, -1, "entity_id", entity_id);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "exercise", exercise);
		lua::settable(L, -1, "taoweaplv", taoweaplv);
		lua::settable(L, -1, "taoweappro", taoweappro);
		player.push(L);
		lua::settable(L, -1, "player");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",scene_instance_id=" << scene_instance_id;
		buffer << ",posx=" << posx;
		buffer << ",posy=" << posy;
		buffer << ",entity_id=" << entity_id;
		buffer << ",pid=" << pid;
		buffer << ",aid=" << aid;
		buffer << ",exercise=" << exercise;
		buffer << ",taoweaplv=" << taoweaplv;
		buffer << ",taoweappro=" << taoweappro;
		buffer << ",player={";
		player.dump(buffer);
		buffer << "}";
	}

public:
	int scene_instance_id;
	short posx;
	short posy;
	int entity_id;
	int pid;
	int aid;
	int exercise;
	int taoweaplv;
	int taoweappro;
	DBPlayerData player;
};

class MsgDBLoadAllTuoguanPlayer : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 8 };

	MsgDBLoadAllTuoguanPlayer() :
		MessageEx(Category, Id)
	{
		channelid = 0;
		platformid = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadAllTuoguanPlayer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 12;
		length += sizeof(short) + deviceid.size();
		length += sizeof(int);
		for (size_t i = 0; i < player.size(); ++i)
		{
			length += player[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << channelid;
		s << deviceid;
		s << platformid;
		s << pid;
		int player_vector_size = (int)player.size();
		s << player_vector_size;
		if (player_vector_size > 0)
		{
			for (auto it = player.begin(); it != player.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> channelid;
		s >> deviceid;
		s >> platformid;
		s >> pid;
		int player_vector_size = s.read_int32();
		player.clear();
		while (player_vector_size > 0)
		{
			player_vector_size--;
			DBPlayerData val;
			val.unserialize(s, true);
			player.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelid", channelid);
		lua::settable(L, -1, "deviceid", deviceid);
		lua::settable(L, -1, "platformid", platformid);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < player.size(); ++i)
		{
			player[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "player");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",channelid=" << channelid;
		buffer << ",deviceid=" << deviceid;
		buffer << ",platformid=" << platformid;
		buffer << ",pid=" << pid;
		buffer << ",player=[";
		for (size_t i = 0; i < player.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			player[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int channelid;
	std::string deviceid;
	int platformid;
	int pid;
	std::vector<DBPlayerData> player;
};

class MsgDBChangeJob : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_LOGIN, Id = 10 };

	MsgDBChangeJob() :
		MessageEx(Category, Id)
	{
		pid = 0;
		job = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBChangeJob";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << job;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> job;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "job", job);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",job=" << job;
	}

public:
	int pid;
	int job;
};

#endif	//_DB_MSG_LOGIN_H_INCLUDED
