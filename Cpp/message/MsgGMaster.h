//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _MSG_G_MASTER_H_INCLUDED
#define _MSG_G_MASTER_H_INCLUDED

#include "category.h"
#include "common/Message.h"

class MsgGetCodeGiftFromAsRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 40 };

	MsgGetCodeGiftFromAsRequest() :
		Message(Category, Id)
	{
		ServerID = 0;
		pid = 0;
		sid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetCodeGiftFromAsRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 12;
		length += sizeof(short) + code.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << ServerID;
		s << pid;
		s << sid;
		s << code;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> ServerID;
		s >> pid;
		s >> sid;
		s >> code;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ServerID", ServerID);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "code", code);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "ServerID=" << ServerID;
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",code=" << code;
	}

public:
	int ServerID;
	int pid;
	int sid;
	std::string code;
};

struct GiftData
{
public:
	GiftData()
	{
		sid = 0;
		cnt = 0;
		isbind = 0;
	}

	size_t getLength(bool ex) const
	{
		return 12;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << sid;
		s << cnt;
		s << isbind;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> sid;
		s >> cnt;
		s >> isbind;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "cnt", cnt);
		lua::settable(L, -1, "isbind", isbind);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "sid=" << sid;
		buffer << ",cnt=" << cnt;
		buffer << ",isbind=" << isbind;
	}

public:
	int sid;
	int cnt;
	int isbind;
};

struct KeyValueData
{
public:
	KeyValueData()
	{
	}

	size_t getLength(bool ex) const
	{
		size_t length = 0;
		length += sizeof(short) + key.size();
		length += sizeof(short) + value.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << key;
		s << value;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> key;
		s >> value;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "key", key);
		lua::settable(L, -1, "value", value);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "key=" << key;
		buffer << ",value=" << value;
	}

public:
	std::string key;
	std::string value;
};

class MsgGetCodeGiftFromAsResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 41 };

	MsgGetCodeGiftFromAsResponse() :
		Message(Category, Id)
	{
		ServerID = 0;
		pid = 0;
		sid = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetCodeGiftFromAsResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 16;
		length += sizeof(short) + code.size();
		length += sizeof(short);
		for (size_t i = 0; i < GiftList.size(); ++i)
		{
			length += GiftList[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << ServerID;
		s << pid;
		s << sid;
		s << errcode;
		s << code;
		short GiftList_vector_size = (short)GiftList.size();
		s << GiftList_vector_size;
		if (GiftList_vector_size > 0)
		{
			for (auto it = GiftList.begin(); it != GiftList.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> ServerID;
		s >> pid;
		s >> sid;
		s >> errcode;
		s >> code;
		int GiftList_vector_size = s.read_int16();
		GiftList.clear();
		while (GiftList_vector_size > 0)
		{
			GiftList_vector_size--;
			GiftData val;
			val.unserialize(s, false);
			GiftList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ServerID", ServerID);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "code", code);
		lua::newtable(lua::L);
		for (size_t i = 0; i < GiftList.size(); ++i)
		{
			GiftList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "GiftList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "ServerID=" << ServerID;
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",errcode=" << errcode;
		buffer << ",code=" << code;
		buffer << ",GiftList=[";
		for (size_t i = 0; i < GiftList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			GiftList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int ServerID;
	int pid;
	int sid;
	int errcode;
	std::string code;
	std::vector<GiftData> GiftList;
};

class MsgGetCodeGiftResultToAsNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 42 };

	MsgGetCodeGiftResultToAsNotify() :
		Message(Category, Id)
	{
		ServerID = 0;
		pid = 0;
		sid = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetCodeGiftResultToAsNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 16;
		length += sizeof(short) + code.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << ServerID;
		s << pid;
		s << sid;
		s << code;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> ServerID;
		s >> pid;
		s >> sid;
		s >> code;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ServerID", ServerID);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "code", code);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "ServerID=" << ServerID;
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",code=" << code;
		buffer << ",errcode=" << errcode;
	}

public:
	int ServerID;
	int pid;
	int sid;
	std::string code;
	int errcode;
};

class MsgRechargeReturnRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 43 };

	MsgRechargeReturnRequest() :
		Message(Category, Id)
	{
		aid = 0;
		channel_id = 0;
		client_session_id = 0;
		player_class = 0;
		player_gender = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRechargeReturnRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 15;
		length += sizeof(short) + begin_time.size();
		length += sizeof(short) + end_time.size();
		length += sizeof(short) + player_name.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << aid;
		s << channel_id;
		s << begin_time;
		s << end_time;
		s << client_session_id;
		s << player_class;
		s << player_name;
		s << player_gender;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> aid;
		s >> channel_id;
		s >> begin_time;
		s >> end_time;
		s >> client_session_id;
		s >> player_class;
		s >> player_name;
		s >> player_gender;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "channel_id", channel_id);
		lua::settable(L, -1, "begin_time", begin_time);
		lua::settable(L, -1, "end_time", end_time);
		lua::settable(L, -1, "client_session_id", client_session_id);
		lua::settable(L, -1, "player_class", player_class);
		lua::settable(L, -1, "player_name", player_name);
		lua::settable(L, -1, "player_gender", player_gender);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "aid=" << aid;
		buffer << ",channel_id=" << channel_id;
		buffer << ",begin_time=" << begin_time;
		buffer << ",end_time=" << end_time;
		buffer << ",client_session_id=" << client_session_id;
		buffer << ",player_class=" << player_class;
		buffer << ",player_name=" << player_name;
		buffer << ",player_gender=" << player_gender;
	}

public:
	int aid; //账号ID 
	int channel_id; //渠道ID 
	std::string begin_time; //开始时间 
	std::string end_time; //结束时间 
	int client_session_id; //玩家会话ID 
	short player_class; //玩家职业 
	std::string player_name; //玩家名称 
	char player_gender; //玩家性别 
};

class MsgRechargeReturnResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 44 };

	MsgRechargeReturnResponse() :
		Message(Category, Id)
	{
		aid = 0;
		channel_id = 0;
		client_session_id = 0;
		player_class = 0;
		player_gender = 0;
		recharge = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRechargeReturnResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 19;
		length += sizeof(short) + begin_time.size();
		length += sizeof(short) + end_time.size();
		length += sizeof(short) + player_name.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << aid;
		s << channel_id;
		s << begin_time;
		s << end_time;
		s << client_session_id;
		s << player_class;
		s << player_name;
		s << player_gender;
		s << recharge;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> aid;
		s >> channel_id;
		s >> begin_time;
		s >> end_time;
		s >> client_session_id;
		s >> player_class;
		s >> player_name;
		s >> player_gender;
		s >> recharge;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "channel_id", channel_id);
		lua::settable(L, -1, "begin_time", begin_time);
		lua::settable(L, -1, "end_time", end_time);
		lua::settable(L, -1, "client_session_id", client_session_id);
		lua::settable(L, -1, "player_class", player_class);
		lua::settable(L, -1, "player_name", player_name);
		lua::settable(L, -1, "player_gender", player_gender);
		lua::settable(L, -1, "recharge", recharge);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "aid=" << aid;
		buffer << ",channel_id=" << channel_id;
		buffer << ",begin_time=" << begin_time;
		buffer << ",end_time=" << end_time;
		buffer << ",client_session_id=" << client_session_id;
		buffer << ",player_class=" << player_class;
		buffer << ",player_name=" << player_name;
		buffer << ",player_gender=" << player_gender;
		buffer << ",recharge=" << recharge;
	}

public:
	int aid; //账号ID 
	int channel_id; //渠道ID 
	std::string begin_time; //开始时间 
	std::string end_time; //结束时间 
	int client_session_id; //玩家会话ID 
	short player_class; //玩家职业 
	std::string player_name; //玩家名称 
	char player_gender; //玩家性别 
	int recharge; //充值金额 
};

class MsgRechargeRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 121 };

	MsgRechargeRequest() :
		Message(Category, Id)
	{
		pid = 0;
		sid = 0;
		cnt = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRechargeRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 12;
		length += sizeof(short) + OrderSerial.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << sid;
		s << cnt;
		s << OrderSerial;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> sid;
		s >> cnt;
		s >> OrderSerial;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "cnt", cnt);
		lua::settable(L, -1, "OrderSerial", OrderSerial);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",cnt=" << cnt;
		buffer << ",OrderSerial=" << OrderSerial;
	}

public:
	int pid;
	int sid;
	int cnt;
	std::string OrderSerial;
};

class MsgRechargeResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 122 };

	MsgRechargeResponse() :
		Message(Category, Id)
	{
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRechargeResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 2;
		length += sizeof(short) + OrderSerial.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << errcode;
		s << OrderSerial;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> errcode;
		s >> OrderSerial;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "OrderSerial", OrderSerial);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "errcode=" << errcode;
		buffer << ",OrderSerial=" << OrderSerial;
	}

public:
	short errcode;
	std::string OrderSerial;
};

class MsgPlayerLoginLogoutNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 130 };

	MsgPlayerLoginLogoutNotify() :
		Message(Category, Id)
	{
		type = 0;
		aid = 0;
		pid = 0;
		serverId = 0;
		channelId = 0;
		platformId = 0;
		time = 0;
	}

	virtual const char *getName() const
	{
		return "MsgPlayerLoginLogoutNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 26;
		length += sizeof(short) + name.size();
		length += sizeof(short) + deviceId.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << type;
		s << aid;
		s << pid;
		s << name;
		s << deviceId;
		s << serverId;
		s << channelId;
		s << platformId;
		s << time;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> type;
		s >> aid;
		s >> pid;
		s >> name;
		s >> deviceId;
		s >> serverId;
		s >> channelId;
		s >> platformId;
		s >> time;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "channelId", channelId);
		lua::settable(L, -1, "platformId", platformId);
		lua::settable(L, -1, "time", time);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "type=" << type;
		buffer << ",aid=" << aid;
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",deviceId=" << deviceId;
		buffer << ",serverId=" << serverId;
		buffer << ",channelId=" << channelId;
		buffer << ",platformId=" << platformId;
		buffer << ",time=" << time;
	}

public:
	short type;
	int aid;
	int pid;
	std::string name;
	std::string deviceId;
	int serverId;
	int channelId;
	int platformId;
	int time;
};

class MsgPlayerCreateDeleteNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 131 };

	MsgPlayerCreateDeleteNotify() :
		Message(Category, Id)
	{
		type = 0;
		aid = 0;
		pid = 0;
		career = 0;
		serverId = 0;
		channelId = 0;
		platformId = 0;
		time = 0;
	}

	virtual const char *getName() const
	{
		return "MsgPlayerCreateDeleteNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 30;
		length += sizeof(short) + name.size();
		length += sizeof(short) + deviceId.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << type;
		s << aid;
		s << pid;
		s << name;
		s << career;
		s << deviceId;
		s << serverId;
		s << channelId;
		s << platformId;
		s << time;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> type;
		s >> aid;
		s >> pid;
		s >> name;
		s >> career;
		s >> deviceId;
		s >> serverId;
		s >> channelId;
		s >> platformId;
		s >> time;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "career", career);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "channelId", channelId);
		lua::settable(L, -1, "platformId", platformId);
		lua::settable(L, -1, "time", time);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "type=" << type;
		buffer << ",aid=" << aid;
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",career=" << career;
		buffer << ",deviceId=" << deviceId;
		buffer << ",serverId=" << serverId;
		buffer << ",channelId=" << channelId;
		buffer << ",platformId=" << platformId;
		buffer << ",time=" << time;
	}

public:
	short type;
	int aid;
	int pid;
	std::string name;
	int career;
	std::string deviceId;
	int serverId;
	int channelId;
	int platformId;
	int time;
};

class MsgAuthRewardDataNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 140 };

	MsgAuthRewardDataNotify() :
		Message(Category, Id)
	{
		rewardid = 0;
		ismail = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAuthRewardDataNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + rewardname.size();
		length += sizeof(short);
		for (size_t i = 0; i < GiftList.size(); ++i)
		{
			length += GiftList[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << rewardid;
		s << rewardname;
		s << ismail;
		short GiftList_vector_size = (short)GiftList.size();
		s << GiftList_vector_size;
		if (GiftList_vector_size > 0)
		{
			for (auto it = GiftList.begin(); it != GiftList.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> rewardid;
		s >> rewardname;
		s >> ismail;
		int GiftList_vector_size = s.read_int16();
		GiftList.clear();
		while (GiftList_vector_size > 0)
		{
			GiftList_vector_size--;
			GiftData val;
			val.unserialize(s, false);
			GiftList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "rewardid", rewardid);
		lua::settable(L, -1, "rewardname", rewardname);
		lua::settable(L, -1, "ismail", ismail);
		lua::newtable(lua::L);
		for (size_t i = 0; i < GiftList.size(); ++i)
		{
			GiftList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "GiftList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "rewardid=" << rewardid;
		buffer << ",rewardname=" << rewardname;
		buffer << ",ismail=" << ismail;
		buffer << ",GiftList=[";
		for (size_t i = 0; i < GiftList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			GiftList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int rewardid;
	std::string rewardname;
	int ismail;
	std::vector<GiftData> GiftList;
};

class MsgGetAuthRewardDataRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 141 };

	MsgGetAuthRewardDataRequest() :
		Message(Category, Id)
	{
		rewardid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetAuthRewardDataRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << rewardid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> rewardid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "rewardid", rewardid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "rewardid=" << rewardid;
	}

public:
	int rewardid;
};

class MsgSendPlayerGiftRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 142 };

	MsgSendPlayerGiftRequest() :
		Message(Category, Id)
	{
		pid = 0;
		rewardid = 0;
		endtime = 0;
		isbind = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendPlayerGiftRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << rewardid;
		s << endtime;
		s << isbind;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> rewardid;
		s >> endtime;
		s >> isbind;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "rewardid", rewardid);
		lua::settable(L, -1, "endtime", endtime);
		lua::settable(L, -1, "isbind", isbind);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",rewardid=" << rewardid;
		buffer << ",endtime=" << endtime;
		buffer << ",isbind=" << isbind;
	}

public:
	int pid;
	int rewardid;
	int endtime;
	int isbind;
};

class MsgSendSystemMsgNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 143 };

	MsgSendSystemMsgNotify() :
		Message(Category, Id)
	{
		type = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendSystemMsgNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + msg.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << type;
		s << msg;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> type;
		s >> msg;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "msg", msg);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "type=" << type;
		buffer << ",msg=" << msg;
	}

public:
	int type;
	std::string msg;
};

class MsgGMsendToPlayer : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 144 };

	MsgGMsendToPlayer() :
		Message(Category, Id)
	{
		playerid = 0;
		gmid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMsendToPlayer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + content.size();
		length += sizeof(short) + gm.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << playerid;
		s << content;
		s << gmid;
		s << gm;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> playerid;
		s >> content;
		s >> gmid;
		s >> gm;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerid", playerid);
		lua::settable(L, -1, "content", content);
		lua::settable(L, -1, "gmid", gmid);
		lua::settable(L, -1, "gm", gm);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "playerid=" << playerid;
		buffer << ",content=" << content;
		buffer << ",gmid=" << gmid;
		buffer << ",gm=" << gm;
	}

public:
	int playerid;
	std::string content;
	int gmid;
	std::string gm;
};

class MsgPlayersendToGM : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 145 };

	MsgPlayersendToGM() :
		Message(Category, Id)
	{
		pid = 0;
		aid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgPlayersendToGM";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 12;
		length += sizeof(short) + content.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << aid;
		s << serverid;
		s << content;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> aid;
		s >> serverid;
		s >> content;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "serverid", serverid);
		lua::settable(L, -1, "content", content);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",aid=" << aid;
		buffer << ",serverid=" << serverid;
		buffer << ",content=" << content;
	}

public:
	int pid;
	int aid;
	int serverid;
	std::string content;
};

class MsgSendPlayerGiftOnlineRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 146 };

	MsgSendPlayerGiftOnlineRequest() :
		Message(Category, Id)
	{
		rewardid = 0;
		endtime = 0;
		gender = 0;
		job = 0;
		lvlMin = 0;
		lvlMax = 0;
		rebornMin = 0;
		rebornMax = 0;
		channelId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendPlayerGiftOnlineRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 36;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << rewardid;
		s << endtime;
		s << gender;
		s << job;
		s << lvlMin;
		s << lvlMax;
		s << rebornMin;
		s << rebornMax;
		s << channelId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> rewardid;
		s >> endtime;
		s >> gender;
		s >> job;
		s >> lvlMin;
		s >> lvlMax;
		s >> rebornMin;
		s >> rebornMax;
		s >> channelId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "rewardid", rewardid);
		lua::settable(L, -1, "endtime", endtime);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "lvlMin", lvlMin);
		lua::settable(L, -1, "lvlMax", lvlMax);
		lua::settable(L, -1, "rebornMin", rebornMin);
		lua::settable(L, -1, "rebornMax", rebornMax);
		lua::settable(L, -1, "channelId", channelId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "rewardid=" << rewardid;
		buffer << ",endtime=" << endtime;
		buffer << ",gender=" << gender;
		buffer << ",job=" << job;
		buffer << ",lvlMin=" << lvlMin;
		buffer << ",lvlMax=" << lvlMax;
		buffer << ",rebornMin=" << rebornMin;
		buffer << ",rebornMax=" << rebornMax;
		buffer << ",channelId=" << channelId;
	}

public:
	int rewardid;
	int endtime;
	int gender;
	int job;
	int lvlMin;
	int lvlMax;
	int rebornMin;
	int rebornMax;
	int channelId;
};

class MsgSendMail : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 147 };

	MsgSendMail() :
		Message(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendMail";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + title.size();
		length += sizeof(short) + content.size();
		length += sizeof(short) + items.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << title;
		s << content;
		s << items;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> title;
		s >> content;
		s >> items;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "title", title);
		lua::settable(L, -1, "content", content);
		lua::settable(L, -1, "items", items);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",title=" << title;
		buffer << ",content=" << content;
		buffer << ",items=" << items;
	}

public:
	int pid; //玩家ID 
	std::string title; //邮件标题 
	std::string content; //邮件内容 
	std::string items; //邮件附件: 物品ID;物品ID*数量;物品ID*数量,属性ID=属性值; 
};

class MsgGetSensitiveWordsRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 151 };

	MsgGetSensitiveWordsRequest() :
		Message(Category, Id)
	{
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetSensitiveWordsRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << serverid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> serverid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverid", serverid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverid=" << serverid;
	}

public:
	int serverid;
};

class MsgGetSensitiveWordsResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 152 };

	MsgGetSensitiveWordsResponse() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGetSensitiveWordsResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		for (size_t i = 0; i < words.size(); ++i)
		{
			length += sizeof(short) + words[i].size();
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short words_vector_size = (short)words.size();
		s << words_vector_size;
		if (words_vector_size > 0)
		{
			for (auto it = words.begin(); it != words.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int words_vector_size = s.read_int16();
		words.clear();
		while (words_vector_size > 0)
		{
			words_vector_size--;
			std::string val;
			s >> val;
			words.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < words.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, words[i]);
		}
		lua::settable(L, -2, "words");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "words=[";
		for (size_t i = 0; i < words.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << words[i];
		}
		buffer << "]";
	}

public:
	std::vector<std::string> words;
};

class MsgGMGetPlayerInfoRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 200 };

	MsgGMGetPlayerInfoRequest() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMGetPlayerInfoRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short) + playername.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << playername;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> playername;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playername", playername);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "playername=" << playername;
	}

public:
	std::string playername;
};

class MsgGMGetPlayerInfoResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 201 };

	MsgGMGetPlayerInfoResponse() :
		Message(Category, Id)
	{
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMGetPlayerInfoResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + playername.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << playername;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> playername;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playername", playername);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "playername=" << playername;
		buffer << ",errcode=" << errcode;
	}

public:
	std::string playername;
	int errcode;
};

class MsgGMPlayerBaseInfoNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 202 };

	MsgGMPlayerBaseInfoNotify() :
		Message(Category, Id)
	{
		aid = 0;
		pid = 0;
		job = 0;
		gender = 0;
		lvl = 0;
		reborn = 0;
		currentexp = 0;
		money = 0;
		gold = 0;
		createtime = 0;
		lastLogouttime = 0;
		vip = 0;
		honor = 0;
		pkvalue = 0;
		rebornsoul = 0;
		honorlvl = 0;
		coupon = 0;
		jifen = 0;
		boss_score = 0;
		boss_score_level = 0;
		stone_chip = 0;
		soul_chip = 0;
		blood_chip = 0;
		hudun_chip = 0;
		wings_bless = 0;
		wings_level = 0;
		xb_happness = 0;
		soul_value = 0;
		achievement_points = 0;
		mars = 0;
		exercise = 0;
		exercise_level = 0;
		gongxun = 0;
		gongxun_level = 0;
		mohun = 0;
		hero_wings_bless = 0;
		hero_wings_level = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMPlayerBaseInfoNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 160;
		length += sizeof(short) + playername.size();
		length += sizeof(short) + guildname.size();
		length += sizeof(short) + mapname.size();
		length += sizeof(short) + equip_stone.size();
		length += sizeof(short) + equip_soul_bead.size();
		length += sizeof(short) + equip_phylactery.size();
		length += sizeof(short) + equip_shield.size();
		length += sizeof(short) + equip_medal.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << aid;
		s << pid;
		s << playername;
		s << job;
		s << gender;
		s << lvl;
		s << reborn;
		s << currentexp;
		s << guildname;
		s << money;
		s << gold;
		s << createtime;
		s << lastLogouttime;
		s << mapname;
		s << vip;
		s << honor;
		s << pkvalue;
		s << rebornsoul;
		s << honorlvl;
		s << coupon;
		s << jifen;
		s << boss_score;
		s << boss_score_level;
		s << stone_chip;
		s << equip_stone;
		s << soul_chip;
		s << equip_soul_bead;
		s << blood_chip;
		s << equip_phylactery;
		s << hudun_chip;
		s << equip_shield;
		s << wings_bless;
		s << wings_level;
		s << xb_happness;
		s << soul_value;
		s << achievement_points;
		s << equip_medal;
		s << mars;
		s << exercise;
		s << exercise_level;
		s << gongxun;
		s << gongxun_level;
		s << mohun;
		s << hero_wings_bless;
		s << hero_wings_level;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> aid;
		s >> pid;
		s >> playername;
		s >> job;
		s >> gender;
		s >> lvl;
		s >> reborn;
		s >> currentexp;
		s >> guildname;
		s >> money;
		s >> gold;
		s >> createtime;
		s >> lastLogouttime;
		s >> mapname;
		s >> vip;
		s >> honor;
		s >> pkvalue;
		s >> rebornsoul;
		s >> honorlvl;
		s >> coupon;
		s >> jifen;
		s >> boss_score;
		s >> boss_score_level;
		s >> stone_chip;
		s >> equip_stone;
		s >> soul_chip;
		s >> equip_soul_bead;
		s >> blood_chip;
		s >> equip_phylactery;
		s >> hudun_chip;
		s >> equip_shield;
		s >> wings_bless;
		s >> wings_level;
		s >> xb_happness;
		s >> soul_value;
		s >> achievement_points;
		s >> equip_medal;
		s >> mars;
		s >> exercise;
		s >> exercise_level;
		s >> gongxun;
		s >> gongxun_level;
		s >> mohun;
		s >> hero_wings_bless;
		s >> hero_wings_level;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "playername", playername);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "lvl", lvl);
		lua::settable(L, -1, "reborn", reborn);
		lua::settable(L, -1, "currentexp", currentexp);
		lua::settable(L, -1, "guildname", guildname);
		lua::settable(L, -1, "money", money);
		lua::settable(L, -1, "gold", gold);
		lua::settable(L, -1, "createtime", createtime);
		lua::settable(L, -1, "lastLogouttime", lastLogouttime);
		lua::settable(L, -1, "mapname", mapname);
		lua::settable(L, -1, "vip", vip);
		lua::settable(L, -1, "honor", honor);
		lua::settable(L, -1, "pkvalue", pkvalue);
		lua::settable(L, -1, "rebornsoul", rebornsoul);
		lua::settable(L, -1, "honorlvl", honorlvl);
		lua::settable(L, -1, "coupon", coupon);
		lua::settable(L, -1, "jifen", jifen);
		lua::settable(L, -1, "boss_score", boss_score);
		lua::settable(L, -1, "boss_score_level", boss_score_level);
		lua::settable(L, -1, "stone_chip", stone_chip);
		lua::settable(L, -1, "equip_stone", equip_stone);
		lua::settable(L, -1, "soul_chip", soul_chip);
		lua::settable(L, -1, "equip_soul_bead", equip_soul_bead);
		lua::settable(L, -1, "blood_chip", blood_chip);
		lua::settable(L, -1, "equip_phylactery", equip_phylactery);
		lua::settable(L, -1, "hudun_chip", hudun_chip);
		lua::settable(L, -1, "equip_shield", equip_shield);
		lua::settable(L, -1, "wings_bless", wings_bless);
		lua::settable(L, -1, "wings_level", wings_level);
		lua::settable(L, -1, "xb_happness", xb_happness);
		lua::settable(L, -1, "soul_value", soul_value);
		lua::settable(L, -1, "achievement_points", achievement_points);
		lua::settable(L, -1, "equip_medal", equip_medal);
		lua::settable(L, -1, "mars", mars);
		lua::settable(L, -1, "exercise", exercise);
		lua::settable(L, -1, "exercise_level", exercise_level);
		lua::settable(L, -1, "gongxun", gongxun);
		lua::settable(L, -1, "gongxun_level", gongxun_level);
		lua::settable(L, -1, "mohun", mohun);
		lua::settable(L, -1, "hero_wings_bless", hero_wings_bless);
		lua::settable(L, -1, "hero_wings_level", hero_wings_level);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "aid=" << aid;
		buffer << ",pid=" << pid;
		buffer << ",playername=" << playername;
		buffer << ",job=" << job;
		buffer << ",gender=" << gender;
		buffer << ",lvl=" << lvl;
		buffer << ",reborn=" << reborn;
		buffer << ",currentexp=" << currentexp;
		buffer << ",guildname=" << guildname;
		buffer << ",money=" << money;
		buffer << ",gold=" << gold;
		buffer << ",createtime=" << createtime;
		buffer << ",lastLogouttime=" << lastLogouttime;
		buffer << ",mapname=" << mapname;
		buffer << ",vip=" << vip;
		buffer << ",honor=" << honor;
		buffer << ",pkvalue=" << pkvalue;
		buffer << ",rebornsoul=" << rebornsoul;
		buffer << ",honorlvl=" << honorlvl;
		buffer << ",coupon=" << coupon;
		buffer << ",jifen=" << jifen;
		buffer << ",boss_score=" << boss_score;
		buffer << ",boss_score_level=" << boss_score_level;
		buffer << ",stone_chip=" << stone_chip;
		buffer << ",equip_stone=" << equip_stone;
		buffer << ",soul_chip=" << soul_chip;
		buffer << ",equip_soul_bead=" << equip_soul_bead;
		buffer << ",blood_chip=" << blood_chip;
		buffer << ",equip_phylactery=" << equip_phylactery;
		buffer << ",hudun_chip=" << hudun_chip;
		buffer << ",equip_shield=" << equip_shield;
		buffer << ",wings_bless=" << wings_bless;
		buffer << ",wings_level=" << wings_level;
		buffer << ",xb_happness=" << xb_happness;
		buffer << ",soul_value=" << soul_value;
		buffer << ",achievement_points=" << achievement_points;
		buffer << ",equip_medal=" << equip_medal;
		buffer << ",mars=" << mars;
		buffer << ",exercise=" << exercise;
		buffer << ",exercise_level=" << exercise_level;
		buffer << ",gongxun=" << gongxun;
		buffer << ",gongxun_level=" << gongxun_level;
		buffer << ",mohun=" << mohun;
		buffer << ",hero_wings_bless=" << hero_wings_bless;
		buffer << ",hero_wings_level=" << hero_wings_level;
	}

public:
	int aid; //账号ID 
	int pid; //玩家ID 
	std::string playername; //玩家名称 
	short job; //玩家职业 
	short gender; //玩家性别 
	int lvl; //玩家等级 
	int reborn; //玩家转生等级 
	long long currentexp; //玩家经验 
	std::string guildname; //玩家所属行会名称 
	long long money; //玩家金币 
	int gold; //玩家元宝 
	int createtime; //玩家创建时间 
	int lastLogouttime; //玩家最后登出时间 
	std::string mapname; //玩家当前地图 
	int vip; //玩家VIP等级 
	int honor; //玩家荣誉 
	int pkvalue; //玩家PK值 
	int rebornsoul; //玩家转生修为 
	int honorlvl; //玩家荣誉等级 
	long long coupon; //玩家绑金 
	int jifen; //玩家绑元 
	int boss_score; //玩家BOSS积分 
	int boss_score_level; //玩家BOSS积分等级 
	int stone_chip; //宝石碎片 
	std::string equip_stone; //宝石 
	int soul_chip; //魂珠碎片 
	std::string equip_soul_bead; //魂珠 
	int blood_chip; //血符碎片 
	std::string equip_phylactery; //血符 
	int hudun_chip; //护盾碎片 
	std::string equip_shield; //护盾 
	int wings_bless; //翅膀祝福值 
	int wings_level; //翅膀等级 
	int xb_happness; //宝藏积分 
	int soul_value; //灵力值 
	int achievement_points; //玩家成就积分 
	std::string equip_medal; //玩家成就勋章 
	int mars; //玩家战神等级 
	long long exercise; //内功值 
	int exercise_level; //内功等级 
	int gongxun; //功勋值 
	int gongxun_level; //功勋称号 
	int mohun; //魔魂值(战魂值) 
	int hero_wings_bless; //英雄翅膀祝福值 
	int hero_wings_level; //英雄翅膀等级 
};

class MsgGMPlayerCombatDataInfoNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 203 };

	MsgGMPlayerCombatDataInfoNotify() :
		Message(Category, Id)
	{
		cbtnum = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMPlayerCombatDataInfoNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short);
		length += cbtdata.size() * 4;
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << cbtnum;
		short cbtdata_vector_size = (short)cbtdata.size();
		s << cbtdata_vector_size;
		if (cbtdata_vector_size > 0)
		{
			for (auto it = cbtdata.begin(); it != cbtdata.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> cbtnum;
		int cbtdata_vector_size = s.read_int16();
		cbtdata.clear();
		while (cbtdata_vector_size > 0)
		{
			cbtdata_vector_size--;
			int val;
			s >> val;
			cbtdata.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "cbtnum", cbtnum);
		lua::newtable(lua::L);
		for (size_t i = 0; i < cbtdata.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, cbtdata[i]);
		}
		lua::settable(L, -2, "cbtdata");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "cbtnum=" << cbtnum;
		buffer << ",cbtdata=[";
		for (size_t i = 0; i < cbtdata.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << cbtdata[i];
		}
		buffer << "]";
	}

public:
	int cbtnum;
	std::vector<int> cbtdata;
};

struct GMItemData
{
public:
	GMItemData()
	{
		ItemPos = 0;
		iid = 0;
		itemcnt = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 12;
		length += sizeof(short) + itemname.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << ItemPos;
		s << iid;
		s << itemname;
		s << itemcnt;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> ItemPos;
		s >> iid;
		s >> itemname;
		s >> itemcnt;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ItemPos", ItemPos);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "itemname", itemname);
		lua::settable(L, -1, "itemcnt", itemcnt);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "ItemPos=" << ItemPos;
		buffer << ",iid=" << iid;
		buffer << ",itemname=" << itemname;
		buffer << ",itemcnt=" << itemcnt;
	}

public:
	int ItemPos;
	int iid;
	std::string itemname;
	int itemcnt;
};

class MsgGMPlayerItemInfoNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 204 };

	MsgGMPlayerItemInfoNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMPlayerItemInfoNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		for (size_t i = 0; i < items.size(); ++i)
		{
			length += items[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short items_vector_size = (short)items.size();
		s << items_vector_size;
		if (items_vector_size > 0)
		{
			for (auto it = items.begin(); it != items.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int items_vector_size = s.read_int16();
		items.clear();
		while (items_vector_size > 0)
		{
			items_vector_size--;
			GMItemData val;
			val.unserialize(s, false);
			items.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < items.size(); ++i)
		{
			items[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "items");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "items=[";
		for (size_t i = 0; i < items.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			items[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<GMItemData> items;
};

struct GMItemExData
{
public:
	GMItemExData()
	{
		idx = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 6;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << idx;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> idx;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "idx=" << idx;
		buffer << ",data=" << data;
	}

public:
	short idx;
	int data;
};

struct GMSkillInfo
{
public:
	GMSkillInfo()
	{
		skilllvl = 0;
		exp = 0;
		maxexp = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 12;
		length += sizeof(short) + skillname.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << skillname;
		s << skilllvl;
		s << exp;
		s << maxexp;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> skillname;
		s >> skilllvl;
		s >> exp;
		s >> maxexp;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "skillname", skillname);
		lua::settable(L, -1, "skilllvl", skilllvl);
		lua::settable(L, -1, "exp", exp);
		lua::settable(L, -1, "maxexp", maxexp);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "skillname=" << skillname;
		buffer << ",skilllvl=" << skilllvl;
		buffer << ",exp=" << exp;
		buffer << ",maxexp=" << maxexp;
	}

public:
	std::string skillname;
	int skilllvl;
	int exp;
	int maxexp;
};

class MsgGMPlayerSkillNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 205 };

	MsgGMPlayerSkillNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMPlayerSkillNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		for (size_t i = 0; i < skills.size(); ++i)
		{
			length += skills[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short skills_vector_size = (short)skills.size();
		s << skills_vector_size;
		if (skills_vector_size > 0)
		{
			for (auto it = skills.begin(); it != skills.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int skills_vector_size = s.read_int16();
		skills.clear();
		while (skills_vector_size > 0)
		{
			skills_vector_size--;
			GMSkillInfo val;
			val.unserialize(s, false);
			skills.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < skills.size(); ++i)
		{
			skills[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "skills");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "skills=[";
		for (size_t i = 0; i < skills.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			skills[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<GMSkillInfo> skills;
};

struct GMPetData
{
public:
	GMPetData()
	{
		petlvl = 0;
		petid = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 8;
		length += sizeof(short) + petname.size();
		length += sizeof(short) + petrename.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << petname;
		s << petrename;
		s << petlvl;
		s << petid;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> petname;
		s >> petrename;
		s >> petlvl;
		s >> petid;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "petname", petname);
		lua::settable(L, -1, "petrename", petrename);
		lua::settable(L, -1, "petlvl", petlvl);
		lua::settable(L, -1, "petid", petid);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "petname=" << petname;
		buffer << ",petrename=" << petrename;
		buffer << ",petlvl=" << petlvl;
		buffer << ",petid=" << petid;
	}

public:
	std::string petname;
	std::string petrename;
	int petlvl;
	int petid;
};

class MsgGMPlayerPetInfoNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 206 };

	MsgGMPlayerPetInfoNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMPlayerPetInfoNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		for (size_t i = 0; i < pets.size(); ++i)
		{
			length += pets[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short pets_vector_size = (short)pets.size();
		s << pets_vector_size;
		if (pets_vector_size > 0)
		{
			for (auto it = pets.begin(); it != pets.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int pets_vector_size = s.read_int16();
		pets.clear();
		while (pets_vector_size > 0)
		{
			pets_vector_size--;
			GMPetData val;
			val.unserialize(s, false);
			pets.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < pets.size(); ++i)
		{
			pets[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "pets");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pets=[";
		for (size_t i = 0; i < pets.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			pets[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<GMPetData> pets;
};

class MsgGMLoadPlayerInfoOverNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 207 };

	MsgGMLoadPlayerInfoOverNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMLoadPlayerInfoOverNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

class MsgGMCommondRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 208 };

	MsgGMCommondRequest() :
		Message(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMCommondRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + commond.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << commond;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> commond;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "commond", commond);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",commond=" << commond;
	}

public:
	int pid;
	std::string commond;
};

class MsgGMCommondResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 209 };

	MsgGMCommondResponse() :
		Message(Category, Id)
	{
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMCommondResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "errcode=" << errcode;
	}

public:
	int errcode;
};

class MsgCloseServerRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 210 };

	MsgCloseServerRequest() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgCloseServerRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

class MsgGetServerPlayerCntRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 220 };

	MsgGetServerPlayerCntRequest() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGetServerPlayerCntRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

class MsgGetServerPlayerCntResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 221 };

	MsgGetServerPlayerCntResponse() :
		Message(Category, Id)
	{
		playercnt = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetServerPlayerCntResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << playercnt;
		s << serverid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> playercnt;
		s >> serverid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playercnt", playercnt);
		lua::settable(L, -1, "serverid", serverid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "playercnt=" << playercnt;
		buffer << ",serverid=" << serverid;
	}

public:
	int playercnt;
	int serverid;
};

struct GMOnlineNumByChannel
{
public:
	GMOnlineNumByChannel()
	{
		channelid = 0;
		playercnt = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << channelid;
		s << playercnt;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> channelid;
		s >> playercnt;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "channelid", channelid);
		lua::settable(L, -1, "playercnt", playercnt);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "channelid=" << channelid;
		buffer << ",playercnt=" << playercnt;
	}

public:
	int channelid;
	int playercnt;
};

class MsgGetChannelPlayerCntRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 224 };

	MsgGetChannelPlayerCntRequest() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGetChannelPlayerCntRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short) + token.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << token;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> token;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "token", token);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "token=" << token;
	}

public:
	std::string token;
};

class MsgGetChannelPlayerCntResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 225 };

	MsgGetChannelPlayerCntResponse() :
		Message(Category, Id)
	{
		serverId = 0;
		onlineTotal = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetChannelPlayerCntResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short);
		for (size_t i = 0; i < channelNum.size(); ++i)
		{
			length += channelNum[i].getLength(false);
		}
		length += sizeof(short) + token.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << serverId;
		s << onlineTotal;
		short channelNum_vector_size = (short)channelNum.size();
		s << channelNum_vector_size;
		if (channelNum_vector_size > 0)
		{
			for (auto it = channelNum.begin(); it != channelNum.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		s << token;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> serverId;
		s >> onlineTotal;
		int channelNum_vector_size = s.read_int16();
		channelNum.clear();
		while (channelNum_vector_size > 0)
		{
			channelNum_vector_size--;
			GMOnlineNumByChannel val;
			val.unserialize(s, false);
			channelNum.push_back(val);
		}
		s >> token;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "onlineTotal", onlineTotal);
		lua::newtable(lua::L);
		for (size_t i = 0; i < channelNum.size(); ++i)
		{
			channelNum[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "channelNum");
		lua::settable(L, -1, "token", token);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverId=" << serverId;
		buffer << ",onlineTotal=" << onlineTotal;
		buffer << ",channelNum=[";
		for (size_t i = 0; i < channelNum.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			channelNum[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",token=" << token;
	}

public:
	int serverId;
	int onlineTotal;
	std::vector<GMOnlineNumByChannel> channelNum;
	std::string token;
};

class MsgGMRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 226 };

	MsgGMRequest() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short) + request.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << request;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> request;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "request", request);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "request=" << request;
	}

public:
	std::string request;
};

class MsgGMResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 227 };

	MsgGMResponse() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short) + response.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << response;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> response;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "response", response);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "response=" << response;
	}

public:
	std::string response;
};

class MsgGMPing : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 228 };

	MsgGMPing() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMPing";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

class MsgGMPong : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 229 };

	MsgGMPong() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMPong";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

class MsgGMGetPlayerInfoRequestNew : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 300 };

	MsgGMGetPlayerInfoRequestNew() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMGetPlayerInfoRequestNew";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short) + playername.size();
		length += sizeof(short) + type.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << playername;
		s << type;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> playername;
		s >> type;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playername", playername);
		lua::settable(L, -1, "type", type);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "playername=" << playername;
		buffer << ",type=" << type;
	}

public:
	std::string playername;
	std::string type;
};

class MsgGMGetPlayerInfoResponseNew : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 301 };

	MsgGMGetPlayerInfoResponseNew() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMGetPlayerInfoResponseNew";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short) + playername.size();
		length += sizeof(short) + type.size();
		length += sizeof(short) + subtype.size();
		length += sizeof(short);
		for (size_t i = 0; i < data.size(); ++i)
		{
			length += data[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << playername;
		s << type;
		s << subtype;
		short data_vector_size = (short)data.size();
		s << data_vector_size;
		if (data_vector_size > 0)
		{
			for (auto it = data.begin(); it != data.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> playername;
		s >> type;
		s >> subtype;
		int data_vector_size = s.read_int16();
		data.clear();
		while (data_vector_size > 0)
		{
			data_vector_size--;
			KeyValueData val;
			val.unserialize(s, false);
			data.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playername", playername);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "subtype", subtype);
		lua::newtable(lua::L);
		for (size_t i = 0; i < data.size(); ++i)
		{
			data[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "data");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "playername=" << playername;
		buffer << ",type=" << type;
		buffer << ",subtype=" << subtype;
		buffer << ",data=[";
		for (size_t i = 0; i < data.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			data[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::string playername;
	std::string type;
	std::string subtype;
	std::vector<KeyValueData> data;
};

class MsgGMRecordInfoResponseNew : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 302 };

	MsgGMRecordInfoResponseNew() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMRecordInfoResponseNew";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short) + playername.size();
		length += sizeof(short) + type.size();
		length += sizeof(short) + subtype.size();
		length += sizeof(short);
		for (size_t i = 0; i < title.size(); ++i)
		{
			length += sizeof(short) + title[i].size();
		}
		length += sizeof(short);
		for (size_t i = 0; i < data.size(); ++i)
		{
			length += sizeof(short) + data[i].size();
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << playername;
		s << type;
		s << subtype;
		short title_vector_size = (short)title.size();
		s << title_vector_size;
		if (title_vector_size > 0)
		{
			for (auto it = title.begin(); it != title.end(); ++it)
			{
				s << *it;
			}
		}
		short data_vector_size = (short)data.size();
		s << data_vector_size;
		if (data_vector_size > 0)
		{
			for (auto it = data.begin(); it != data.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> playername;
		s >> type;
		s >> subtype;
		int title_vector_size = s.read_int16();
		title.clear();
		while (title_vector_size > 0)
		{
			title_vector_size--;
			std::string val;
			s >> val;
			title.push_back(val);
		}
		int data_vector_size = s.read_int16();
		data.clear();
		while (data_vector_size > 0)
		{
			data_vector_size--;
			std::string val;
			s >> val;
			data.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playername", playername);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "subtype", subtype);
		lua::newtable(lua::L);
		for (size_t i = 0; i < title.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, title[i]);
		}
		lua::settable(L, -2, "title");
		lua::newtable(lua::L);
		for (size_t i = 0; i < data.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, data[i]);
		}
		lua::settable(L, -2, "data");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "playername=" << playername;
		buffer << ",type=" << type;
		buffer << ",subtype=" << subtype;
		buffer << ",title=[";
		for (size_t i = 0; i < title.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << title[i];
		}
		buffer << "]";
		buffer << ",data=[";
		for (size_t i = 0; i < data.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << data[i];
		}
		buffer << "]";
	}

public:
	std::string playername;
	std::string type;
	std::string subtype;
	std::vector<std::string> title;
	std::vector<std::string> data;
};

struct GMHolidayProp
{
public:
	GMHolidayProp()
	{
		idx = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 4;
		length += sizeof(short) + value.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << idx;
		s << value;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> idx;
		s >> value;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "value", value);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "idx=" << idx;
		buffer << ",value=" << value;
	}

public:
	int idx;
	std::string value;
};

struct GMHolidayItem
{
public:
	GMHolidayItem()
	{
		index = 0;
		static_id = 0;
		count = 0;
		bind = 0;
		type = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			length += vprop[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << index;
		s << static_id;
		s << count;
		s << bind;
		s << type;
		int vprop_vector_size = ex ? (int)vprop.size() : (short)vprop.size();
		if (ex)
		{
			s << vprop_vector_size;
		}
		else
		{
			s << (short)vprop_vector_size;
		}
		if (vprop_vector_size > 0)
		{
			for (auto it = vprop.begin(); it != vprop.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> index;
		s >> static_id;
		s >> count;
		s >> bind;
		s >> type;
		int vprop_vector_size = ex ? s.read_int32() : s.read_int16();
		vprop.clear();
		while (vprop_vector_size > 0)
		{
			vprop_vector_size--;
			GMHolidayProp val;
			val.unserialize(s, ex);
			vprop.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "index", index);
		lua::settable(L, -1, "static_id", static_id);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "bind", bind);
		lua::settable(L, -1, "type", type);
		lua::newtable(lua::L);
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			vprop[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "vprop");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "index=" << index;
		buffer << ",static_id=" << static_id;
		buffer << ",count=" << count;
		buffer << ",bind=" << bind;
		buffer << ",type=" << type;
		buffer << ",vprop=[";
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			vprop[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int index;
	int static_id;
	int count;
	int bind;
	int type;
	std::vector<GMHolidayProp> vprop;
};

struct GMHolidayGrade
{
public:
	GMHolidayGrade()
	{
		index = 0;
		mark = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 8;
		length += sizeof(short) + content.size();
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			length += vprop[i].getLength(ex);
		}
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < vitem.size(); ++i)
		{
			length += vitem[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << index;
		s << mark;
		s << content;
		int vprop_vector_size = ex ? (int)vprop.size() : (short)vprop.size();
		if (ex)
		{
			s << vprop_vector_size;
		}
		else
		{
			s << (short)vprop_vector_size;
		}
		if (vprop_vector_size > 0)
		{
			for (auto it = vprop.begin(); it != vprop.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		int vitem_vector_size = ex ? (int)vitem.size() : (short)vitem.size();
		if (ex)
		{
			s << vitem_vector_size;
		}
		else
		{
			s << (short)vitem_vector_size;
		}
		if (vitem_vector_size > 0)
		{
			for (auto it = vitem.begin(); it != vitem.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> index;
		s >> mark;
		s >> content;
		int vprop_vector_size = ex ? s.read_int32() : s.read_int16();
		vprop.clear();
		while (vprop_vector_size > 0)
		{
			vprop_vector_size--;
			GMHolidayProp val;
			val.unserialize(s, ex);
			vprop.push_back(val);
		}
		int vitem_vector_size = ex ? s.read_int32() : s.read_int16();
		vitem.clear();
		while (vitem_vector_size > 0)
		{
			vitem_vector_size--;
			GMHolidayItem val;
			val.unserialize(s, ex);
			vitem.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "index", index);
		lua::settable(L, -1, "mark", mark);
		lua::settable(L, -1, "content", content);
		lua::newtable(lua::L);
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			vprop[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "vprop");
		lua::newtable(lua::L);
		for (size_t i = 0; i < vitem.size(); ++i)
		{
			vitem[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "vitem");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "index=" << index;
		buffer << ",mark=" << mark;
		buffer << ",content=" << content;
		buffer << ",vprop=[";
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			vprop[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",vitem=[";
		for (size_t i = 0; i < vitem.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			vitem[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int index;
	int mark;
	std::string content;
	std::vector<GMHolidayProp> vprop;
	std::vector<GMHolidayItem> vitem;
};

struct GMHoliday
{
public:
	GMHoliday()
	{
		mark = 0;
		type = 0;
		state = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 12;
		length += sizeof(short) + str_menu.size();
		length += sizeof(short) + str_title.size();
		length += sizeof(short) + str_content.size();
		length += sizeof(short) + begin_time.size();
		length += sizeof(short) + begin_show_time.size();
		length += sizeof(short) + end_time.size();
		length += sizeof(short) + end_show_time.size();
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			length += vprop[i].getLength(ex);
		}
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < vgrade.size(); ++i)
		{
			length += vgrade[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << mark;
		s << type;
		s << str_menu;
		s << str_title;
		s << str_content;
		s << begin_time;
		s << begin_show_time;
		s << end_time;
		s << end_show_time;
		s << state;
		int vprop_vector_size = ex ? (int)vprop.size() : (short)vprop.size();
		if (ex)
		{
			s << vprop_vector_size;
		}
		else
		{
			s << (short)vprop_vector_size;
		}
		if (vprop_vector_size > 0)
		{
			for (auto it = vprop.begin(); it != vprop.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		int vgrade_vector_size = ex ? (int)vgrade.size() : (short)vgrade.size();
		if (ex)
		{
			s << vgrade_vector_size;
		}
		else
		{
			s << (short)vgrade_vector_size;
		}
		if (vgrade_vector_size > 0)
		{
			for (auto it = vgrade.begin(); it != vgrade.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> mark;
		s >> type;
		s >> str_menu;
		s >> str_title;
		s >> str_content;
		s >> begin_time;
		s >> begin_show_time;
		s >> end_time;
		s >> end_show_time;
		s >> state;
		int vprop_vector_size = ex ? s.read_int32() : s.read_int16();
		vprop.clear();
		while (vprop_vector_size > 0)
		{
			vprop_vector_size--;
			GMHolidayProp val;
			val.unserialize(s, ex);
			vprop.push_back(val);
		}
		int vgrade_vector_size = ex ? s.read_int32() : s.read_int16();
		vgrade.clear();
		while (vgrade_vector_size > 0)
		{
			vgrade_vector_size--;
			GMHolidayGrade val;
			val.unserialize(s, ex);
			vgrade.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "mark", mark);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "str_menu", str_menu);
		lua::settable(L, -1, "str_title", str_title);
		lua::settable(L, -1, "str_content", str_content);
		lua::settable(L, -1, "begin_time", begin_time);
		lua::settable(L, -1, "begin_show_time", begin_show_time);
		lua::settable(L, -1, "end_time", end_time);
		lua::settable(L, -1, "end_show_time", end_show_time);
		lua::settable(L, -1, "state", state);
		lua::newtable(lua::L);
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			vprop[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "vprop");
		lua::newtable(lua::L);
		for (size_t i = 0; i < vgrade.size(); ++i)
		{
			vgrade[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "vgrade");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "mark=" << mark;
		buffer << ",type=" << type;
		buffer << ",str_menu=" << str_menu;
		buffer << ",str_title=" << str_title;
		buffer << ",str_content=" << str_content;
		buffer << ",begin_time=" << begin_time;
		buffer << ",begin_show_time=" << begin_show_time;
		buffer << ",end_time=" << end_time;
		buffer << ",end_show_time=" << end_show_time;
		buffer << ",state=" << state;
		buffer << ",vprop=[";
		for (size_t i = 0; i < vprop.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			vprop[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",vgrade=[";
		for (size_t i = 0; i < vgrade.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			vgrade[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int mark;
	int type;
	std::string str_menu;
	std::string str_title;
	std::string str_content;
	std::string begin_time;
	std::string begin_show_time;
	std::string end_time;
	std::string end_show_time;
	int state;
	std::vector<GMHolidayProp> vprop;
	std::vector<GMHolidayGrade> vgrade;
};

class MsgUpdateGMHolidayRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 400 };

	MsgUpdateGMHolidayRequest() :
		Message(Category, Id)
	{
		mark_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgUpdateGMHolidayRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << mark_id;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> mark_id;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "mark_id", mark_id);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "mark_id=" << mark_id;
	}

public:
	int mark_id;
};

class MsgUpdateGMHolidayResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 401 };

	MsgUpdateGMHolidayResponse() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgUpdateGMHolidayResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += holiday.getLength(false);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		holiday.serialize(s, false);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		holiday.unserialize(s, false);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		holiday.push(L);
		lua::settable(L, -1, "holiday");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "holiday={";
		holiday.dump(buffer);
		buffer << "}";
	}

public:
	GMHoliday holiday;
};

class MsgGMHolidayGRankValueAddRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 402 };

	MsgGMHolidayGRankValueAddRequest() :
		Message(Category, Id)
	{
		server_id = 0;
		switch_id = 0;
		pid = 0;
		job = 0;
		gender = 0;
		value = 0;
		flag = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMHolidayGRankValueAddRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 28;
		length += sizeof(short) + name.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << server_id;
		s << switch_id;
		s << pid;
		s << name;
		s << job;
		s << gender;
		s << value;
		s << flag;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> server_id;
		s >> switch_id;
		s >> pid;
		s >> name;
		s >> job;
		s >> gender;
		s >> value;
		s >> flag;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "server_id", server_id);
		lua::settable(L, -1, "switch_id", switch_id);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "value", value);
		lua::settable(L, -1, "flag", flag);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "server_id=" << server_id;
		buffer << ",switch_id=" << switch_id;
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",job=" << job;
		buffer << ",gender=" << gender;
		buffer << ",value=" << value;
		buffer << ",flag=" << flag;
	}

public:
	int server_id;
	int switch_id;
	int pid;
	std::string name;
	int job;
	int gender;
	int value;
	int flag;
};

class MsgGMHolidayGRankValueAddResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 403 };

	MsgGMHolidayGRankValueAddResponse() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMHolidayGRankValueAddResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

struct GMHolidayGRankData
{
public:
	GMHolidayGRankData()
	{
		server_id = 0;
		pid = 0;
		job = 0;
		gender = 0;
		value = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += sizeof(short) + server_name.size();
		length += sizeof(short) + name.size();
		length += sizeof(short) + time.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << server_id;
		s << server_name;
		s << pid;
		s << name;
		s << job;
		s << gender;
		s << value;
		s << time;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> server_id;
		s >> server_name;
		s >> pid;
		s >> name;
		s >> job;
		s >> gender;
		s >> value;
		s >> time;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "server_id", server_id);
		lua::settable(L, -1, "server_name", server_name);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "value", value);
		lua::settable(L, -1, "time", time);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "server_id=" << server_id;
		buffer << ",server_name=" << server_name;
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",job=" << job;
		buffer << ",gender=" << gender;
		buffer << ",value=" << value;
		buffer << ",time=" << time;
	}

public:
	int server_id;
	std::string server_name;
	int pid;
	std::string name;
	int job;
	int gender;
	int value;
	std::string time;
};

class MsgGMHolidayGRankRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 404 };

	MsgGMHolidayGRankRequest() :
		Message(Category, Id)
	{
		server_id = 0;
		switch_id = 0;
		is_end = 0;
		count = 0;
		server_group = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMHolidayGRankRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 20;
		length += sizeof(short) + begin_time.size();
		length += sizeof(short) + end_time.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << server_id;
		s << switch_id;
		s << is_end;
		s << begin_time;
		s << end_time;
		s << count;
		s << server_group;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> server_id;
		s >> switch_id;
		s >> is_end;
		s >> begin_time;
		s >> end_time;
		s >> count;
		s >> server_group;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "server_id", server_id);
		lua::settable(L, -1, "switch_id", switch_id);
		lua::settable(L, -1, "is_end", is_end);
		lua::settable(L, -1, "begin_time", begin_time);
		lua::settable(L, -1, "end_time", end_time);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "server_group", server_group);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "server_id=" << server_id;
		buffer << ",switch_id=" << switch_id;
		buffer << ",is_end=" << is_end;
		buffer << ",begin_time=" << begin_time;
		buffer << ",end_time=" << end_time;
		buffer << ",count=" << count;
		buffer << ",server_group=" << server_group;
	}

public:
	int server_id;
	int switch_id;
	int is_end;
	std::string begin_time;
	std::string end_time;
	int count;
	int server_group;
};

class MsgGMHolidayGRankResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 405 };

	MsgGMHolidayGRankResponse() :
		Message(Category, Id)
	{
		switch_id = 0;
		is_end = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMHolidayGRankResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short);
		for (size_t i = 0; i < vglobalrank.size(); ++i)
		{
			length += vglobalrank[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << switch_id;
		s << is_end;
		short vglobalrank_vector_size = (short)vglobalrank.size();
		s << vglobalrank_vector_size;
		if (vglobalrank_vector_size > 0)
		{
			for (auto it = vglobalrank.begin(); it != vglobalrank.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> switch_id;
		s >> is_end;
		int vglobalrank_vector_size = s.read_int16();
		vglobalrank.clear();
		while (vglobalrank_vector_size > 0)
		{
			vglobalrank_vector_size--;
			GMHolidayGRankData val;
			val.unserialize(s, false);
			vglobalrank.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "switch_id", switch_id);
		lua::settable(L, -1, "is_end", is_end);
		lua::newtable(lua::L);
		for (size_t i = 0; i < vglobalrank.size(); ++i)
		{
			vglobalrank[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "vglobalrank");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "switch_id=" << switch_id;
		buffer << ",is_end=" << is_end;
		buffer << ",vglobalrank=[";
		for (size_t i = 0; i < vglobalrank.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			vglobalrank[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int switch_id;
	int is_end;
	std::vector<GMHolidayGRankData> vglobalrank;
};

class MsgGMHolidayNoteRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 406 };

	MsgGMHolidayNoteRequest() :
		Message(Category, Id)
	{
		pid = 0;
		switch_id = 0;
		index = 0;
		flag = 0;
		account_id = 0;
		server_id = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMHolidayNoteRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 36;
		length += sizeof(short) + datas.size();
		length += sizeof(short) + begin_time.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << switch_id;
		s << index;
		s << flag;
		s << account_id;
		s << server_id;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		s << begin_time;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> switch_id;
		s >> index;
		s >> flag;
		s >> account_id;
		s >> server_id;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		s >> begin_time;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "switch_id", switch_id);
		lua::settable(L, -1, "index", index);
		lua::settable(L, -1, "flag", flag);
		lua::settable(L, -1, "account_id", account_id);
		lua::settable(L, -1, "server_id", server_id);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
		lua::settable(L, -1, "begin_time", begin_time);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",switch_id=" << switch_id;
		buffer << ",index=" << index;
		buffer << ",flag=" << flag;
		buffer << ",account_id=" << account_id;
		buffer << ",server_id=" << server_id;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
		buffer << ",begin_time=" << begin_time;
	}

public:
	int pid;
	int switch_id;
	int index;
	int flag;
	int account_id;
	int server_id;
	int datax;
	int datay;
	int dataz;
	std::string datas;
	std::string begin_time;
};

class MsgGMHolidayNoteResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 407 };

	MsgGMHolidayNoteResponse() :
		Message(Category, Id)
	{
		pid = 0;
		switch_id = 0;
		index = 0;
		flag = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMHolidayNoteResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << switch_id;
		s << index;
		s << flag;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> switch_id;
		s >> index;
		s >> flag;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "switch_id", switch_id);
		lua::settable(L, -1, "index", index);
		lua::settable(L, -1, "flag", flag);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",switch_id=" << switch_id;
		buffer << ",index=" << index;
		buffer << ",flag=" << flag;
	}

public:
	int pid;
	int switch_id;
	int index;
	int flag;
};

class MsgGMGetBlackListRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 416 };

	MsgGMGetBlackListRequest() :
		Message(Category, Id)
	{
		serverId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMGetBlackListRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << serverId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> serverId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverId=" << serverId;
	}

public:
	int serverId;
};

class MsgGMGetBlackListResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 417 };

	MsgGMGetBlackListResponse() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMGetBlackListResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		length += blackList.size() * 4;
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short blackList_vector_size = (short)blackList.size();
		s << blackList_vector_size;
		if (blackList_vector_size > 0)
		{
			for (auto it = blackList.begin(); it != blackList.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int blackList_vector_size = s.read_int16();
		blackList.clear();
		while (blackList_vector_size > 0)
		{
			blackList_vector_size--;
			int val;
			s >> val;
			blackList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < blackList.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, blackList[i]);
		}
		lua::settable(L, -2, "blackList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "blackList=[";
		for (size_t i = 0; i < blackList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << blackList[i];
		}
		buffer << "]";
	}

public:
	std::vector<int> blackList;
};

struct ServerCommonInfo
{
public:
	ServerCommonInfo()
	{
		serverId = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 4;
		length += sizeof(short) + serverName.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << serverName;
		s << serverId;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> serverName;
		s >> serverId;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverName", serverName);
		lua::settable(L, -1, "serverId", serverId);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "serverName=" << serverName;
		buffer << ",serverId=" << serverId;
	}

public:
	std::string serverName;
	int serverId;
};

struct WarZoneInfo
{
public:
	WarZoneInfo()
	{
		warZoneServerId = 0;
		warZoneLineId = 0;
		warZonePreOpenTime = 0;
		warZoneOpenTime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 14;
		length += sizeof(short) + warZoneServerName.size();
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < gameServerInfoList.size(); ++i)
		{
			length += gameServerInfoList[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << warZoneServerId;
		s << warZoneServerName;
		s << warZoneLineId;
		s << warZonePreOpenTime;
		s << warZoneOpenTime;
		int gameServerInfoList_vector_size = ex ? (int)gameServerInfoList.size() : (short)gameServerInfoList.size();
		if (ex)
		{
			s << gameServerInfoList_vector_size;
		}
		else
		{
			s << (short)gameServerInfoList_vector_size;
		}
		if (gameServerInfoList_vector_size > 0)
		{
			for (auto it = gameServerInfoList.begin(); it != gameServerInfoList.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> warZoneServerId;
		s >> warZoneServerName;
		s >> warZoneLineId;
		s >> warZonePreOpenTime;
		s >> warZoneOpenTime;
		int gameServerInfoList_vector_size = ex ? s.read_int32() : s.read_int16();
		gameServerInfoList.clear();
		while (gameServerInfoList_vector_size > 0)
		{
			gameServerInfoList_vector_size--;
			ServerCommonInfo val;
			val.unserialize(s, ex);
			gameServerInfoList.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "warZoneServerId", warZoneServerId);
		lua::settable(L, -1, "warZoneServerName", warZoneServerName);
		lua::settable(L, -1, "warZoneLineId", warZoneLineId);
		lua::settable(L, -1, "warZonePreOpenTime", warZonePreOpenTime);
		lua::settable(L, -1, "warZoneOpenTime", warZoneOpenTime);
		lua::newtable(lua::L);
		for (size_t i = 0; i < gameServerInfoList.size(); ++i)
		{
			gameServerInfoList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "gameServerInfoList");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "warZoneServerId=" << warZoneServerId;
		buffer << ",warZoneServerName=" << warZoneServerName;
		buffer << ",warZoneLineId=" << warZoneLineId;
		buffer << ",warZonePreOpenTime=" << warZonePreOpenTime;
		buffer << ",warZoneOpenTime=" << warZoneOpenTime;
		buffer << ",gameServerInfoList=[";
		for (size_t i = 0; i < gameServerInfoList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			gameServerInfoList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int warZoneServerId; //战区所在的服务器的id 
	std::string warZoneServerName; //战区所在的服务器的名称 
	short warZoneLineId; //战区的分线id 
	int warZonePreOpenTime; //战区的预开启时间 
	int warZoneOpenTime; //战区的正式开启时间 
	std::vector<ServerCommonInfo> gameServerInfoList; //该战区内的所有游戏服信息 
};

class MsgGMWarZoneNotifyStart : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 421 };

	MsgGMWarZoneNotifyStart() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMWarZoneNotifyStart";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

class MsgGMWarZoneNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 422 };

	MsgGMWarZoneNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMWarZoneNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		for (size_t i = 0; i < infoList.size(); ++i)
		{
			length += infoList[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short infoList_vector_size = (short)infoList.size();
		s << infoList_vector_size;
		if (infoList_vector_size > 0)
		{
			for (auto it = infoList.begin(); it != infoList.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int infoList_vector_size = s.read_int16();
		infoList.clear();
		while (infoList_vector_size > 0)
		{
			infoList_vector_size--;
			WarZoneInfo val;
			val.unserialize(s, false);
			infoList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < infoList.size(); ++i)
		{
			infoList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "infoList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "infoList=[";
		for (size_t i = 0; i < infoList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			infoList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<WarZoneInfo> infoList;
};

class MsgGMWarZoneNotifyEnd : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 423 };

	MsgGMWarZoneNotifyEnd() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMWarZoneNotifyEnd";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

class MsgJuHeLoginRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 427 };

	MsgJuHeLoginRequest() :
		Message(Category, Id)
	{
		appId = 0;
		packageId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgJuHeLoginRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + deviceId.size();
		length += sizeof(short) + ip.size();
		length += sizeof(short) + data.size();
		length += sizeof(short) + openId.size();
		length += sizeof(short) + token.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << appId;
		s << packageId;
		s << deviceId;
		s << ip;
		s << data;
		s << openId;
		s << token;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> appId;
		s >> packageId;
		s >> deviceId;
		s >> ip;
		s >> data;
		s >> openId;
		s >> token;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "packageId", packageId);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "ip", ip);
		lua::settable(L, -1, "data", data);
		lua::settable(L, -1, "openId", openId);
		lua::settable(L, -1, "token", token);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "appId=" << appId;
		buffer << ",packageId=" << packageId;
		buffer << ",deviceId=" << deviceId;
		buffer << ",ip=" << ip;
		buffer << ",data=" << data;
		buffer << ",openId=" << openId;
		buffer << ",token=" << token;
	}

public:
	int appId; //应用编号 
	int packageId; //分包编号 
	std::string deviceId; //设备id 
	std::string ip; //ip地址 
	std::string data; //json数据 
	std::string openId; //账号唯一标识 
	std::string token; //中通行凭证 
};

struct UserData
{
public:
	UserData()
	{
		uid = 0;
		packageId = 0;
		sdkId = 0;
		createTime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 16;
		length += sizeof(short) + uin.size();
		length += sizeof(short) + deviceId.size();
		length += sizeof(short) + ip.size();
		length += sizeof(short) + extn.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << uid;
		s << packageId;
		s << sdkId;
		s << uin;
		s << deviceId;
		s << ip;
		s << createTime;
		s << extn;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> uid;
		s >> packageId;
		s >> sdkId;
		s >> uin;
		s >> deviceId;
		s >> ip;
		s >> createTime;
		s >> extn;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "uid", uid);
		lua::settable(L, -1, "packageId", packageId);
		lua::settable(L, -1, "sdkId", sdkId);
		lua::settable(L, -1, "uin", uin);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "ip", ip);
		lua::settable(L, -1, "createTime", createTime);
		lua::settable(L, -1, "extn", extn);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "uid=" << uid;
		buffer << ",packageId=" << packageId;
		buffer << ",sdkId=" << sdkId;
		buffer << ",uin=" << uin;
		buffer << ",deviceId=" << deviceId;
		buffer << ",ip=" << ip;
		buffer << ",createTime=" << createTime;
		buffer << ",extn=" << extn;
	}

public:
	int uid;
	int packageId;
	int sdkId;
	std::string uin;
	std::string deviceId;
	std::string ip;
	int createTime;
	std::string extn;
};

class MsgJuHeLoginResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 424 };

	MsgJuHeLoginResponse() :
		Message(Category, Id)
	{
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgJuHeLoginResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 2;
		length += sizeof(short);
		for (size_t i = 0; i < userData.size(); ++i)
		{
			length += userData[i].getLength(false);
		}
		length += sizeof(short) + msg.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short userData_vector_size = (short)userData.size();
		s << userData_vector_size;
		if (userData_vector_size > 0)
		{
			for (auto it = userData.begin(); it != userData.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		s << msg;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int userData_vector_size = s.read_int16();
		userData.clear();
		while (userData_vector_size > 0)
		{
			userData_vector_size--;
			UserData val;
			val.unserialize(s, false);
			userData.push_back(val);
		}
		s >> msg;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < userData.size(); ++i)
		{
			userData[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "userData");
		lua::settable(L, -1, "msg", msg);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "userData=[";
		for (size_t i = 0; i < userData.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			userData[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",msg=" << msg;
		buffer << ",errcode=" << errcode;
	}

public:
	std::vector<UserData> userData;
	std::string msg; //提示信息 
	short errcode;
};

class MsgJuHePayRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 426 };

	MsgJuHePayRequest() :
		Message(Category, Id)
	{
		appId = 0;
		packageId = 0;
		aid = 0;
		sdkId = 0;
		sessionId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgJuHePayRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 20;
		length += sizeof(short) + deviceId.size();
		length += sizeof(short) + money.size();
		length += sizeof(short) + ip.size();
		length += sizeof(short) + cpExt.size();
		length += sizeof(short) + serverName.size();
		length += sizeof(short) + roleName.size();
		length += sizeof(short) + openId.size();
		length += sizeof(short) + appKey.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << appId;
		s << packageId;
		s << deviceId;
		s << aid;
		s << money;
		s << ip;
		s << cpExt;
		s << serverName;
		s << roleName;
		s << sdkId;
		s << sessionId;
		s << openId;
		s << appKey;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> appId;
		s >> packageId;
		s >> deviceId;
		s >> aid;
		s >> money;
		s >> ip;
		s >> cpExt;
		s >> serverName;
		s >> roleName;
		s >> sdkId;
		s >> sessionId;
		s >> openId;
		s >> appKey;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "packageId", packageId);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "money", money);
		lua::settable(L, -1, "ip", ip);
		lua::settable(L, -1, "cpExt", cpExt);
		lua::settable(L, -1, "serverName", serverName);
		lua::settable(L, -1, "roleName", roleName);
		lua::settable(L, -1, "sdkId", sdkId);
		lua::settable(L, -1, "sessionId", sessionId);
		lua::settable(L, -1, "openId", openId);
		lua::settable(L, -1, "appKey", appKey);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "appId=" << appId;
		buffer << ",packageId=" << packageId;
		buffer << ",deviceId=" << deviceId;
		buffer << ",aid=" << aid;
		buffer << ",money=" << money;
		buffer << ",ip=" << ip;
		buffer << ",cpExt=" << cpExt;
		buffer << ",serverName=" << serverName;
		buffer << ",roleName=" << roleName;
		buffer << ",sdkId=" << sdkId;
		buffer << ",sessionId=" << sessionId;
		buffer << ",openId=" << openId;
		buffer << ",appKey=" << appKey;
	}

public:
	int appId; //应用编号 
	int packageId; //分包编号 
	std::string deviceId; //设备id 
	int aid; //ip地址 
	std::string money; //ip地址 
	std::string ip; //ip地址 
	std::string cpExt; //json数据 
	std::string serverName; //账号唯一标识 
	std::string roleName; //中通行凭证 
	int sdkId; //sdk编号 
	int sessionId; //sdk编号 
	std::string openId; //账号唯一标识 
	std::string appKey; //中通行凭证 
};

class MsgJuHePayResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 428 };

	MsgJuHePayResponse() :
		Message(Category, Id)
	{
		errcode = 0;
		sessionId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgJuHePayResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + orderId.size();
		length += sizeof(short) + msg.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << orderId;
		s << errcode;
		s << sessionId;
		s << msg;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> orderId;
		s >> errcode;
		s >> sessionId;
		s >> msg;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "orderId", orderId);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "sessionId", sessionId);
		lua::settable(L, -1, "msg", msg);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "orderId=" << orderId;
		buffer << ",errcode=" << errcode;
		buffer << ",sessionId=" << sessionId;
		buffer << ",msg=" << msg;
	}

public:
	std::string orderId; //订单编号 
	int errcode;
	int sessionId;
	std::string msg; //提示信息 
};

struct VisitorLoginData
{
public:
	VisitorLoginData()
	{
		appId = 0;
		packageId = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 8;
		length += sizeof(short) + deviceId.size();
		length += sizeof(short) + deviceUin.size();
		length += sizeof(short) + ip.size();
		length += sizeof(short) + appKey.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << appId;
		s << packageId;
		s << deviceId;
		s << deviceUin;
		s << ip;
		s << appKey;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> appId;
		s >> packageId;
		s >> deviceId;
		s >> deviceUin;
		s >> ip;
		s >> appKey;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "packageId", packageId);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "deviceUin", deviceUin);
		lua::settable(L, -1, "ip", ip);
		lua::settable(L, -1, "appKey", appKey);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "appId=" << appId;
		buffer << ",packageId=" << packageId;
		buffer << ",deviceId=" << deviceId;
		buffer << ",deviceUin=" << deviceUin;
		buffer << ",ip=" << ip;
		buffer << ",appKey=" << appKey;
	}

public:
	int appId;
	int packageId;
	std::string deviceId;
	std::string deviceUin;
	std::string ip;
	std::string appKey;
};

struct AccountLoginData
{
public:
	AccountLoginData()
	{
		appId = 0;
		packageId = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 8;
		length += sizeof(short) + account.size();
		length += sizeof(short) + password.size();
		length += sizeof(short) + deviceId.size();
		length += sizeof(short) + ip.size();
		length += sizeof(short) + appKey.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << appId;
		s << packageId;
		s << account;
		s << password;
		s << deviceId;
		s << ip;
		s << appKey;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> appId;
		s >> packageId;
		s >> account;
		s >> password;
		s >> deviceId;
		s >> ip;
		s >> appKey;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "packageId", packageId);
		lua::settable(L, -1, "account", account);
		lua::settable(L, -1, "password", password);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "ip", ip);
		lua::settable(L, -1, "appKey", appKey);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "appId=" << appId;
		buffer << ",packageId=" << packageId;
		buffer << ",account=" << account;
		buffer << ",password=" << password;
		buffer << ",deviceId=" << deviceId;
		buffer << ",ip=" << ip;
		buffer << ",appKey=" << appKey;
	}

public:
	int appId;
	int packageId;
	std::string account;
	std::string password;
	std::string deviceId;
	std::string ip;
	std::string appKey;
};

struct VerificationLoginData
{
public:
	VerificationLoginData()
	{
		appId = 0;
		packageId = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 8;
		length += sizeof(short) + deviceId.size();
		length += sizeof(short) + ip.size();
		length += sizeof(short) + username.size();
		length += sizeof(short) + verification.size();
		length += sizeof(short) + appKey.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << appId;
		s << packageId;
		s << deviceId;
		s << ip;
		s << username;
		s << verification;
		s << appKey;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> appId;
		s >> packageId;
		s >> deviceId;
		s >> ip;
		s >> username;
		s >> verification;
		s >> appKey;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "packageId", packageId);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "ip", ip);
		lua::settable(L, -1, "username", username);
		lua::settable(L, -1, "verification", verification);
		lua::settable(L, -1, "appKey", appKey);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "appId=" << appId;
		buffer << ",packageId=" << packageId;
		buffer << ",deviceId=" << deviceId;
		buffer << ",ip=" << ip;
		buffer << ",username=" << username;
		buffer << ",verification=" << verification;
		buffer << ",appKey=" << appKey;
	}

public:
	int appId;
	int packageId;
	std::string deviceId;
	std::string ip;
	std::string username;
	std::string verification;
	std::string appKey;
};

struct responseData
{
public:
	responseData()
	{
	}

	size_t getLength(bool ex) const
	{
		size_t length = 0;
		length += sizeof(short) + openId.size();
		length += sizeof(short) + token.size();
		length += sizeof(short) + nickName.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << openId;
		s << token;
		s << nickName;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> openId;
		s >> token;
		s >> nickName;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "openId", openId);
		lua::settable(L, -1, "token", token);
		lua::settable(L, -1, "nickName", nickName);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "openId=" << openId;
		buffer << ",token=" << token;
		buffer << ",nickName=" << nickName;
	}

public:
	std::string openId;
	std::string token;
	std::string nickName; //游客编号(1是游客. 其他是空字符串 
};

class MsgIosResetPwdRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 431 };

	MsgIosResetPwdRequest() :
		Message(Category, Id)
	{
		appId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosResetPwdRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + username.size();
		length += sizeof(short) + ip.size();
		length += sizeof(short) + verification.size();
		length += sizeof(short) + password.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << username;
		s << appId;
		s << ip;
		s << verification;
		s << password;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> username;
		s >> appId;
		s >> ip;
		s >> verification;
		s >> password;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "username", username);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "ip", ip);
		lua::settable(L, -1, "verification", verification);
		lua::settable(L, -1, "password", password);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "username=" << username;
		buffer << ",appId=" << appId;
		buffer << ",ip=" << ip;
		buffer << ",verification=" << verification;
		buffer << ",password=" << password;
	}

public:
	std::string username; //用户名 
	int appId; //应用编号 
	std::string ip; //ip地址 
	std::string verification; //验证码 
	std::string password; //新密码 
};

class MsgIosResetPwdResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 432 };

	MsgIosResetPwdResponse() :
		Message(Category, Id)
	{
		error = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosResetPwdResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + msg.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << error;
		s << msg;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> error;
		s >> msg;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "error", error);
		lua::settable(L, -1, "msg", msg);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "error=" << error;
		buffer << ",msg=" << msg;
	}

public:
	int error; //错误码 
	std::string msg; //登录结果 
};

class MsgIosBandPhoneOrEmailRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 433 };

	MsgIosBandPhoneOrEmailRequest() :
		Message(Category, Id)
	{
		appId = 0;
		packageId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosBandPhoneOrEmailRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + deviceId.size();
		length += sizeof(short) + deviceUin.size();
		length += sizeof(short) + phone.size();
		length += sizeof(short) + email.size();
		length += sizeof(short) + verification.size();
		length += sizeof(short) + password.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << deviceId;
		s << deviceUin;
		s << appId;
		s << packageId;
		s << phone;
		s << email;
		s << verification;
		s << password;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> deviceId;
		s >> deviceUin;
		s >> appId;
		s >> packageId;
		s >> phone;
		s >> email;
		s >> verification;
		s >> password;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "deviceId", deviceId);
		lua::settable(L, -1, "deviceUin", deviceUin);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "packageId", packageId);
		lua::settable(L, -1, "phone", phone);
		lua::settable(L, -1, "email", email);
		lua::settable(L, -1, "verification", verification);
		lua::settable(L, -1, "password", password);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "deviceId=" << deviceId;
		buffer << ",deviceUin=" << deviceUin;
		buffer << ",appId=" << appId;
		buffer << ",packageId=" << packageId;
		buffer << ",phone=" << phone;
		buffer << ",email=" << email;
		buffer << ",verification=" << verification;
		buffer << ",password=" << password;
	}

public:
	std::string deviceId; //设备唯一标识 
	std::string deviceUin; //游客唯一标志 
	int appId; //app编号 
	int packageId; //分包编号 
	std::string phone; //手机号 
	std::string email; //email地址 
	std::string verification; //验证码 
	std::string password; //密码 
};

class MsgIosBandPhoneOrEmailResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 434 };

	MsgIosBandPhoneOrEmailResponse() :
		Message(Category, Id)
	{
		error = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosBandPhoneOrEmailResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + msg.size();
		length += sizeof(short) + token.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << error;
		s << msg;
		s << token;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> error;
		s >> msg;
		s >> token;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "error", error);
		lua::settable(L, -1, "msg", msg);
		lua::settable(L, -1, "token", token);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "error=" << error;
		buffer << ",msg=" << msg;
		buffer << ",token=" << token;
	}

public:
	int error; //错误码 
	std::string msg; //提示信息 
	std::string token; //同行凭证 
};

class MsgIosSendVerificationRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 435 };

	MsgIosSendVerificationRequest() :
		Message(Category, Id)
	{
		appId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosSendVerificationRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + username.size();
		length += sizeof(short) + appKey.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << username;
		s << appId;
		s << appKey;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> username;
		s >> appId;
		s >> appKey;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "username", username);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "appKey", appKey);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "username=" << username;
		buffer << ",appId=" << appId;
		buffer << ",appKey=" << appKey;
	}

public:
	std::string username; //用户名 
	int appId; //应用编号 
	std::string appKey; //app密钥 
};

class MsgIosSendVerificationResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 436 };

	MsgIosSendVerificationResponse() :
		Message(Category, Id)
	{
		error = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosSendVerificationResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + msg.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << error;
		s << msg;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> error;
		s >> msg;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "error", error);
		lua::settable(L, -1, "msg", msg);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "error=" << error;
		buffer << ",msg=" << msg;
	}

public:
	int error; //错误码 
	std::string msg; //登录结果 
};

class MsgIosLoginRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 437 };

	MsgIosLoginRequest() :
		Message(Category, Id)
	{
		loginType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosLoginRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += visitorLoginData.getLength(false);
		length += accountLoginData.getLength(false);
		length += VerLoginData.getLength(false);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << loginType;
		visitorLoginData.serialize(s, false);
		accountLoginData.serialize(s, false);
		VerLoginData.serialize(s, false);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> loginType;
		visitorLoginData.unserialize(s, false);
		accountLoginData.unserialize(s, false);
		VerLoginData.unserialize(s, false);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "loginType", loginType);
		visitorLoginData.push(L);
		lua::settable(L, -1, "visitorLoginData");
		accountLoginData.push(L);
		lua::settable(L, -1, "accountLoginData");
		VerLoginData.push(L);
		lua::settable(L, -1, "VerLoginData");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "loginType=" << loginType;
		buffer << ",visitorLoginData={";
		visitorLoginData.dump(buffer);
		buffer << "}";
		buffer << ",accountLoginData={";
		accountLoginData.dump(buffer);
		buffer << "}";
		buffer << ",VerLoginData={";
		VerLoginData.dump(buffer);
		buffer << "}";
	}

public:
	int loginType; //1.游客登陆 2.账号登录 3.验证码登陆 
	VisitorLoginData visitorLoginData; //登录数据:每种登录场合参照下方参数 
	AccountLoginData accountLoginData; //登录数据:每种登录场合参照下方参数 
	VerificationLoginData VerLoginData; //登录数据:每种登录场合参照下方参数 
};

class MsgIosLoginResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 438 };

	MsgIosLoginResponse() :
		Message(Category, Id)
	{
		error = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosLoginResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += resdata.getLength(false);
		length += sizeof(short) + msg.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		resdata.serialize(s, false);
		s << msg;
		s << error;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		resdata.unserialize(s, false);
		s >> msg;
		s >> error;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		resdata.push(L);
		lua::settable(L, -1, "resdata");
		lua::settable(L, -1, "msg", msg);
		lua::settable(L, -1, "error", error);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "resdata={";
		resdata.dump(buffer);
		buffer << "}";
		buffer << ",msg=" << msg;
		buffer << ",error=" << error;
	}

public:
	responseData resdata; //登录结果信息 
	std::string msg; //登录结果 
	int error; //错误码 
};

class MsgGMChatVeriPhoneRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 439 };

	MsgGMChatVeriPhoneRequest() :
		Message(Category, Id)
	{
		appId = 0;
		sessionId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMChatVeriPhoneRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + openId.size();
		length += sizeof(short) + mobile.size();
		length += sizeof(short) + verifyCode.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << appId;
		s << openId;
		s << mobile;
		s << verifyCode;
		s << sessionId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> appId;
		s >> openId;
		s >> mobile;
		s >> verifyCode;
		s >> sessionId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "openId", openId);
		lua::settable(L, -1, "mobile", mobile);
		lua::settable(L, -1, "verifyCode", verifyCode);
		lua::settable(L, -1, "sessionId", sessionId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "appId=" << appId;
		buffer << ",openId=" << openId;
		buffer << ",mobile=" << mobile;
		buffer << ",verifyCode=" << verifyCode;
		buffer << ",sessionId=" << sessionId;
	}

public:
	int appId; //订单编号 
	std::string openId;
	std::string mobile; //手机号 
	std::string verifyCode; //手机号 
	int sessionId; //手机号 
};

class MsgGMChatVeriPhoneResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 440 };

	MsgGMChatVeriPhoneResponse() :
		Message(Category, Id)
	{
		error = 0;
		sessionId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMChatVeriPhoneResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + message.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << error;
		s << message;
		s << sessionId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> error;
		s >> message;
		s >> sessionId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "error", error);
		lua::settable(L, -1, "message", message);
		lua::settable(L, -1, "sessionId", sessionId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "error=" << error;
		buffer << ",message=" << message;
		buffer << ",sessionId=" << sessionId;
	}

public:
	int error;
	std::string message;
	int sessionId; //手机号 
};

class MsgGMChatVeriCodeRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 441 };

	MsgGMChatVeriCodeRequest() :
		Message(Category, Id)
	{
		appId = 0;
		sessionId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMChatVeriCodeRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + openId.size();
		length += sizeof(short) + mobile.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << appId;
		s << openId;
		s << mobile;
		s << sessionId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> appId;
		s >> openId;
		s >> mobile;
		s >> sessionId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "openId", openId);
		lua::settable(L, -1, "mobile", mobile);
		lua::settable(L, -1, "sessionId", sessionId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "appId=" << appId;
		buffer << ",openId=" << openId;
		buffer << ",mobile=" << mobile;
		buffer << ",sessionId=" << sessionId;
	}

public:
	int appId; //订单编号 
	std::string openId;
	std::string mobile; //手机号 
	int sessionId; //手机号 
};

class MsgGMChatVeriCodeResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 442 };

	MsgGMChatVeriCodeResponse() :
		Message(Category, Id)
	{
		error = 0;
		sessionId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMChatVeriCodeResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + message.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << error;
		s << message;
		s << sessionId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> error;
		s >> message;
		s >> sessionId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "error", error);
		lua::settable(L, -1, "message", message);
		lua::settable(L, -1, "sessionId", sessionId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "error=" << error;
		buffer << ",message=" << message;
		buffer << ",sessionId=" << sessionId;
	}

public:
	int error;
	std::string message;
	int sessionId; //手机号 
};

class MsgIosPERegisterRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 443 };

	MsgIosPERegisterRequest() :
		Message(Category, Id)
	{
		appId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosPERegisterRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + ip.size();
		length += sizeof(short) + username.size();
		length += sizeof(short) + appKey.size();
		length += sizeof(short) + verification.size();
		length += sizeof(short) + password.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << ip;
		s << username;
		s << appId;
		s << appKey;
		s << verification;
		s << password;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> ip;
		s >> username;
		s >> appId;
		s >> appKey;
		s >> verification;
		s >> password;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ip", ip);
		lua::settable(L, -1, "username", username);
		lua::settable(L, -1, "appId", appId);
		lua::settable(L, -1, "appKey", appKey);
		lua::settable(L, -1, "verification", verification);
		lua::settable(L, -1, "password", password);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "ip=" << ip;
		buffer << ",username=" << username;
		buffer << ",appId=" << appId;
		buffer << ",appKey=" << appKey;
		buffer << ",verification=" << verification;
		buffer << ",password=" << password;
	}

public:
	std::string ip; //订单编号 
	std::string username;
	int appId; //订单编号 
	std::string appKey;
	std::string verification; //手机号 
	std::string password; //手机号 
};

class MsgIosPERegisterResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 444 };

	MsgIosPERegisterResponse() :
		Message(Category, Id)
	{
		error = 0;
	}

	virtual const char *getName() const
	{
		return "MsgIosPERegisterResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += sizeof(short) + message.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << error;
		s << message;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> error;
		s >> message;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "error", error);
		lua::settable(L, -1, "message", message);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "error=" << error;
		buffer << ",message=" << message;
	}

public:
	int error;
	std::string message;
};

class MsgGetChannelTuoGuanCntRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 501 };

	MsgGetChannelTuoGuanCntRequest() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGetChannelTuoGuanCntRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short) + token.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << token;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> token;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "token", token);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "token=" << token;
	}

public:
	std::string token;
};

class MsgGetChannelTuoGuanCntResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 502 };

	MsgGetChannelTuoGuanCntResponse() :
		Message(Category, Id)
	{
		serverId = 0;
		onlineTotal = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetChannelTuoGuanCntResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short);
		for (size_t i = 0; i < channelNum.size(); ++i)
		{
			length += channelNum[i].getLength(false);
		}
		length += sizeof(short) + token.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << serverId;
		s << onlineTotal;
		short channelNum_vector_size = (short)channelNum.size();
		s << channelNum_vector_size;
		if (channelNum_vector_size > 0)
		{
			for (auto it = channelNum.begin(); it != channelNum.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		s << token;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> serverId;
		s >> onlineTotal;
		int channelNum_vector_size = s.read_int16();
		channelNum.clear();
		while (channelNum_vector_size > 0)
		{
			channelNum_vector_size--;
			GMOnlineNumByChannel val;
			val.unserialize(s, false);
			channelNum.push_back(val);
		}
		s >> token;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "onlineTotal", onlineTotal);
		lua::newtable(lua::L);
		for (size_t i = 0; i < channelNum.size(); ++i)
		{
			channelNum[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "channelNum");
		lua::settable(L, -1, "token", token);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverId=" << serverId;
		buffer << ",onlineTotal=" << onlineTotal;
		buffer << ",channelNum=[";
		for (size_t i = 0; i < channelNum.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			channelNum[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",token=" << token;
	}

public:
	int serverId;
	int onlineTotal;
	std::vector<GMOnlineNumByChannel> channelNum;
	std::string token;
};

class MsgGMWarZoneNotifyRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 503 };

	MsgGMWarZoneNotifyRequest() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMWarZoneNotifyRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		length += serverList.size() * 4;
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short serverList_vector_size = (short)serverList.size();
		s << serverList_vector_size;
		if (serverList_vector_size > 0)
		{
			for (auto it = serverList.begin(); it != serverList.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int serverList_vector_size = s.read_int16();
		serverList.clear();
		while (serverList_vector_size > 0)
		{
			serverList_vector_size--;
			int val;
			s >> val;
			serverList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < serverList.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, serverList[i]);
		}
		lua::settable(L, -2, "serverList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverList=[";
		for (size_t i = 0; i < serverList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << serverList[i];
		}
		buffer << "]";
	}

public:
	std::vector<int> serverList;
};

class MsgGMWarZoneNotifyResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 504 };

	MsgGMWarZoneNotifyResponse() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgGMWarZoneNotifyResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		length += serverList.size() * 4;
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short serverList_vector_size = (short)serverList.size();
		s << serverList_vector_size;
		if (serverList_vector_size > 0)
		{
			for (auto it = serverList.begin(); it != serverList.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int serverList_vector_size = s.read_int16();
		serverList.clear();
		while (serverList_vector_size > 0)
		{
			serverList_vector_size--;
			int val;
			s >> val;
			serverList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < serverList.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, serverList[i]);
		}
		lua::settable(L, -2, "serverList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverList=[";
		for (size_t i = 0; i < serverList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << serverList[i];
		}
		buffer << "]";
	}

public:
	std::vector<int> serverList;
};

class MsgNewRechargeReturnRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 505 };

	MsgNewRechargeReturnRequest() :
		Message(Category, Id)
	{
		aid = 0;
		channel_id = 0;
		client_session_id = 0;
		player_class = 0;
		player_gender = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgNewRechargeReturnRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 19;
		length += sizeof(short) + begin_time.size();
		length += sizeof(short) + end_time.size();
		length += sizeof(short) + player_name.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << aid;
		s << channel_id;
		s << begin_time;
		s << end_time;
		s << client_session_id;
		s << player_class;
		s << player_name;
		s << player_gender;
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> aid;
		s >> channel_id;
		s >> begin_time;
		s >> end_time;
		s >> client_session_id;
		s >> player_class;
		s >> player_name;
		s >> player_gender;
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "channel_id", channel_id);
		lua::settable(L, -1, "begin_time", begin_time);
		lua::settable(L, -1, "end_time", end_time);
		lua::settable(L, -1, "client_session_id", client_session_id);
		lua::settable(L, -1, "player_class", player_class);
		lua::settable(L, -1, "player_name", player_name);
		lua::settable(L, -1, "player_gender", player_gender);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "aid=" << aid;
		buffer << ",channel_id=" << channel_id;
		buffer << ",begin_time=" << begin_time;
		buffer << ",end_time=" << end_time;
		buffer << ",client_session_id=" << client_session_id;
		buffer << ",player_class=" << player_class;
		buffer << ",player_name=" << player_name;
		buffer << ",player_gender=" << player_gender;
		buffer << ",pid=" << pid;
	}

public:
	int aid; //账号ID 
	int channel_id; //渠道ID 
	std::string begin_time; //开始时间 
	std::string end_time; //结束时间 
	int client_session_id; //玩家会话ID 
	short player_class; //玩家职业 
	std::string player_name; //玩家名称 
	char player_gender; //玩家性别 
	int pid; //玩家id 
};

struct Privilege
{
public:
	Privilege()
	{
		p_type = 0;
		p_num = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << p_type;
		s << p_num;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> p_type;
		s >> p_num;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "p_type", p_type);
		lua::settable(L, -1, "p_num", p_num);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "p_type=" << p_type;
		buffer << ",p_num=" << p_num;
	}

public:
	int p_type;
	int p_num;
};

class MsgNewRechargeReturnResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 506 };

	MsgNewRechargeReturnResponse() :
		Message(Category, Id)
	{
		aid = 0;
		channel_id = 0;
		client_session_id = 0;
		player_class = 0;
		player_gender = 0;
		recharge = 0;
		player_level = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgNewRechargeReturnResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 27;
		length += sizeof(short) + begin_time.size();
		length += sizeof(short) + end_time.size();
		length += sizeof(short) + player_name.size();
		length += sizeof(short);
		for (size_t i = 0; i < privilege.size(); ++i)
		{
			length += privilege[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << aid;
		s << channel_id;
		s << begin_time;
		s << end_time;
		s << client_session_id;
		s << player_class;
		s << player_name;
		s << player_gender;
		s << recharge;
		short privilege_vector_size = (short)privilege.size();
		s << privilege_vector_size;
		if (privilege_vector_size > 0)
		{
			for (auto it = privilege.begin(); it != privilege.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		s << player_level;
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> aid;
		s >> channel_id;
		s >> begin_time;
		s >> end_time;
		s >> client_session_id;
		s >> player_class;
		s >> player_name;
		s >> player_gender;
		s >> recharge;
		int privilege_vector_size = s.read_int16();
		privilege.clear();
		while (privilege_vector_size > 0)
		{
			privilege_vector_size--;
			Privilege val;
			val.unserialize(s, false);
			privilege.push_back(val);
		}
		s >> player_level;
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "channel_id", channel_id);
		lua::settable(L, -1, "begin_time", begin_time);
		lua::settable(L, -1, "end_time", end_time);
		lua::settable(L, -1, "client_session_id", client_session_id);
		lua::settable(L, -1, "player_class", player_class);
		lua::settable(L, -1, "player_name", player_name);
		lua::settable(L, -1, "player_gender", player_gender);
		lua::settable(L, -1, "recharge", recharge);
		lua::newtable(lua::L);
		for (size_t i = 0; i < privilege.size(); ++i)
		{
			privilege[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "privilege");
		lua::settable(L, -1, "player_level", player_level);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "aid=" << aid;
		buffer << ",channel_id=" << channel_id;
		buffer << ",begin_time=" << begin_time;
		buffer << ",end_time=" << end_time;
		buffer << ",client_session_id=" << client_session_id;
		buffer << ",player_class=" << player_class;
		buffer << ",player_name=" << player_name;
		buffer << ",player_gender=" << player_gender;
		buffer << ",recharge=" << recharge;
		buffer << ",privilege=[";
		for (size_t i = 0; i < privilege.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			privilege[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",player_level=" << player_level;
		buffer << ",pid=" << pid;
	}

public:
	int aid; //账号ID 
	int channel_id; //渠道ID 
	std::string begin_time; //开始时间 
	std::string end_time; //结束时间 
	int client_session_id; //玩家会话ID 
	short player_class; //玩家职业 
	std::string player_name; //玩家名称 
	char player_gender; //玩家性别 
	int recharge; //充值金额 
	std::vector<Privilege> privilege; //特权 
	int player_level; //等级 
	int pid; //玩家id 
};

class MsgWebPayActivityProductsRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 516 };

	MsgWebPayActivityProductsRequest() :
		Message(Category, Id)
	{
		pid = 0;
		activityId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgWebPayActivityProductsRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 6;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << activityId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> activityId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "activityId", activityId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",activityId=" << activityId;
	}

public:
	int pid;
	short activityId;
};

class MsgWebPayActivityProductsResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 517 };

	MsgWebPayActivityProductsResponse() :
		Message(Category, Id)
	{
		pid = 0;
		activityId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgWebPayActivityProductsResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 6;
		length += sizeof(short) + jsondata.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << activityId;
		s << jsondata;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> activityId;
		s >> jsondata;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "activityId", activityId);
		lua::settable(L, -1, "jsondata", jsondata);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",activityId=" << activityId;
		buffer << ",jsondata=" << jsondata;
	}

public:
	int pid;
	short activityId;
	std::string jsondata;
};

class MsgWebPayRechargeRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 518 };

	MsgWebPayRechargeRequest() :
		Message(Category, Id)
	{
		pid = 0;
		sid = 0;
		cnt = 0;
	}

	virtual const char *getName() const
	{
		return "MsgWebPayRechargeRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 12;
		length += sizeof(short) + OrderSerial.size();
		length += sizeof(short) + ext.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << sid;
		s << cnt;
		s << OrderSerial;
		s << ext;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> sid;
		s >> cnt;
		s >> OrderSerial;
		s >> ext;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "cnt", cnt);
		lua::settable(L, -1, "OrderSerial", OrderSerial);
		lua::settable(L, -1, "ext", ext);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",cnt=" << cnt;
		buffer << ",OrderSerial=" << OrderSerial;
		buffer << ",ext=" << ext;
	}

public:
	int pid;
	int sid;
	int cnt;
	std::string OrderSerial;
	std::string ext;
};

class MsgWebPaySelecetItemsRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 519 };

	MsgWebPaySelecetItemsRequest() :
		Message(Category, Id)
	{
		pid = 0;
		productId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgWebPaySelecetItemsRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << productId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> productId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "productId", productId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",productId=" << productId;
	}

public:
	int pid;
	int productId;
};

class MsgWebPaySelecetItemsResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 520 };

	MsgWebPaySelecetItemsResponse() :
		Message(Category, Id)
	{
		pid = 0;
		productId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgWebPaySelecetItemsResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 8;
		length += sizeof(short) + jsondata.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << productId;
		s << jsondata;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> productId;
		s >> jsondata;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "productId", productId);
		lua::settable(L, -1, "jsondata", jsondata);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",productId=" << productId;
		buffer << ",jsondata=" << jsondata;
	}

public:
	int pid;
	int productId;
	std::string jsondata;
};

class MsgGMHolidayResultRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_GM, Id = 535 };

	MsgGMHolidayResultRequest() :
		Message(Category, Id)
	{
		code = 0;
		activityId = 0;
		serverId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGMHolidayResultRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 12;
		length += sizeof(short) + cnMsg.size();
		length += sizeof(short) + msg.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << code;
		s << cnMsg;
		s << msg;
		s << activityId;
		s << serverId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> code;
		s >> cnMsg;
		s >> msg;
		s >> activityId;
		s >> serverId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "code", code);
		lua::settable(L, -1, "cnMsg", cnMsg);
		lua::settable(L, -1, "msg", msg);
		lua::settable(L, -1, "activityId", activityId);
		lua::settable(L, -1, "serverId", serverId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "code=" << code;
		buffer << ",cnMsg=" << cnMsg;
		buffer << ",msg=" << msg;
		buffer << ",activityId=" << activityId;
		buffer << ",serverId=" << serverId;
	}

public:
	int code;
	std::string cnMsg;
	std::string msg;
	int activityId;
	int serverId;
};

#endif	//_MSG_G_MASTER_H_INCLUDED
