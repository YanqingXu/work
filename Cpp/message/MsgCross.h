//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _MSG_CROSS_H_INCLUDED
#define _MSG_CROSS_H_INCLUDED

#include "category.h"
#include "common/MessageEx.h"

struct CrossIntProp
{
public:
	CrossIntProp()
	{
		ctype = 0;
		data = 0;
		valueInGS = 0;
	}

	size_t getLength(bool ex) const
	{
		return 12;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << ctype;
		s << data;
		s << valueInGS;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> ctype;
		s >> data;
		s >> valueInGS;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ctype", ctype);
		lua::settable(L, -1, "data", data);
		lua::settable(L, -1, "valueInGS", valueInGS);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "ctype=" << ctype;
		buffer << ",data=" << data;
		buffer << ",valueInGS=" << valueInGS;
	}

public:
	int ctype;
	int data;
	int valueInGS;
};

struct CrossStrProp
{
public:
	CrossStrProp()
	{
		ctype = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 4;
		length += sizeof(short) + data.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << ctype;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> ctype;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ctype", ctype);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "ctype=" << ctype;
		buffer << ",data=" << data;
	}

public:
	int ctype;
	std::string data;
};

struct CrossSkill
{
public:
	CrossSkill()
	{
		sid = 0;
		level = 0;
		remove = 0;
	}

	size_t getLength(bool ex) const
	{
		return 10;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << sid;
		s << level;
		s << remove;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> sid;
		s >> level;
		s >> remove;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "remove", remove);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "sid=" << sid;
		buffer << ",level=" << level;
		buffer << ",remove=" << remove;
	}

public:
	int sid;
	int level;
	short remove;
};

struct CrossCombat
{
public:
	CrossCombat()
	{
		ctype = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 6;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << ctype;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> ctype;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ctype", ctype);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "ctype=" << ctype;
		buffer << ",data=" << data;
	}

public:
	short ctype;
	int data;
};

struct CrossGene
{
public:
	CrossGene()
	{
		geneId = 0;
		geneType = 0;
		geneGroup = 0;
		duration = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
		inherit = 0;
		remove = 0;
	}

	size_t getLength(bool ex) const
	{
		return 32;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << geneId;
		s << geneType;
		s << geneGroup;
		s << duration;
		s << datax;
		s << datay;
		s << dataz;
		s << inherit;
		s << remove;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> geneId;
		s >> geneType;
		s >> geneGroup;
		s >> duration;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> inherit;
		s >> remove;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "geneId", geneId);
		lua::settable(L, -1, "geneType", geneType);
		lua::settable(L, -1, "geneGroup", geneGroup);
		lua::settable(L, -1, "duration", duration);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "inherit", inherit);
		lua::settable(L, -1, "remove", remove);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "geneId=" << geneId;
		buffer << ",geneType=" << geneType;
		buffer << ",geneGroup=" << geneGroup;
		buffer << ",duration=" << duration;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",inherit=" << inherit;
		buffer << ",remove=" << remove;
	}

public:
	int geneId;
	int geneType;
	int geneGroup;
	int duration;
	int datax;
	int datay;
	int dataz;
	short inherit;
	short remove;
};

struct CrossCommonStruct
{
public:
	CrossCommonStruct()
	{
	}

	size_t getLength(bool ex) const
	{
		size_t length = 0;
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < intProps.size(); ++i)
		{
			length += intProps[i].getLength(ex);
		}
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < strProps.size(); ++i)
		{
			length += strProps[i].getLength(ex);
		}
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < genes.size(); ++i)
		{
			length += genes[i].getLength(ex);
		}
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < skills.size(); ++i)
		{
			length += skills[i].getLength(ex);
		}
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < combatImmunity.size(); ++i)
		{
			length += combatImmunity[i].getLength(ex);
		}
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < combatProps.size(); ++i)
		{
			length += combatProps[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		int intProps_vector_size = ex ? (int)intProps.size() : (short)intProps.size();
		if (ex)
		{
			s << intProps_vector_size;
		}
		else
		{
			s << (short)intProps_vector_size;
		}
		if (intProps_vector_size > 0)
		{
			for (auto it = intProps.begin(); it != intProps.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		int strProps_vector_size = ex ? (int)strProps.size() : (short)strProps.size();
		if (ex)
		{
			s << strProps_vector_size;
		}
		else
		{
			s << (short)strProps_vector_size;
		}
		if (strProps_vector_size > 0)
		{
			for (auto it = strProps.begin(); it != strProps.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		int genes_vector_size = ex ? (int)genes.size() : (short)genes.size();
		if (ex)
		{
			s << genes_vector_size;
		}
		else
		{
			s << (short)genes_vector_size;
		}
		if (genes_vector_size > 0)
		{
			for (auto it = genes.begin(); it != genes.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		int skills_vector_size = ex ? (int)skills.size() : (short)skills.size();
		if (ex)
		{
			s << skills_vector_size;
		}
		else
		{
			s << (short)skills_vector_size;
		}
		if (skills_vector_size > 0)
		{
			for (auto it = skills.begin(); it != skills.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		int combatImmunity_vector_size = ex ? (int)combatImmunity.size() : (short)combatImmunity.size();
		if (ex)
		{
			s << combatImmunity_vector_size;
		}
		else
		{
			s << (short)combatImmunity_vector_size;
		}
		if (combatImmunity_vector_size > 0)
		{
			for (auto it = combatImmunity.begin(); it != combatImmunity.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		int combatProps_vector_size = ex ? (int)combatProps.size() : (short)combatProps.size();
		if (ex)
		{
			s << combatProps_vector_size;
		}
		else
		{
			s << (short)combatProps_vector_size;
		}
		if (combatProps_vector_size > 0)
		{
			for (auto it = combatProps.begin(); it != combatProps.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		int intProps_vector_size = ex ? s.read_int32() : s.read_int16();
		intProps.clear();
		while (intProps_vector_size > 0)
		{
			intProps_vector_size--;
			CrossIntProp val;
			val.unserialize(s, ex);
			intProps.push_back(val);
		}
		int strProps_vector_size = ex ? s.read_int32() : s.read_int16();
		strProps.clear();
		while (strProps_vector_size > 0)
		{
			strProps_vector_size--;
			CrossStrProp val;
			val.unserialize(s, ex);
			strProps.push_back(val);
		}
		int genes_vector_size = ex ? s.read_int32() : s.read_int16();
		genes.clear();
		while (genes_vector_size > 0)
		{
			genes_vector_size--;
			CrossGene val;
			val.unserialize(s, ex);
			genes.push_back(val);
		}
		int skills_vector_size = ex ? s.read_int32() : s.read_int16();
		skills.clear();
		while (skills_vector_size > 0)
		{
			skills_vector_size--;
			CrossSkill val;
			val.unserialize(s, ex);
			skills.push_back(val);
		}
		int combatImmunity_vector_size = ex ? s.read_int32() : s.read_int16();
		combatImmunity.clear();
		while (combatImmunity_vector_size > 0)
		{
			combatImmunity_vector_size--;
			CrossCombat val;
			val.unserialize(s, ex);
			combatImmunity.push_back(val);
		}
		int combatProps_vector_size = ex ? s.read_int32() : s.read_int16();
		combatProps.clear();
		while (combatProps_vector_size > 0)
		{
			combatProps_vector_size--;
			CrossCombat val;
			val.unserialize(s, ex);
			combatProps.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < intProps.size(); ++i)
		{
			intProps[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "intProps");
		lua::newtable(lua::L);
		for (size_t i = 0; i < strProps.size(); ++i)
		{
			strProps[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "strProps");
		lua::newtable(lua::L);
		for (size_t i = 0; i < genes.size(); ++i)
		{
			genes[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "genes");
		lua::newtable(lua::L);
		for (size_t i = 0; i < skills.size(); ++i)
		{
			skills[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "skills");
		lua::newtable(lua::L);
		for (size_t i = 0; i < combatImmunity.size(); ++i)
		{
			combatImmunity[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "combatImmunity");
		lua::newtable(lua::L);
		for (size_t i = 0; i < combatProps.size(); ++i)
		{
			combatProps[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "combatProps");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "intProps=[";
		for (size_t i = 0; i < intProps.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			intProps[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",strProps=[";
		for (size_t i = 0; i < strProps.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			strProps[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",genes=[";
		for (size_t i = 0; i < genes.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			genes[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",skills=[";
		for (size_t i = 0; i < skills.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			skills[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",combatImmunity=[";
		for (size_t i = 0; i < combatImmunity.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			combatImmunity[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",combatProps=[";
		for (size_t i = 0; i < combatProps.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			combatProps[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<CrossIntProp> intProps; //整型属性 
	std::vector<CrossStrProp> strProps; //字符属性 
	std::vector<CrossGene> genes; //基因 
	std::vector<CrossSkill> skills; //技能 
	std::vector<CrossCombat> combatImmunity; //战斗免疫属性 
	std::vector<CrossCombat> combatProps; //战斗属性 
};

struct CrossItemProp
{
public:
	CrossItemProp()
	{
		ctype = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 6;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << ctype;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> ctype;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ctype", ctype);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "ctype=" << ctype;
		buffer << ",data=" << data;
	}

public:
	short ctype;
	int data;
};

class MsgRegisterGameServerToCrossServer : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 1 };

	MsgRegisterGameServerToCrossServer() :
		MessageEx(Category, Id)
	{
		gameServerId = 0;
		gameServerPort = 0;
		dbAgentPort = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRegisterGameServerToCrossServer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 12;
		length += sizeof(short) + gameServerName.size();
		length += sizeof(short) + gameServerAddr.size();
		length += sizeof(short) + dbAgentAddr.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << gameServerId;
		s << gameServerName;
		s << gameServerAddr;
		s << gameServerPort;
		s << dbAgentAddr;
		s << dbAgentPort;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> gameServerId;
		s >> gameServerName;
		s >> gameServerAddr;
		s >> gameServerPort;
		s >> dbAgentAddr;
		s >> dbAgentPort;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "gameServerId", gameServerId);
		lua::settable(L, -1, "gameServerName", gameServerName);
		lua::settable(L, -1, "gameServerAddr", gameServerAddr);
		lua::settable(L, -1, "gameServerPort", gameServerPort);
		lua::settable(L, -1, "dbAgentAddr", dbAgentAddr);
		lua::settable(L, -1, "dbAgentPort", dbAgentPort);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",gameServerId=" << gameServerId;
		buffer << ",gameServerName=" << gameServerName;
		buffer << ",gameServerAddr=" << gameServerAddr;
		buffer << ",gameServerPort=" << gameServerPort;
		buffer << ",dbAgentAddr=" << dbAgentAddr;
		buffer << ",dbAgentPort=" << dbAgentPort;
	}

public:
	int gameServerId;
	std::string gameServerName;
	std::string gameServerAddr;
	int gameServerPort;
	std::string dbAgentAddr;
	int dbAgentPort;
};

struct CrossEventData
{
public:
	CrossEventData()
	{
		id = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
		timeIndex = 0;
	}

	size_t getLength(bool ex) const
	{
		return 20;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << id;
		s << datax;
		s << datay;
		s << dataz;
		s << timeIndex;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> id;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> timeIndex;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "id", id);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "timeIndex", timeIndex);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "id=" << id;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",timeIndex=" << timeIndex;
	}

public:
	int id;
	int datax;
	int datay;
	int dataz;
	int timeIndex;
};

class MsgCreatePlayerInCrossServerRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 3 };

	MsgCreatePlayerInCrossServerRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		dstMapId = 0;
		posX = 0;
		posY = 0;
		job = 0;
		gender = 0;
		level = 0;
		gjtime = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCreatePlayerInCrossServerRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 32;
		length += sizeof(short) + name.size();
		length += sizeof(int);
		for (size_t i = 0; i < events.size(); ++i)
		{
			length += events[i].getLength(true);
		}
		length += playerInfo.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << dstMapId;
		s << posX;
		s << posY;
		s << name;
		s << job;
		s << gender;
		s << level;
		s << gjtime;
		int events_vector_size = (int)events.size();
		s << events_vector_size;
		if (events_vector_size > 0)
		{
			for (auto it = events.begin(); it != events.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		playerInfo.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> dstMapId;
		s >> posX;
		s >> posY;
		s >> name;
		s >> job;
		s >> gender;
		s >> level;
		s >> gjtime;
		int events_vector_size = s.read_int32();
		events.clear();
		while (events_vector_size > 0)
		{
			events_vector_size--;
			CrossEventData val;
			val.unserialize(s, true);
			events.push_back(val);
		}
		playerInfo.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "dstMapId", dstMapId);
		lua::settable(L, -1, "posX", posX);
		lua::settable(L, -1, "posY", posY);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "gjtime", gjtime);
		lua::newtable(lua::L);
		for (size_t i = 0; i < events.size(); ++i)
		{
			events[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "events");
		playerInfo.push(L);
		lua::settable(L, -1, "playerInfo");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",dstMapId=" << dstMapId;
		buffer << ",posX=" << posX;
		buffer << ",posY=" << posY;
		buffer << ",name=" << name;
		buffer << ",job=" << job;
		buffer << ",gender=" << gender;
		buffer << ",level=" << level;
		buffer << ",gjtime=" << gjtime;
		buffer << ",events=[";
		for (size_t i = 0; i < events.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			events[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",playerInfo={";
		playerInfo.dump(buffer);
		buffer << "}";
	}

public:
	int playerId;
	int dstMapId;
	int posX;
	int posY;
	std::string name;
	int job;
	int gender;
	int level;
	int gjtime;
	std::vector<CrossEventData> events;
	CrossCommonStruct playerInfo; //玩家数据 
};

class MsgCreatePlayerInCrossServerEnd : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 7 };

	MsgCreatePlayerInCrossServerEnd() :
		MessageEx(Category, Id)
	{
		playerId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCreatePlayerInCrossServerEnd";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
	}

public:
	int playerId;
};

class MsgCreatePlayerInCrossServerResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 8 };

	MsgCreatePlayerInCrossServerResponse() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		playerEid = 0;
		heroEid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCreatePlayerInCrossServerResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << playerEid;
		s << heroEid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> playerEid;
		s >> heroEid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "playerEid", playerEid);
		lua::settable(L, -1, "heroEid", heroEid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",playerEid=" << playerEid;
		buffer << ",heroEid=" << heroEid;
	}

public:
	int playerId;
	int playerEid;
	int heroEid;
};

class MsgSyncPropToCrossServer : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 9 };

	MsgSyncPropToCrossServer() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncPropToCrossServer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < combatProps.size(); ++i)
		{
			length += combatProps[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		int combatProps_vector_size = (int)combatProps.size();
		s << combatProps_vector_size;
		if (combatProps_vector_size > 0)
		{
			for (auto it = combatProps.begin(); it != combatProps.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		int combatProps_vector_size = s.read_int32();
		combatProps.clear();
		while (combatProps_vector_size > 0)
		{
			combatProps_vector_size--;
			CrossCombat val;
			val.unserialize(s, true);
			combatProps.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < combatProps.size(); ++i)
		{
			combatProps[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "combatProps");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",combatProps=[";
		for (size_t i = 0; i < combatProps.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			combatProps[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	std::vector<CrossCombat> combatProps; //战斗属性 
};

class MsgLeaveFromCrossServerMapRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 10 };

	MsgLeaveFromCrossServerMapRequest() :
		MessageEx(Category, Id)
	{
		sourceServerId = 0;
		playerId = 0;
		dstMapId = 0;
		posX = 0;
		posY = 0;
		reason = 0;
		sceneInstanceId = 0;
		enterSceneType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgLeaveFromCrossServerMapRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 30;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sourceServerId;
		s << playerId;
		s << dstMapId;
		s << posX;
		s << posY;
		s << reason;
		s << sceneInstanceId;
		s << enterSceneType;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sourceServerId;
		s >> playerId;
		s >> dstMapId;
		s >> posX;
		s >> posY;
		s >> reason;
		s >> sceneInstanceId;
		s >> enterSceneType;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sourceServerId", sourceServerId);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "dstMapId", dstMapId);
		lua::settable(L, -1, "posX", posX);
		lua::settable(L, -1, "posY", posY);
		lua::settable(L, -1, "reason", reason);
		lua::settable(L, -1, "sceneInstanceId", sceneInstanceId);
		lua::settable(L, -1, "enterSceneType", enterSceneType);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sourceServerId=" << sourceServerId;
		buffer << ",playerId=" << playerId;
		buffer << ",dstMapId=" << dstMapId;
		buffer << ",posX=" << posX;
		buffer << ",posY=" << posY;
		buffer << ",reason=" << reason;
		buffer << ",sceneInstanceId=" << sceneInstanceId;
		buffer << ",enterSceneType=" << enterSceneType;
	}

public:
	int sourceServerId;
	int playerId;
	int dstMapId;
	int posX;
	int posY;
	short reason;
	int sceneInstanceId;
	int enterSceneType;
};

class MsgLeaveFromCrossServerMapResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 11 };

	MsgLeaveFromCrossServerMapResponse() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		dstMapId = 0;
		posX = 0;
		posY = 0;
		reason = 0;
		sceneInstanceId = 0;
		enterSceneType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgLeaveFromCrossServerMapResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 26;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << dstMapId;
		s << posX;
		s << posY;
		s << reason;
		s << sceneInstanceId;
		s << enterSceneType;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> dstMapId;
		s >> posX;
		s >> posY;
		s >> reason;
		s >> sceneInstanceId;
		s >> enterSceneType;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "dstMapId", dstMapId);
		lua::settable(L, -1, "posX", posX);
		lua::settable(L, -1, "posY", posY);
		lua::settable(L, -1, "reason", reason);
		lua::settable(L, -1, "sceneInstanceId", sceneInstanceId);
		lua::settable(L, -1, "enterSceneType", enterSceneType);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",dstMapId=" << dstMapId;
		buffer << ",posX=" << posX;
		buffer << ",posY=" << posY;
		buffer << ",reason=" << reason;
		buffer << ",sceneInstanceId=" << sceneInstanceId;
		buffer << ",enterSceneType=" << enterSceneType;
	}

public:
	int playerId;
	int dstMapId;
	int posX;
	int posY;
	short reason;
	int sceneInstanceId;
	int enterSceneType;
};

class MsgSyncCommonInfoToCrossServerRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 13 };

	MsgSyncCommonInfoToCrossServerRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		heroId = 0;
		entityType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncCommonInfoToCrossServerRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 10;
		length += commonInfo.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << heroId;
		s << entityType;
		commonInfo.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> heroId;
		s >> entityType;
		commonInfo.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "heroId", heroId);
		lua::settable(L, -1, "entityType", entityType);
		commonInfo.push(L);
		lua::settable(L, -1, "commonInfo");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",heroId=" << heroId;
		buffer << ",entityType=" << entityType;
		buffer << ",commonInfo={";
		commonInfo.dump(buffer);
		buffer << "}";
	}

public:
	int playerId;
	int heroId;
	short entityType;
	CrossCommonStruct commonInfo; //玩家数据 
};

class MsgSyncInfoToGameServerRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 14 };

	MsgSyncInfoToGameServerRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncInfoToGameServerRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += commonInfoPlayer.getLength(true);
		length += commonInfoHero.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		commonInfoPlayer.serialize(s, true);
		commonInfoHero.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		commonInfoPlayer.unserialize(s, true);
		commonInfoHero.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		commonInfoPlayer.push(L);
		lua::settable(L, -1, "commonInfoPlayer");
		commonInfoHero.push(L);
		lua::settable(L, -1, "commonInfoHero");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",commonInfoPlayer={";
		commonInfoPlayer.dump(buffer);
		buffer << "}";
		buffer << ",commonInfoHero={";
		commonInfoHero.dump(buffer);
		buffer << "}";
	}

public:
	int playerId;
	CrossCommonStruct commonInfoPlayer; //玩家数据 
	CrossCommonStruct commonInfoHero; //英雄数据 
};

class MsgSwitchCSMapRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 15 };

	MsgSwitchCSMapRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		dstMapId = 0;
		posX = 0;
		posY = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSwitchCSMapRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << dstMapId;
		s << posX;
		s << posY;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> dstMapId;
		s >> posX;
		s >> posY;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "dstMapId", dstMapId);
		lua::settable(L, -1, "posX", posX);
		lua::settable(L, -1, "posY", posY);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",dstMapId=" << dstMapId;
		buffer << ",posX=" << posX;
		buffer << ",posY=" << posY;
	}

public:
	int playerId;
	int dstMapId;
	int posX;
	int posY;
};

class MsgKickPlayerFromCSRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 16 };

	MsgKickPlayerFromCSRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgKickPlayerFromCSRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
	}

public:
	int playerId;
};

class MsgNotifyGameServerItemAdd : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 51 };

	MsgNotifyGameServerItemAdd() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sid = 0;
		count = 0;
		bindType = 0;
		bag = 0;
		monster = 0;
		opcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgNotifyGameServerItemAdd";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 28;
		length += sizeof(short) + firstowner.size();
		length += sizeof(short) + appraiser.size();
		length += sizeof(int);
		for (size_t i = 0; i < itemProps.size(); ++i)
		{
			length += itemProps[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sid;
		s << count;
		s << bindType;
		s << bag;
		s << monster;
		s << opcode;
		s << firstowner;
		s << appraiser;
		int itemProps_vector_size = (int)itemProps.size();
		s << itemProps_vector_size;
		if (itemProps_vector_size > 0)
		{
			for (auto it = itemProps.begin(); it != itemProps.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sid;
		s >> count;
		s >> bindType;
		s >> bag;
		s >> monster;
		s >> opcode;
		s >> firstowner;
		s >> appraiser;
		int itemProps_vector_size = s.read_int32();
		itemProps.clear();
		while (itemProps_vector_size > 0)
		{
			itemProps_vector_size--;
			CrossItemProp val;
			val.unserialize(s, true);
			itemProps.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "bindType", bindType);
		lua::settable(L, -1, "bag", bag);
		lua::settable(L, -1, "monster", monster);
		lua::settable(L, -1, "opcode", opcode);
		lua::settable(L, -1, "firstowner", firstowner);
		lua::settable(L, -1, "appraiser", appraiser);
		lua::newtable(lua::L);
		for (size_t i = 0; i < itemProps.size(); ++i)
		{
			itemProps[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "itemProps");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",bindType=" << bindType;
		buffer << ",bag=" << bag;
		buffer << ",monster=" << monster;
		buffer << ",opcode=" << opcode;
		buffer << ",firstowner=" << firstowner;
		buffer << ",appraiser=" << appraiser;
		buffer << ",itemProps=[";
		for (size_t i = 0; i < itemProps.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			itemProps[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int sid;
	int count;
	int bindType;
	int bag;
	int monster;
	int opcode;
	std::string firstowner;
	std::string appraiser;
	std::vector<CrossItemProp> itemProps;
};

class MsgNotifyCrossServerItemAbandon : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 52 };

	MsgNotifyCrossServerItemAbandon() :
		MessageEx(Category, Id)
	{
		pid = 0;
		warZoneLineId = 0;
		mapId = 0;
		mapLineId = 0;
		itemId = 0;
		itemCount = 0;
		posX = 0;
		posY = 0;
	}

	virtual const char *getName() const
	{
		return "MsgNotifyCrossServerItemAbandon";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 32;
		length += sizeof(short) + firstowner.size();
		length += sizeof(short) + appraiser.size();
		length += sizeof(int);
		for (size_t i = 0; i < itemProps.size(); ++i)
		{
			length += itemProps[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << warZoneLineId;
		s << mapId;
		s << mapLineId;
		s << itemId;
		s << itemCount;
		s << posX;
		s << posY;
		s << firstowner;
		s << appraiser;
		int itemProps_vector_size = (int)itemProps.size();
		s << itemProps_vector_size;
		if (itemProps_vector_size > 0)
		{
			for (auto it = itemProps.begin(); it != itemProps.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> warZoneLineId;
		s >> mapId;
		s >> mapLineId;
		s >> itemId;
		s >> itemCount;
		s >> posX;
		s >> posY;
		s >> firstowner;
		s >> appraiser;
		int itemProps_vector_size = s.read_int32();
		itemProps.clear();
		while (itemProps_vector_size > 0)
		{
			itemProps_vector_size--;
			CrossItemProp val;
			val.unserialize(s, true);
			itemProps.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "warZoneLineId", warZoneLineId);
		lua::settable(L, -1, "mapId", mapId);
		lua::settable(L, -1, "mapLineId", mapLineId);
		lua::settable(L, -1, "itemId", itemId);
		lua::settable(L, -1, "itemCount", itemCount);
		lua::settable(L, -1, "posX", posX);
		lua::settable(L, -1, "posY", posY);
		lua::settable(L, -1, "firstowner", firstowner);
		lua::settable(L, -1, "appraiser", appraiser);
		lua::newtable(lua::L);
		for (size_t i = 0; i < itemProps.size(); ++i)
		{
			itemProps[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "itemProps");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",warZoneLineId=" << warZoneLineId;
		buffer << ",mapId=" << mapId;
		buffer << ",mapLineId=" << mapLineId;
		buffer << ",itemId=" << itemId;
		buffer << ",itemCount=" << itemCount;
		buffer << ",posX=" << posX;
		buffer << ",posY=" << posY;
		buffer << ",firstowner=" << firstowner;
		buffer << ",appraiser=" << appraiser;
		buffer << ",itemProps=[";
		for (size_t i = 0; i < itemProps.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			itemProps[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int warZoneLineId;
	int mapId;
	int mapLineId;
	int itemId;
	int itemCount;
	int posX;
	int posY;
	std::string firstowner;
	std::string appraiser;
	std::vector<CrossItemProp> itemProps;
};

class MsgCrossMapDropRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 55 };

	MsgCrossMapDropRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		mapId = 0;
		mapLineId = 0;
		posx = 0;
		posy = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossMapDropRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 20;
		length += sizeof(short) + killerName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << mapId;
		s << mapLineId;
		s << posx;
		s << posy;
		s << killerName;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> mapId;
		s >> mapLineId;
		s >> posx;
		s >> posy;
		s >> killerName;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "mapId", mapId);
		lua::settable(L, -1, "mapLineId", mapLineId);
		lua::settable(L, -1, "posx", posx);
		lua::settable(L, -1, "posy", posy);
		lua::settable(L, -1, "killerName", killerName);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",mapId=" << mapId;
		buffer << ",mapLineId=" << mapLineId;
		buffer << ",posx=" << posx;
		buffer << ",posy=" << posy;
		buffer << ",killerName=" << killerName;
	}

public:
	int playerId;
	int mapId;
	int mapLineId;
	int posx;
	int posy;
	std::string killerName;
};

class MsgReviveInCSMapRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 56 };

	MsgReviveInCSMapRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		subType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgReviveInCSMapRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << subType;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> subType;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "subType", subType);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",subType=" << subType;
	}

public:
	int playerId;
	int subType;
};

class MsgReviveInCSMapResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 57 };

	MsgReviveInCSMapResponse() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		subType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgReviveInCSMapResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << subType;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> subType;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "subType", subType);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",subType=" << subType;
	}

public:
	int playerId;
	int subType;
};

class MsgConveyToSceneRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 58 };

	MsgConveyToSceneRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		mapId = 0;
		posX = 0;
		posY = 0;
	}

	virtual const char *getName() const
	{
		return "MsgConveyToSceneRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << mapId;
		s << posX;
		s << posY;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> mapId;
		s >> posX;
		s >> posY;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "mapId", mapId);
		lua::settable(L, -1, "posX", posX);
		lua::settable(L, -1, "posY", posY);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",mapId=" << mapId;
		buffer << ",posX=" << posX;
		buffer << ",posY=" << posY;
	}

public:
	int playerId;
	int mapId;
	int posX;
	int posY;
};

class MsgSyncEventDataRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 59 };

	MsgSyncEventDataRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncEventDataRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += data.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		data.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		data.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		data.push(L);
		lua::settable(L, -1, "data");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",data={";
		data.dump(buffer);
		buffer << "}";
	}

public:
	int playerId;
	CrossEventData data;
};

class MsgResetAndSyncAllEventDataNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 60 };

	MsgResetAndSyncAllEventDataNotify() :
		MessageEx(Category, Id)
	{
		playerId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgResetAndSyncAllEventDataNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < events.size(); ++i)
		{
			length += events[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		int events_vector_size = (int)events.size();
		s << events_vector_size;
		if (events_vector_size > 0)
		{
			for (auto it = events.begin(); it != events.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		int events_vector_size = s.read_int32();
		events.clear();
		while (events_vector_size > 0)
		{
			events_vector_size--;
			CrossEventData val;
			val.unserialize(s, true);
			events.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::newtable(lua::L);
		for (size_t i = 0; i < events.size(); ++i)
		{
			events[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "events");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",events=[";
		for (size_t i = 0; i < events.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			events[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int playerId;
	std::vector<CrossEventData> events;
};

class MsgUseItemInCSMapRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 61 };

	MsgUseItemInCSMapRequest() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		sid = 0;
		count = 0;
		rid = 0;
		targetType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgUseItemInCSMapRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << sid;
		s << count;
		s << rid;
		s << targetType;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> sid;
		s >> count;
		s >> rid;
		s >> targetType;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "rid", rid);
		lua::settable(L, -1, "targetType", targetType);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",rid=" << rid;
		buffer << ",targetType=" << targetType;
	}

public:
	int playerId;
	int sid;
	int count;
	int rid;
	int targetType;
};

class MsgSyncCSPosToGSNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 62 };

	MsgSyncCSPosToGSNotify() :
		MessageEx(Category, Id)
	{
		playerId = 0;
		mapId = 0;
		mapLineId = 0;
		posX = 0;
		posY = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncCSPosToGSNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << playerId;
		s << mapId;
		s << mapLineId;
		s << posX;
		s << posY;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> playerId;
		s >> mapId;
		s >> mapLineId;
		s >> posX;
		s >> posY;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "playerId", playerId);
		lua::settable(L, -1, "mapId", mapId);
		lua::settable(L, -1, "mapLineId", mapLineId);
		lua::settable(L, -1, "posX", posX);
		lua::settable(L, -1, "posY", posY);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",playerId=" << playerId;
		buffer << ",mapId=" << mapId;
		buffer << ",mapLineId=" << mapLineId;
		buffer << ",posX=" << posX;
		buffer << ",posY=" << posY;
	}

public:
	int playerId;
	int mapId;
	int mapLineId;
	int posX;
	int posY;
};

class MsgBroadcastSystemPromptToGSNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 63 };

	MsgBroadcastSystemPromptToGSNotify() :
		MessageEx(Category, Id)
	{
		serverId = 0;
		itemSid = 0;
		showflag = 0;
	}

	virtual const char *getName() const
	{
		return "MsgBroadcastSystemPromptToGSNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 12;
		length += sizeof(short) + msg.size();
		length += sizeof(short) + touchID.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << serverId;
		s << msg;
		s << touchID;
		s << itemSid;
		s << showflag;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> serverId;
		s >> msg;
		s >> touchID;
		s >> itemSid;
		s >> showflag;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "msg", msg);
		lua::settable(L, -1, "touchID", touchID);
		lua::settable(L, -1, "itemSid", itemSid);
		lua::settable(L, -1, "showflag", showflag);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",serverId=" << serverId;
		buffer << ",msg=" << msg;
		buffer << ",touchID=" << touchID;
		buffer << ",itemSid=" << itemSid;
		buffer << ",showflag=" << showflag;
	}

public:
	int serverId;
	std::string msg;
	std::string touchID;
	int itemSid;
	int showflag;
};

struct CrossBossInfo
{
public:
	CrossBossInfo()
	{
		index = 0;
		bossId = 0;
		freshTime = 0;
		alive = 0;
	}

	size_t getLength(bool ex) const
	{
		return 14;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << index;
		s << bossId;
		s << freshTime;
		s << alive;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> index;
		s >> bossId;
		s >> freshTime;
		s >> alive;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "index", index);
		lua::settable(L, -1, "bossId", bossId);
		lua::settable(L, -1, "freshTime", freshTime);
		lua::settable(L, -1, "alive", alive);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "index=" << index;
		buffer << ",bossId=" << bossId;
		buffer << ",freshTime=" << freshTime;
		buffer << ",alive=" << alive;
	}

public:
	int index;
	int bossId;
	int freshTime;
	short alive;
};

class MsgSyncBossInfoToGSNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 64 };

	MsgSyncBossInfoToGSNotify() :
		MessageEx(Category, Id)
	{
		serverId = 0;
		sceneId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncBossInfoToGSNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < list.size(); ++i)
		{
			length += list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << serverId;
		s << sceneId;
		int list_vector_size = (int)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> serverId;
		s >> sceneId;
		int list_vector_size = s.read_int32();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			CrossBossInfo val;
			val.unserialize(s, true);
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "sceneId", sceneId);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",serverId=" << serverId;
		buffer << ",sceneId=" << sceneId;
		buffer << ",list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int serverId;
	int sceneId;
	std::vector<CrossBossInfo> list;
};

class MsgGetQualifiedPlayerListNearbyRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 66 };

	MsgGetQualifiedPlayerListNearbyRequest() :
		MessageEx(Category, Id)
	{
		pid = 0;
		condition = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetQualifiedPlayerListNearbyRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << condition;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> condition;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "condition", condition);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",condition=" << condition;
	}

public:
	int pid;
	int condition;
};

class MsgGetQualifiedPlayerListNearbyResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 67 };

	MsgGetQualifiedPlayerListNearbyResponse() :
		MessageEx(Category, Id)
	{
		pid = 0;
		condition = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetQualifiedPlayerListNearbyResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		length += list.size() * 4;
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << condition;
		int list_vector_size = (int)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> condition;
		int list_vector_size = s.read_int32();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			int val;
			s >> val;
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "condition", condition);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, list[i]);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",condition=" << condition;
		buffer << ",list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << list[i];
		}
		buffer << "]";
	}

public:
	int pid;
	int condition;
	std::vector<int> list;
};

struct WarZoneDropInfo
{
public:
	WarZoneDropInfo()
	{
		killerPid = 0;
		mapId = 0;
		monsterId = 0;
		dropItemId = 0;
		dropTime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += sizeof(short) + killerName.size();
		length += sizeof(short) + gameServerName.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << killerPid;
		s << killerName;
		s << gameServerName;
		s << mapId;
		s << monsterId;
		s << dropItemId;
		s << dropTime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> killerPid;
		s >> killerName;
		s >> gameServerName;
		s >> mapId;
		s >> monsterId;
		s >> dropItemId;
		s >> dropTime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "killerPid", killerPid);
		lua::settable(L, -1, "killerName", killerName);
		lua::settable(L, -1, "gameServerName", gameServerName);
		lua::settable(L, -1, "mapId", mapId);
		lua::settable(L, -1, "monsterId", monsterId);
		lua::settable(L, -1, "dropItemId", dropItemId);
		lua::settable(L, -1, "dropTime", dropTime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "killerPid=" << killerPid;
		buffer << ",killerName=" << killerName;
		buffer << ",gameServerName=" << gameServerName;
		buffer << ",mapId=" << mapId;
		buffer << ",monsterId=" << monsterId;
		buffer << ",dropItemId=" << dropItemId;
		buffer << ",dropTime=" << dropTime;
	}

public:
	int killerPid;
	std::string killerName;
	std::string gameServerName;
	int mapId;
	int monsterId;
	int dropItemId;
	int dropTime;
};

class MsgSyncWarZoneDropInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 68 };

	MsgSyncWarZoneDropInfo() :
		MessageEx(Category, Id)
	{
		reload = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncWarZoneDropInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 2;
		length += sizeof(int);
		for (size_t i = 0; i < topDropInfoList.size(); ++i)
		{
			length += topDropInfoList[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < dropInfoList.size(); ++i)
		{
			length += dropInfoList[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << reload;
		int topDropInfoList_vector_size = (int)topDropInfoList.size();
		s << topDropInfoList_vector_size;
		if (topDropInfoList_vector_size > 0)
		{
			for (auto it = topDropInfoList.begin(); it != topDropInfoList.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int dropInfoList_vector_size = (int)dropInfoList.size();
		s << dropInfoList_vector_size;
		if (dropInfoList_vector_size > 0)
		{
			for (auto it = dropInfoList.begin(); it != dropInfoList.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> reload;
		int topDropInfoList_vector_size = s.read_int32();
		topDropInfoList.clear();
		while (topDropInfoList_vector_size > 0)
		{
			topDropInfoList_vector_size--;
			WarZoneDropInfo val;
			val.unserialize(s, true);
			topDropInfoList.push_back(val);
		}
		int dropInfoList_vector_size = s.read_int32();
		dropInfoList.clear();
		while (dropInfoList_vector_size > 0)
		{
			dropInfoList_vector_size--;
			WarZoneDropInfo val;
			val.unserialize(s, true);
			dropInfoList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "reload", reload);
		lua::newtable(lua::L);
		for (size_t i = 0; i < topDropInfoList.size(); ++i)
		{
			topDropInfoList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "topDropInfoList");
		lua::newtable(lua::L);
		for (size_t i = 0; i < dropInfoList.size(); ++i)
		{
			dropInfoList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "dropInfoList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",reload=" << reload;
		buffer << ",topDropInfoList=[";
		for (size_t i = 0; i < topDropInfoList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			topDropInfoList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",dropInfoList=[";
		for (size_t i = 0; i < dropInfoList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			dropInfoList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	short reload;
	std::vector<WarZoneDropInfo> topDropInfoList;
	std::vector<WarZoneDropInfo> dropInfoList;
};

class MsgSyncWarZoneDropInfoToCS : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 69 };

	MsgSyncWarZoneDropInfoToCS() :
		MessageEx(Category, Id)
	{
		top = 0;
		serverId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncWarZoneDropInfoToCS";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 6;
		length += record.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << top;
		s << serverId;
		record.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> top;
		s >> serverId;
		record.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "top", top);
		lua::settable(L, -1, "serverId", serverId);
		record.push(L);
		lua::settable(L, -1, "record");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",top=" << top;
		buffer << ",serverId=" << serverId;
		buffer << ",record={";
		record.dump(buffer);
		buffer << "}";
	}

public:
	short top;
	int serverId;
	WarZoneDropInfo record;
};

struct CrossAcution
{
public:
	CrossAcution()
	{
		aid = 0;
		sid = 0;
		count = 0;
		fixed_price = 0;
		start_price = 0;
		things_type = 0;
		status = 0;
		buyer_pid = 0;
		cur_price = 0;
		atime = 0;
		etime = 0;
		crt_type = 0;
		next_auction = 0;
		guild_id = 0;
		server_id = 0;
		war_zone_id = 0;
		buyer_server_id = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 72;
		length += sizeof(short) + buyer_name.size();
		length += ex ? sizeof(int) : sizeof(short);
		length += parters.size() * 4;
		length += ex ? sizeof(int) : sizeof(short);
		length += buyers.size() * 4;
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << aid;
		s << sid;
		s << count;
		s << fixed_price;
		s << start_price;
		s << things_type;
		s << status;
		s << buyer_pid;
		s << buyer_name;
		s << cur_price;
		s << atime;
		s << etime;
		int parters_vector_size = ex ? (int)parters.size() : (short)parters.size();
		if (ex)
		{
			s << parters_vector_size;
		}
		else
		{
			s << (short)parters_vector_size;
		}
		if (parters_vector_size > 0)
		{
			for (auto it = parters.begin(); it != parters.end(); ++it)
			{
				s << *it;
			}
		}
		int buyers_vector_size = ex ? (int)buyers.size() : (short)buyers.size();
		if (ex)
		{
			s << buyers_vector_size;
		}
		else
		{
			s << (short)buyers_vector_size;
		}
		if (buyers_vector_size > 0)
		{
			for (auto it = buyers.begin(); it != buyers.end(); ++it)
			{
				s << *it;
			}
		}
		s << crt_type;
		s << next_auction;
		s << guild_id;
		s << server_id;
		s << war_zone_id;
		s << buyer_server_id;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> aid;
		s >> sid;
		s >> count;
		s >> fixed_price;
		s >> start_price;
		s >> things_type;
		s >> status;
		s >> buyer_pid;
		s >> buyer_name;
		s >> cur_price;
		s >> atime;
		s >> etime;
		int parters_vector_size = ex ? s.read_int32() : s.read_int16();
		parters.clear();
		while (parters_vector_size > 0)
		{
			parters_vector_size--;
			int val;
			s >> val;
			parters.push_back(val);
		}
		int buyers_vector_size = ex ? s.read_int32() : s.read_int16();
		buyers.clear();
		while (buyers_vector_size > 0)
		{
			buyers_vector_size--;
			int val;
			s >> val;
			buyers.push_back(val);
		}
		s >> crt_type;
		s >> next_auction;
		s >> guild_id;
		s >> server_id;
		s >> war_zone_id;
		s >> buyer_server_id;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "fixed_price", fixed_price);
		lua::settable(L, -1, "start_price", start_price);
		lua::settable(L, -1, "things_type", things_type);
		lua::settable(L, -1, "status", status);
		lua::settable(L, -1, "buyer_pid", buyer_pid);
		lua::settable(L, -1, "buyer_name", buyer_name);
		lua::settable(L, -1, "cur_price", cur_price);
		lua::settable(L, -1, "atime", atime);
		lua::settable(L, -1, "etime", etime);
		lua::newtable(lua::L);
		for (size_t i = 0; i < parters.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, parters[i]);
		}
		lua::settable(L, -2, "parters");
		lua::newtable(lua::L);
		for (size_t i = 0; i < buyers.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, buyers[i]);
		}
		lua::settable(L, -2, "buyers");
		lua::settable(L, -1, "crt_type", crt_type);
		lua::settable(L, -1, "next_auction", next_auction);
		lua::settable(L, -1, "guild_id", guild_id);
		lua::settable(L, -1, "server_id", server_id);
		lua::settable(L, -1, "war_zone_id", war_zone_id);
		lua::settable(L, -1, "buyer_server_id", buyer_server_id);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "aid=" << aid;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",fixed_price=" << fixed_price;
		buffer << ",start_price=" << start_price;
		buffer << ",things_type=" << things_type;
		buffer << ",status=" << status;
		buffer << ",buyer_pid=" << buyer_pid;
		buffer << ",buyer_name=" << buyer_name;
		buffer << ",cur_price=" << cur_price;
		buffer << ",atime=" << atime;
		buffer << ",etime=" << etime;
		buffer << ",parters=[";
		for (size_t i = 0; i < parters.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << parters[i];
		}
		buffer << "]";
		buffer << ",buyers=[";
		for (size_t i = 0; i < buyers.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << buyers[i];
		}
		buffer << "]";
		buffer << ",crt_type=" << crt_type;
		buffer << ",next_auction=" << next_auction;
		buffer << ",guild_id=" << guild_id;
		buffer << ",server_id=" << server_id;
		buffer << ",war_zone_id=" << war_zone_id;
		buffer << ",buyer_server_id=" << buyer_server_id;
	}

public:
	long long aid; //拍卖ID 
	int sid; //物品ID 
	int count; //物品数量 
	int fixed_price; //一口价 
	int start_price; //起拍价 
	int things_type; //货币类型 
	int status; //拍卖状态 
	int buyer_pid; //竞价人pid 
	std::string buyer_name; //竞价人名字 
	int cur_price; //当前竞拍价格 
	int atime; //成交时间 
	int etime; //过期时间 
	std::vector<int> parters; //拍卖受益人 
	std::vector<int> buyers; //拍卖竞价者 
	int crt_type; //当前竞拍归属组 
	int next_auction; //是否进入下一拍卖行 
	int guild_id; //公会id 
	int server_id; //区服id 
	int war_zone_id; //战区id 
	int buyer_server_id; //竞价人区服id 
};

struct RyzRank
{
public:
	RyzRank()
	{
		pid = 0;
		gender = 0;
		zhiye = 0;
		chengji = 0;
		ryz = 0;
		force = 0;
		robbedCnt = 0;
		fighting = 0;
		challengeCnt = 0;
		lastchallengetime = 0;
		sourceWorldID = 0;
		warzoneID = 0;
		logintime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 52;
		length += sizeof(short) + name.size();
		length += sizeof(short) + sourceSvrName.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << name;
		s << gender;
		s << zhiye;
		s << chengji;
		s << ryz;
		s << force;
		s << robbedCnt;
		s << fighting;
		s << challengeCnt;
		s << lastchallengetime;
		s << sourceWorldID;
		s << warzoneID;
		s << logintime;
		s << sourceSvrName;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> name;
		s >> gender;
		s >> zhiye;
		s >> chengji;
		s >> ryz;
		s >> force;
		s >> robbedCnt;
		s >> fighting;
		s >> challengeCnt;
		s >> lastchallengetime;
		s >> sourceWorldID;
		s >> warzoneID;
		s >> logintime;
		s >> sourceSvrName;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "zhiye", zhiye);
		lua::settable(L, -1, "chengji", chengji);
		lua::settable(L, -1, "ryz", ryz);
		lua::settable(L, -1, "force", force);
		lua::settable(L, -1, "robbedCnt", robbedCnt);
		lua::settable(L, -1, "fighting", fighting);
		lua::settable(L, -1, "challengeCnt", challengeCnt);
		lua::settable(L, -1, "lastchallengetime", lastchallengetime);
		lua::settable(L, -1, "sourceWorldID", sourceWorldID);
		lua::settable(L, -1, "warzoneID", warzoneID);
		lua::settable(L, -1, "logintime", logintime);
		lua::settable(L, -1, "sourceSvrName", sourceSvrName);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",gender=" << gender;
		buffer << ",zhiye=" << zhiye;
		buffer << ",chengji=" << chengji;
		buffer << ",ryz=" << ryz;
		buffer << ",force=" << force;
		buffer << ",robbedCnt=" << robbedCnt;
		buffer << ",fighting=" << fighting;
		buffer << ",challengeCnt=" << challengeCnt;
		buffer << ",lastchallengetime=" << lastchallengetime;
		buffer << ",sourceWorldID=" << sourceWorldID;
		buffer << ",warzoneID=" << warzoneID;
		buffer << ",logintime=" << logintime;
		buffer << ",sourceSvrName=" << sourceSvrName;
	}

public:
	int pid;
	std::string name;
	int gender;
	int zhiye;
	int chengji;
	int ryz;
	int force;
	int robbedCnt;
	int fighting;
	int challengeCnt;
	int lastchallengetime;
	int sourceWorldID;
	int warzoneID;
	int logintime;
	std::string sourceSvrName;
};

class MsgAddItemToCrossAuctionRequset : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 70 };

	MsgAddItemToCrossAuctionRequset() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgAddItemToCrossAuctionRequset";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += auctionItem.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		auctionItem.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		auctionItem.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		auctionItem.push(L);
		lua::settable(L, -1, "auctionItem");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",auctionItem={";
		auctionItem.dump(buffer);
		buffer << "}";
	}

public:
	CrossAcution auctionItem;
};

class MsgCrossAuctionItemAddNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 71 };

	MsgCrossAuctionItemAddNotify() :
		MessageEx(Category, Id)
	{
		reload = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossAuctionItemAddNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 2;
		length += sizeof(int);
		for (size_t i = 0; i < auctionItemList.size(); ++i)
		{
			length += auctionItemList[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << reload;
		int auctionItemList_vector_size = (int)auctionItemList.size();
		s << auctionItemList_vector_size;
		if (auctionItemList_vector_size > 0)
		{
			for (auto it = auctionItemList.begin(); it != auctionItemList.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> reload;
		int auctionItemList_vector_size = s.read_int32();
		auctionItemList.clear();
		while (auctionItemList_vector_size > 0)
		{
			auctionItemList_vector_size--;
			CrossAcution val;
			val.unserialize(s, true);
			auctionItemList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "reload", reload);
		lua::newtable(lua::L);
		for (size_t i = 0; i < auctionItemList.size(); ++i)
		{
			auctionItemList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "auctionItemList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",reload=" << reload;
		buffer << ",auctionItemList=[";
		for (size_t i = 0; i < auctionItemList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			auctionItemList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	short reload;
	std::vector<CrossAcution> auctionItemList;
};

class MsgCrossAuctionItemRmvNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 72 };

	MsgCrossAuctionItemRmvNotify() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgCrossAuctionItemRmvNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < auctionItemList.size(); ++i)
		{
			length += auctionItemList[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int auctionItemList_vector_size = (int)auctionItemList.size();
		s << auctionItemList_vector_size;
		if (auctionItemList_vector_size > 0)
		{
			for (auto it = auctionItemList.begin(); it != auctionItemList.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int auctionItemList_vector_size = s.read_int32();
		auctionItemList.clear();
		while (auctionItemList_vector_size > 0)
		{
			auctionItemList_vector_size--;
			CrossAcution val;
			val.unserialize(s, true);
			auctionItemList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < auctionItemList.size(); ++i)
		{
			auctionItemList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "auctionItemList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",auctionItemList=[";
		for (size_t i = 0; i < auctionItemList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			auctionItemList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<CrossAcution> auctionItemList;
};

class MsgCrossAuctionRecordNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 73 };

	MsgCrossAuctionRecordNotify() :
		MessageEx(Category, Id)
	{
		buyer_pid = 0;
		other_pid = 0;
		sid = 0;
		count = 0;
		fixed_price = 0;
		things_type = 0;
		ctype = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossAuctionRecordNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 26;
		length += sizeof(short) + buyer_name.size();
		length += sizeof(short) + other_name.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyer_pid;
		s << buyer_name;
		s << other_pid;
		s << other_name;
		s << sid;
		s << count;
		s << fixed_price;
		s << things_type;
		s << ctype;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyer_pid;
		s >> buyer_name;
		s >> other_pid;
		s >> other_name;
		s >> sid;
		s >> count;
		s >> fixed_price;
		s >> things_type;
		s >> ctype;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyer_pid", buyer_pid);
		lua::settable(L, -1, "buyer_name", buyer_name);
		lua::settable(L, -1, "other_pid", other_pid);
		lua::settable(L, -1, "other_name", other_name);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "fixed_price", fixed_price);
		lua::settable(L, -1, "things_type", things_type);
		lua::settable(L, -1, "ctype", ctype);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyer_pid=" << buyer_pid;
		buffer << ",buyer_name=" << buyer_name;
		buffer << ",other_pid=" << other_pid;
		buffer << ",other_name=" << other_name;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",fixed_price=" << fixed_price;
		buffer << ",things_type=" << things_type;
		buffer << ",ctype=" << ctype;
	}

public:
	int buyer_pid; //竞价人pid 
	std::string buyer_name; //竞价人名字 
	int other_pid; //卖家pid 
	std::string other_name; //卖家名字 
	int sid; //物品ID 
	int count; //物品数量 
	int fixed_price; //一口价 
	int things_type; //货币类型 
	short ctype; //货币类型 
};

class MsgCheckBuyCrossAuctionItemRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 74 };

	MsgCheckBuyCrossAuctionItemRequest() :
		MessageEx(Category, Id)
	{
		buyer_pid = 0;
		buyer_server_id = 0;
		buyer_war_zone_id = 0;
		aid = 0;
		type = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCheckBuyCrossAuctionItemRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 22;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyer_pid;
		s << buyer_server_id;
		s << buyer_war_zone_id;
		s << aid;
		s << type;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyer_pid;
		s >> buyer_server_id;
		s >> buyer_war_zone_id;
		s >> aid;
		s >> type;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyer_pid", buyer_pid);
		lua::settable(L, -1, "buyer_server_id", buyer_server_id);
		lua::settable(L, -1, "buyer_war_zone_id", buyer_war_zone_id);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "type", type);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyer_pid=" << buyer_pid;
		buffer << ",buyer_server_id=" << buyer_server_id;
		buffer << ",buyer_war_zone_id=" << buyer_war_zone_id;
		buffer << ",aid=" << aid;
		buffer << ",type=" << type;
	}

public:
	int buyer_pid; //竞价人pid 
	int buyer_server_id; //竞价人区服id 
	int buyer_war_zone_id; //竞价人战区id 
	long long aid; //拍卖ID 
	short type; //竞拍类型 
};

class MsgCheckBuyCrossAuctionItemResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 75 };

	MsgCheckBuyCrossAuctionItemResponse() :
		MessageEx(Category, Id)
	{
		buyer_pid = 0;
		aid = 0;
		type = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCheckBuyCrossAuctionItemResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 18;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyer_pid;
		s << aid;
		s << type;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyer_pid;
		s >> aid;
		s >> type;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyer_pid", buyer_pid);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyer_pid=" << buyer_pid;
		buffer << ",aid=" << aid;
		buffer << ",type=" << type;
		buffer << ",errcode=" << errcode;
	}

public:
	int buyer_pid; //竞价人pid 
	long long aid; //拍卖ID 
	short type; //竞拍类型 
	int errcode; //错误码 
};

class MsgBuyCrossAuctionItemRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 76 };

	MsgBuyCrossAuctionItemRequest() :
		MessageEx(Category, Id)
	{
		buyer_pid = 0;
		buyer_server_id = 0;
		buyer_war_zone_id = 0;
		cost_money = 0;
		money_type = 0;
		aid = 0;
		sid = 0;
		type = 0;
	}

	virtual const char *getName() const
	{
		return "MsgBuyCrossAuctionItemRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 34;
		length += sizeof(short) + buyer_name.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyer_pid;
		s << buyer_name;
		s << buyer_server_id;
		s << buyer_war_zone_id;
		s << cost_money;
		s << money_type;
		s << aid;
		s << sid;
		s << type;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyer_pid;
		s >> buyer_name;
		s >> buyer_server_id;
		s >> buyer_war_zone_id;
		s >> cost_money;
		s >> money_type;
		s >> aid;
		s >> sid;
		s >> type;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyer_pid", buyer_pid);
		lua::settable(L, -1, "buyer_name", buyer_name);
		lua::settable(L, -1, "buyer_server_id", buyer_server_id);
		lua::settable(L, -1, "buyer_war_zone_id", buyer_war_zone_id);
		lua::settable(L, -1, "cost_money", cost_money);
		lua::settable(L, -1, "money_type", money_type);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "type", type);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyer_pid=" << buyer_pid;
		buffer << ",buyer_name=" << buyer_name;
		buffer << ",buyer_server_id=" << buyer_server_id;
		buffer << ",buyer_war_zone_id=" << buyer_war_zone_id;
		buffer << ",cost_money=" << cost_money;
		buffer << ",money_type=" << money_type;
		buffer << ",aid=" << aid;
		buffer << ",sid=" << sid;
		buffer << ",type=" << type;
	}

public:
	int buyer_pid; //竞价人pid 
	std::string buyer_name; //竞价人名字 
	int buyer_server_id; //竞价人区服id 
	int buyer_war_zone_id; //竞价人战区id 
	int cost_money; //出价 
	int money_type; //货币类型 
	long long aid; //拍卖ID 
	int sid; //拍卖物品id 
	short type; //竞拍类型 
};

class MsgBuyCrossAuctionItemResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 77 };

	MsgBuyCrossAuctionItemResponse() :
		MessageEx(Category, Id)
	{
		buyer_pid = 0;
		buyer_server_id = 0;
		cost_money = 0;
		money_type = 0;
		sid = 0;
		type = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgBuyCrossAuctionItemResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 26;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyer_pid;
		s << buyer_server_id;
		s << cost_money;
		s << money_type;
		s << sid;
		s << type;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyer_pid;
		s >> buyer_server_id;
		s >> cost_money;
		s >> money_type;
		s >> sid;
		s >> type;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyer_pid", buyer_pid);
		lua::settable(L, -1, "buyer_server_id", buyer_server_id);
		lua::settable(L, -1, "cost_money", cost_money);
		lua::settable(L, -1, "money_type", money_type);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyer_pid=" << buyer_pid;
		buffer << ",buyer_server_id=" << buyer_server_id;
		buffer << ",cost_money=" << cost_money;
		buffer << ",money_type=" << money_type;
		buffer << ",sid=" << sid;
		buffer << ",type=" << type;
		buffer << ",errcode=" << errcode;
	}

public:
	int buyer_pid; //竞价人pid 
	int buyer_server_id; //竞价人区服id 
	int cost_money; //出价 
	int money_type; //货币类型 
	int sid; //拍卖物品id 
	short type; //竞拍类型 
	int errcode; //错误码 
};

class MsgCrossAuctionItemUpdNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 78 };

	MsgCrossAuctionItemUpdNotify() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgCrossAuctionItemUpdNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += auctionItem.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		auctionItem.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		auctionItem.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		auctionItem.push(L);
		lua::settable(L, -1, "auctionItem");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",auctionItem={";
		auctionItem.dump(buffer);
		buffer << "}";
	}

public:
	CrossAcution auctionItem;
};

struct CrossConsignmentItemProp
{
public:
	CrossConsignmentItemProp()
	{
		idx = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 6;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << idx;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> idx;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "idx=" << idx;
		buffer << ",data=" << data;
	}

public:
	short idx;
	int data;
};

struct CrossConsignment
{
public:
	CrossConsignment()
	{
		sellerPid = 0;
		sellerServerId = 0;
		sellerWarZoneId = 0;
		cid = 0;
		sid = 0;
		count = 0;
		taxRate = 0;
		price = 0;
		ctime = 0;
		etime = 0;
		mailTip = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 44;
		length += sizeof(short) + sellerName.size();
		length += sizeof(short) + sellerServerName.size();
		length += sizeof(short) + firstOwner.size();
		length += sizeof(short) + appraiser.size();
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << sellerPid;
		s << sellerName;
		s << sellerServerId;
		s << sellerServerName;
		s << sellerWarZoneId;
		s << cid;
		s << sid;
		s << count;
		s << taxRate;
		s << price;
		s << ctime;
		s << etime;
		s << firstOwner;
		s << appraiser;
		s << mailTip;
		int props_vector_size = ex ? (int)props.size() : (short)props.size();
		if (ex)
		{
			s << props_vector_size;
		}
		else
		{
			s << (short)props_vector_size;
		}
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> sellerPid;
		s >> sellerName;
		s >> sellerServerId;
		s >> sellerServerName;
		s >> sellerWarZoneId;
		s >> cid;
		s >> sid;
		s >> count;
		s >> taxRate;
		s >> price;
		s >> ctime;
		s >> etime;
		s >> firstOwner;
		s >> appraiser;
		s >> mailTip;
		int props_vector_size = ex ? s.read_int32() : s.read_int16();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			CrossConsignmentItemProp val;
			val.unserialize(s, ex);
			props.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "sellerName", sellerName);
		lua::settable(L, -1, "sellerServerId", sellerServerId);
		lua::settable(L, -1, "sellerServerName", sellerServerName);
		lua::settable(L, -1, "sellerWarZoneId", sellerWarZoneId);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "taxRate", taxRate);
		lua::settable(L, -1, "price", price);
		lua::settable(L, -1, "ctime", ctime);
		lua::settable(L, -1, "etime", etime);
		lua::settable(L, -1, "firstOwner", firstOwner);
		lua::settable(L, -1, "appraiser", appraiser);
		lua::settable(L, -1, "mailTip", mailTip);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "sellerPid=" << sellerPid;
		buffer << ",sellerName=" << sellerName;
		buffer << ",sellerServerId=" << sellerServerId;
		buffer << ",sellerServerName=" << sellerServerName;
		buffer << ",sellerWarZoneId=" << sellerWarZoneId;
		buffer << ",cid=" << cid;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",taxRate=" << taxRate;
		buffer << ",price=" << price;
		buffer << ",ctime=" << ctime;
		buffer << ",etime=" << etime;
		buffer << ",firstOwner=" << firstOwner;
		buffer << ",appraiser=" << appraiser;
		buffer << ",mailTip=" << mailTip;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int sellerPid; //卖家ID 
	std::string sellerName; //卖家姓名 
	int sellerServerId; //卖家服务器id 
	std::string sellerServerName; //卖家服务器名称 
	int sellerWarZoneId; //卖家战区id 
	int cid; //寄售ID 
	int sid; //物品ID 
	int count; //物品数量 
	int taxRate; //税率 
	int price; //出售价格 
	int ctime; //寄售时间 
	int etime; //过期时间 
	std::string firstOwner; //第一个拥有者 
	std::string appraiser; //鉴定者 
	int mailTip; //邮件提示 
	std::vector<CrossConsignmentItemProp> props;
};

class MsgAddConsignmentToCrossRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 79 };

	MsgAddConsignmentToCrossRequest() :
		MessageEx(Category, Id)
	{
		pid = 0;
		srcServerId = 0;
		warZoneId = 0;
		sid = 0;
		taxRate = 0;
		count = 0;
		price = 0;
		time = 0;
		cTime = 0;
		eTime = 0;
		mailTip = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAddConsignmentToCrossRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 44;
		length += sizeof(short) + name.size();
		length += sizeof(short) + srcServerName.size();
		length += sizeof(short) + firstOwner.size();
		length += sizeof(short) + appraiser.size();
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << name;
		s << srcServerId;
		s << srcServerName;
		s << warZoneId;
		s << sid;
		s << taxRate;
		s << count;
		s << price;
		s << time;
		s << cTime;
		s << eTime;
		s << mailTip;
		s << firstOwner;
		s << appraiser;
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> name;
		s >> srcServerId;
		s >> srcServerName;
		s >> warZoneId;
		s >> sid;
		s >> taxRate;
		s >> count;
		s >> price;
		s >> time;
		s >> cTime;
		s >> eTime;
		s >> mailTip;
		s >> firstOwner;
		s >> appraiser;
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			CrossConsignmentItemProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "srcServerId", srcServerId);
		lua::settable(L, -1, "srcServerName", srcServerName);
		lua::settable(L, -1, "warZoneId", warZoneId);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "taxRate", taxRate);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "price", price);
		lua::settable(L, -1, "time", time);
		lua::settable(L, -1, "cTime", cTime);
		lua::settable(L, -1, "eTime", eTime);
		lua::settable(L, -1, "mailTip", mailTip);
		lua::settable(L, -1, "firstOwner", firstOwner);
		lua::settable(L, -1, "appraiser", appraiser);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",srcServerId=" << srcServerId;
		buffer << ",srcServerName=" << srcServerName;
		buffer << ",warZoneId=" << warZoneId;
		buffer << ",sid=" << sid;
		buffer << ",taxRate=" << taxRate;
		buffer << ",count=" << count;
		buffer << ",price=" << price;
		buffer << ",time=" << time;
		buffer << ",cTime=" << cTime;
		buffer << ",eTime=" << eTime;
		buffer << ",mailTip=" << mailTip;
		buffer << ",firstOwner=" << firstOwner;
		buffer << ",appraiser=" << appraiser;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	std::string name;
	int srcServerId;
	std::string srcServerName;
	int warZoneId;
	int sid;
	int taxRate;
	int count;
	int price;
	int time;
	int cTime; //寄售时间 
	int eTime; //结束时间 
	int mailTip; //过期邮件提示 
	std::string firstOwner; //第一个拥有者 
	std::string appraiser; //鉴定者 
	std::vector<CrossConsignmentItemProp> props;
};

class MsgAddConsignmentToCrossResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 80 };

	MsgAddConsignmentToCrossResponse() :
		MessageEx(Category, Id)
	{
		pid = 0;
		errcode = 0;
		sid = 0;
		count = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAddConsignmentToCrossResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << errcode;
		s << sid;
		s << count;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> errcode;
		s >> sid;
		s >> count;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",errcode=" << errcode;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
	}

public:
	int pid;
	int errcode;
	int sid;
	int count;
};

class MsgCrossConsignmentAddNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 81 };

	MsgCrossConsignmentAddNotify() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgCrossConsignmentAddNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += item.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		item.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		item.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		item.push(L);
		lua::settable(L, -1, "item");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",item={";
		item.dump(buffer);
		buffer << "}";
	}

public:
	CrossConsignment item;
};

class MsgCrossConsignmentRmvNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 82 };

	MsgCrossConsignmentRmvNotify() :
		MessageEx(Category, Id)
	{
		sellerPid = 0;
		cid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossConsignmentRmvNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sellerPid;
		s << cid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sellerPid;
		s >> cid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "cid", cid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",cid=" << cid;
	}

public:
	int sellerPid;
	int cid;
};

class MsgCrossConsignmentUpdNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 83 };

	MsgCrossConsignmentUpdNotify() :
		MessageEx(Category, Id)
	{
		sellerPid = 0;
		cid = 0;
		newCount = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossConsignmentUpdNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sellerPid;
		s << cid;
		s << newCount;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sellerPid;
		s >> cid;
		s >> newCount;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "newCount", newCount);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",cid=" << cid;
		buffer << ",newCount=" << newCount;
	}

public:
	int sellerPid;
	int cid;
	int newCount;
};

class MsgCheckBuyCrossConsignmentRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 84 };

	MsgCheckBuyCrossConsignmentRequest() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		buyerServerId = 0;
		sellerPid = 0;
		cid = 0;
		count = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCheckBuyCrossConsignmentRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << buyerServerId;
		s << sellerPid;
		s << cid;
		s << count;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> buyerServerId;
		s >> sellerPid;
		s >> cid;
		s >> count;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "buyerServerId", buyerServerId);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "count", count);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",buyerServerId=" << buyerServerId;
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",cid=" << cid;
		buffer << ",count=" << count;
	}

public:
	int buyerPid;
	int buyerServerId;
	int sellerPid;
	int cid;
	int count;
};

class MsgCheckBuyCrossConsignmentResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 85 };

	MsgCheckBuyCrossConsignmentResponse() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		sellerPid = 0;
		cid = 0;
		count = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCheckBuyCrossConsignmentResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << sellerPid;
		s << cid;
		s << count;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> sellerPid;
		s >> cid;
		s >> count;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",cid=" << cid;
		buffer << ",count=" << count;
		buffer << ",errcode=" << errcode;
	}

public:
	int buyerPid;
	int sellerPid;
	int cid;
	int count;
	int errcode;
};

class MsgSendSellerRewardRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 86 };

	MsgSendSellerRewardRequest() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		buyerServerId = 0;
		sellerPid = 0;
		cid = 0;
		count = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendSellerRewardRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 20;
		length += sizeof(short) + buyerName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << buyerServerId;
		s << buyerName;
		s << sellerPid;
		s << cid;
		s << count;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> buyerServerId;
		s >> buyerName;
		s >> sellerPid;
		s >> cid;
		s >> count;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "buyerServerId", buyerServerId);
		lua::settable(L, -1, "buyerName", buyerName);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "count", count);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",buyerServerId=" << buyerServerId;
		buffer << ",buyerName=" << buyerName;
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",cid=" << cid;
		buffer << ",count=" << count;
	}

public:
	int buyerPid;
	int buyerServerId;
	std::string buyerName;
	int sellerPid;
	int cid;
	int count;
};

class MsgSendSellerRewardResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 87 };

	MsgSendSellerRewardResponse() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		sellerPid = 0;
		cid = 0;
		count = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendSellerRewardResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << sellerPid;
		s << cid;
		s << count;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> sellerPid;
		s >> cid;
		s >> count;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",cid=" << cid;
		buffer << ",count=" << count;
		buffer << ",errcode=" << errcode;
	}

public:
	int buyerPid;
	int sellerPid;
	int cid;
	int count;
	int errcode;
};

class MsgRmvCrossConsignmentRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 88 };

	MsgRmvCrossConsignmentRequest() :
		MessageEx(Category, Id)
	{
		sellerServerId = 0;
		sellerPid = 0;
		cid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRmvCrossConsignmentRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sellerServerId;
		s << sellerPid;
		s << cid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sellerServerId;
		s >> sellerPid;
		s >> cid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sellerServerId", sellerServerId);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "cid", cid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sellerServerId=" << sellerServerId;
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",cid=" << cid;
	}

public:
	int sellerServerId;
	int sellerPid;
	int cid;
};

class MsgRmvCrossConsignmentResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 89 };

	MsgRmvCrossConsignmentResponse() :
		MessageEx(Category, Id)
	{
		sellerPid = 0;
		cid = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRmvCrossConsignmentResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sellerPid;
		s << cid;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sellerPid;
		s >> cid;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",cid=" << cid;
		buffer << ",errcode=" << errcode;
	}

public:
	int sellerPid;
	int cid;
	int errcode;
};

class MsgSyncAllCrossConsignmentNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 90 };

	MsgSyncAllCrossConsignmentNotify() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgSyncAllCrossConsignmentNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < list.size(); ++i)
		{
			length += list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int list_vector_size = (int)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int list_vector_size = s.read_int32();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			CrossConsignment val;
			val.unserialize(s, true);
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<CrossConsignment> list;
};

struct crossChatPlayerProp
{
public:
	crossChatPlayerProp()
	{
		type = 0;
		value = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << type;
		s << value;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> type;
		s >> value;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "value", value);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "type=" << type;
		buffer << ",value=" << value;
	}

public:
	int type;
	int value;
};

class MsgSyncCrossChatNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 91 };

	MsgSyncCrossChatNotify() :
		MessageEx(Category, Id)
	{
		chatType = 0;
		pid = 0;
		gender = 0;
		vipLevel = 0;
		level = 0;
		job = 0;
		position = 0;
		redID = 0;
		targetPid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncCrossChatNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 28;
		length += sizeof(short) + playerName.size();
		length += sizeof(short) + chatText.size();
		length += sizeof(short) + guildName.size();
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << chatType;
		s << pid;
		s << playerName;
		s << gender;
		s << vipLevel;
		s << chatText;
		s << level;
		s << job;
		s << position;
		s << redID;
		s << targetPid;
		s << guildName;
		s << serverid;
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> chatType;
		s >> pid;
		s >> playerName;
		s >> gender;
		s >> vipLevel;
		s >> chatText;
		s >> level;
		s >> job;
		s >> position;
		s >> redID;
		s >> targetPid;
		s >> guildName;
		s >> serverid;
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			crossChatPlayerProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "chatType", chatType);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "playerName", playerName);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "vipLevel", vipLevel);
		lua::settable(L, -1, "chatText", chatText);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "position", position);
		lua::settable(L, -1, "redID", redID);
		lua::settable(L, -1, "targetPid", targetPid);
		lua::settable(L, -1, "guildName", guildName);
		lua::settable(L, -1, "serverid", serverid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",chatType=" << chatType;
		buffer << ",pid=" << pid;
		buffer << ",playerName=" << playerName;
		buffer << ",gender=" << gender;
		buffer << ",vipLevel=" << vipLevel;
		buffer << ",chatText=" << chatText;
		buffer << ",level=" << level;
		buffer << ",job=" << job;
		buffer << ",position=" << position;
		buffer << ",redID=" << redID;
		buffer << ",targetPid=" << targetPid;
		buffer << ",guildName=" << guildName;
		buffer << ",serverid=" << serverid;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	short chatType;
	int pid;
	std::string playerName;
	short gender;
	short vipLevel;
	std::string chatText;
	short level;
	short job;
	short position;
	int redID;
	int targetPid;
	std::string guildName;
	int serverid;
	std::vector<crossChatPlayerProp> props;
};

class MsgSendCrossChaToCsRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 92 };

	MsgSendCrossChaToCsRequest() :
		MessageEx(Category, Id)
	{
		chatType = 0;
		pid = 0;
		gender = 0;
		vipLevel = 0;
		level = 0;
		job = 0;
		position = 0;
		redID = 0;
		targetPid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendCrossChaToCsRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 28;
		length += sizeof(short) + playerName.size();
		length += sizeof(short) + chatText.size();
		length += sizeof(short) + guildName.size();
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << chatType;
		s << pid;
		s << playerName;
		s << gender;
		s << vipLevel;
		s << chatText;
		s << level;
		s << job;
		s << position;
		s << redID;
		s << targetPid;
		s << guildName;
		s << serverid;
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> chatType;
		s >> pid;
		s >> playerName;
		s >> gender;
		s >> vipLevel;
		s >> chatText;
		s >> level;
		s >> job;
		s >> position;
		s >> redID;
		s >> targetPid;
		s >> guildName;
		s >> serverid;
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			crossChatPlayerProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "chatType", chatType);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "playerName", playerName);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "vipLevel", vipLevel);
		lua::settable(L, -1, "chatText", chatText);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "position", position);
		lua::settable(L, -1, "redID", redID);
		lua::settable(L, -1, "targetPid", targetPid);
		lua::settable(L, -1, "guildName", guildName);
		lua::settable(L, -1, "serverid", serverid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",chatType=" << chatType;
		buffer << ",pid=" << pid;
		buffer << ",playerName=" << playerName;
		buffer << ",gender=" << gender;
		buffer << ",vipLevel=" << vipLevel;
		buffer << ",chatText=" << chatText;
		buffer << ",level=" << level;
		buffer << ",job=" << job;
		buffer << ",position=" << position;
		buffer << ",redID=" << redID;
		buffer << ",targetPid=" << targetPid;
		buffer << ",guildName=" << guildName;
		buffer << ",serverid=" << serverid;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	short chatType;
	int pid;
	std::string playerName;
	short gender;
	short vipLevel;
	std::string chatText;
	short level;
	short job;
	short position;
	int redID;
	int targetPid;
	std::string guildName;
	int serverid;
	std::vector<crossChatPlayerProp> props;
};

class MsgGetPlayerCrossPropRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 93 };

	MsgGetPlayerCrossPropRequest() :
		MessageEx(Category, Id)
	{
		pid = 0;
		ctype = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetPlayerCrossPropRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << ctype;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> ctype;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "ctype", ctype);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",ctype=" << ctype;
	}

public:
	int pid;
	int ctype;
};

class MsgPlayerCSActionNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 94 };

	MsgPlayerCSActionNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		crossActionType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgPlayerCSActionNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < intParams.size(); ++i)
		{
			length += intParams[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < strParams.size(); ++i)
		{
			length += strParams[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << crossActionType;
		int intParams_vector_size = (int)intParams.size();
		s << intParams_vector_size;
		if (intParams_vector_size > 0)
		{
			for (auto it = intParams.begin(); it != intParams.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int strParams_vector_size = (int)strParams.size();
		s << strParams_vector_size;
		if (strParams_vector_size > 0)
		{
			for (auto it = strParams.begin(); it != strParams.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> crossActionType;
		int intParams_vector_size = s.read_int32();
		intParams.clear();
		while (intParams_vector_size > 0)
		{
			intParams_vector_size--;
			CrossIntProp val;
			val.unserialize(s, true);
			intParams.push_back(val);
		}
		int strParams_vector_size = s.read_int32();
		strParams.clear();
		while (strParams_vector_size > 0)
		{
			strParams_vector_size--;
			CrossStrProp val;
			val.unserialize(s, true);
			strParams.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "crossActionType", crossActionType);
		lua::newtable(lua::L);
		for (size_t i = 0; i < intParams.size(); ++i)
		{
			intParams[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "intParams");
		lua::newtable(lua::L);
		for (size_t i = 0; i < strParams.size(); ++i)
		{
			strParams[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "strParams");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",crossActionType=" << crossActionType;
		buffer << ",intParams=[";
		for (size_t i = 0; i < intParams.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			intParams[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",strParams=[";
		for (size_t i = 0; i < strParams.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			strParams[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int crossActionType;
	std::vector<CrossIntProp> intParams; //整型参数 
	std::vector<CrossStrProp> strParams; //字符参数 
};

class MsgAddGeneInGameServerRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 95 };

	MsgAddGeneInGameServerRequest() :
		MessageEx(Category, Id)
	{
		pid = 0;
		geneId = 0;
		geneType = 0;
		geneGroup = 0;
		geneDuration = 0;
		geneInherit = 0;
		geneDatax = 0;
		geneDatay = 0;
		geneDataz = 0;
		geneDatau = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAddGeneInGameServerRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 38;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << geneId;
		s << geneType;
		s << geneGroup;
		s << geneDuration;
		s << geneInherit;
		s << geneDatax;
		s << geneDatay;
		s << geneDataz;
		s << geneDatau;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> geneId;
		s >> geneType;
		s >> geneGroup;
		s >> geneDuration;
		s >> geneInherit;
		s >> geneDatax;
		s >> geneDatay;
		s >> geneDataz;
		s >> geneDatau;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "geneId", geneId);
		lua::settable(L, -1, "geneType", geneType);
		lua::settable(L, -1, "geneGroup", geneGroup);
		lua::settable(L, -1, "geneDuration", geneDuration);
		lua::settable(L, -1, "geneInherit", geneInherit);
		lua::settable(L, -1, "geneDatax", geneDatax);
		lua::settable(L, -1, "geneDatay", geneDatay);
		lua::settable(L, -1, "geneDataz", geneDataz);
		lua::settable(L, -1, "geneDatau", geneDatau);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",geneId=" << geneId;
		buffer << ",geneType=" << geneType;
		buffer << ",geneGroup=" << geneGroup;
		buffer << ",geneDuration=" << geneDuration;
		buffer << ",geneInherit=" << geneInherit;
		buffer << ",geneDatax=" << geneDatax;
		buffer << ",geneDatay=" << geneDatay;
		buffer << ",geneDataz=" << geneDataz;
		buffer << ",geneDatau=" << geneDatau;
	}

public:
	int pid;
	int geneId;
	int geneType;
	int geneGroup;
	int geneDuration;
	short geneInherit;
	int geneDatax;
	int geneDatay;
	int geneDataz;
	int geneDatau;
};

class MsgRmvGeneFromGameServerRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 96 };

	MsgRmvGeneFromGameServerRequest() :
		MessageEx(Category, Id)
	{
		pid = 0;
		geneId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRmvGeneFromGameServerRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << geneId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> geneId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "geneId", geneId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",geneId=" << geneId;
	}

public:
	int pid;
	int geneId;
};

class MsgCheckPlayerAllCrossPropRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 97 };

	MsgCheckPlayerAllCrossPropRequest() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCheckPlayerAllCrossPropRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += commonInfo.getLength(true);
		length += sizeof(int);
		for (size_t i = 0; i < events.size(); ++i)
		{
			length += events[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		commonInfo.serialize(s, true);
		int events_vector_size = (int)events.size();
		s << events_vector_size;
		if (events_vector_size > 0)
		{
			for (auto it = events.begin(); it != events.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		commonInfo.unserialize(s, true);
		int events_vector_size = s.read_int32();
		events.clear();
		while (events_vector_size > 0)
		{
			events_vector_size--;
			CrossEventData val;
			val.unserialize(s, true);
			events.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		commonInfo.push(L);
		lua::settable(L, -1, "commonInfo");
		lua::newtable(lua::L);
		for (size_t i = 0; i < events.size(); ++i)
		{
			events[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "events");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",commonInfo={";
		commonInfo.dump(buffer);
		buffer << "}";
		buffer << ",events=[";
		for (size_t i = 0; i < events.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			events[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	CrossCommonStruct commonInfo; //玩家数据 
	std::vector<CrossEventData> events;
};

class MsgCrossGetPlayerSerializeInfoG2C : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 103 };

	MsgCrossGetPlayerSerializeInfoG2C() :
		MessageEx(Category, Id)
	{
		sourceWorldId = 0;
		pid = 0;
		enemy_pid = 0;
		action = 0;
		scene_static_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossGetPlayerSerializeInfoG2C";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 20;
		length += sizeof(short) + json.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sourceWorldId;
		s << pid;
		s << enemy_pid;
		s << action;
		s << scene_static_id;
		s << json;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sourceWorldId;
		s >> pid;
		s >> enemy_pid;
		s >> action;
		s >> scene_static_id;
		s >> json;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sourceWorldId", sourceWorldId);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "enemy_pid", enemy_pid);
		lua::settable(L, -1, "action", action);
		lua::settable(L, -1, "scene_static_id", scene_static_id);
		lua::settable(L, -1, "json", json);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sourceWorldId=" << sourceWorldId;
		buffer << ",pid=" << pid;
		buffer << ",enemy_pid=" << enemy_pid;
		buffer << ",action=" << action;
		buffer << ",scene_static_id=" << scene_static_id;
		buffer << ",json=" << json;
	}

public:
	int sourceWorldId;
	int pid;
	int enemy_pid;
	int action;
	int scene_static_id;
	std::string json;
};

class MsgCrossGetPlayerSerializeInfoC2G : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 104 };

	MsgCrossGetPlayerSerializeInfoC2G() :
		MessageEx(Category, Id)
	{
		pid = 0;
		enemy_pid = 0;
		action = 0;
		scene_static_id = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossGetPlayerSerializeInfoC2G";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 20;
		length += sizeof(short) + json.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << enemy_pid;
		s << action;
		s << scene_static_id;
		s << errcode;
		s << json;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> enemy_pid;
		s >> action;
		s >> scene_static_id;
		s >> errcode;
		s >> json;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "enemy_pid", enemy_pid);
		lua::settable(L, -1, "action", action);
		lua::settable(L, -1, "scene_static_id", scene_static_id);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "json", json);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",enemy_pid=" << enemy_pid;
		buffer << ",action=" << action;
		buffer << ",scene_static_id=" << scene_static_id;
		buffer << ",errcode=" << errcode;
		buffer << ",json=" << json;
	}

public:
	int pid;
	int enemy_pid;
	int action;
	int scene_static_id;
	int errcode;
	std::string json;
};

struct UpdateSerializeUnit
{
public:
	UpdateSerializeUnit()
	{
		pid = 0;
		force = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 8;
		length += sizeof(short) + name.size();
		length += sizeof(short) + json.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << force;
		s << name;
		s << json;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> force;
		s >> name;
		s >> json;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "force", force);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "json", json);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",force=" << force;
		buffer << ",name=" << name;
		buffer << ",json=" << json;
	}

public:
	int pid;
	int force;
	std::string name;
	std::string json;
};

struct CrossPurchase
{
public:
	CrossPurchase()
	{
		buyerPid = 0;
		buyerServerId = 0;
		buyerWarZoneId = 0;
		purchaseId = 0;
		sid = 0;
		count = 0;
		taxRate = 0;
		price = 0;
		ctime = 0;
		etime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 40;
		length += sizeof(short) + buyerName.size();
		length += sizeof(short) + buyerServerName.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << buyerPid;
		s << buyerName;
		s << buyerServerId;
		s << buyerServerName;
		s << buyerWarZoneId;
		s << purchaseId;
		s << sid;
		s << count;
		s << taxRate;
		s << price;
		s << ctime;
		s << etime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> buyerPid;
		s >> buyerName;
		s >> buyerServerId;
		s >> buyerServerName;
		s >> buyerWarZoneId;
		s >> purchaseId;
		s >> sid;
		s >> count;
		s >> taxRate;
		s >> price;
		s >> ctime;
		s >> etime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "buyerName", buyerName);
		lua::settable(L, -1, "buyerServerId", buyerServerId);
		lua::settable(L, -1, "buyerServerName", buyerServerName);
		lua::settable(L, -1, "buyerWarZoneId", buyerWarZoneId);
		lua::settable(L, -1, "purchaseId", purchaseId);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "taxRate", taxRate);
		lua::settable(L, -1, "price", price);
		lua::settable(L, -1, "ctime", ctime);
		lua::settable(L, -1, "etime", etime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "buyerPid=" << buyerPid;
		buffer << ",buyerName=" << buyerName;
		buffer << ",buyerServerId=" << buyerServerId;
		buffer << ",buyerServerName=" << buyerServerName;
		buffer << ",buyerWarZoneId=" << buyerWarZoneId;
		buffer << ",purchaseId=" << purchaseId;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",taxRate=" << taxRate;
		buffer << ",price=" << price;
		buffer << ",ctime=" << ctime;
		buffer << ",etime=" << etime;
	}

public:
	int buyerPid; //求购者pid 
	std::string buyerName; //求购者姓名 
	int buyerServerId; //求购者服务器id 
	std::string buyerServerName; //求购者服务器名称 
	int buyerWarZoneId; //求购者战区id 
	int purchaseId; //求购id 
	int sid; //求购物品ID 
	int count; //求购物品数量 
	int taxRate; //税率 
	int price; //求购价格 
	int ctime; //求购时间 
	int etime; //求购过期时间 
};

class MsgAddPurchaseToCrossRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 115 };

	MsgAddPurchaseToCrossRequest() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		buyerServerId = 0;
		buyerWarZoneId = 0;
		sid = 0;
		count = 0;
		price = 0;
		time = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAddPurchaseToCrossRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 28;
		length += sizeof(short) + buyerName.size();
		length += sizeof(short) + buyerServerName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << buyerName;
		s << buyerServerId;
		s << buyerServerName;
		s << buyerWarZoneId;
		s << sid;
		s << count;
		s << price;
		s << time;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> buyerName;
		s >> buyerServerId;
		s >> buyerServerName;
		s >> buyerWarZoneId;
		s >> sid;
		s >> count;
		s >> price;
		s >> time;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "buyerName", buyerName);
		lua::settable(L, -1, "buyerServerId", buyerServerId);
		lua::settable(L, -1, "buyerServerName", buyerServerName);
		lua::settable(L, -1, "buyerWarZoneId", buyerWarZoneId);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "price", price);
		lua::settable(L, -1, "time", time);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",buyerName=" << buyerName;
		buffer << ",buyerServerId=" << buyerServerId;
		buffer << ",buyerServerName=" << buyerServerName;
		buffer << ",buyerWarZoneId=" << buyerWarZoneId;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",price=" << price;
		buffer << ",time=" << time;
	}

public:
	int buyerPid;
	std::string buyerName;
	int buyerServerId;
	std::string buyerServerName;
	int buyerWarZoneId;
	int sid;
	int count;
	int price;
	int time;
};

class MsgAddPurchaseToCrossResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 116 };

	MsgAddPurchaseToCrossResponse() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		sid = 0;
		count = 0;
		price = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAddPurchaseToCrossResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << sid;
		s << count;
		s << price;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> sid;
		s >> count;
		s >> price;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "price", price);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",sid=" << sid;
		buffer << ",count=" << count;
		buffer << ",price=" << price;
		buffer << ",errcode=" << errcode;
	}

public:
	int buyerPid;
	int sid;
	int count;
	int price;
	int errcode;
};

class MsgCrossPurchaseAddNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 117 };

	MsgCrossPurchaseAddNotify() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgCrossPurchaseAddNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += crossPurchase.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		crossPurchase.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		crossPurchase.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		crossPurchase.push(L);
		lua::settable(L, -1, "crossPurchase");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",crossPurchase={";
		crossPurchase.dump(buffer);
		buffer << "}";
	}

public:
	CrossPurchase crossPurchase;
};

class MsgCrossPurchaseRmvNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 118 };

	MsgCrossPurchaseRmvNotify() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		purchaseId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossPurchaseRmvNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << purchaseId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> purchaseId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "purchaseId", purchaseId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",purchaseId=" << purchaseId;
	}

public:
	int buyerPid;
	int purchaseId;
};

class MsgCrossPurchaseUpdNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 119 };

	MsgCrossPurchaseUpdNotify() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		purchaseId = 0;
		newCount = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossPurchaseUpdNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << purchaseId;
		s << newCount;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> purchaseId;
		s >> newCount;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "purchaseId", purchaseId);
		lua::settable(L, -1, "newCount", newCount);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",purchaseId=" << purchaseId;
		buffer << ",newCount=" << newCount;
	}

public:
	int buyerPid;
	int purchaseId;
	int newCount;
};

class MsgTrySellCrossPurchaseRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 120 };

	MsgTrySellCrossPurchaseRequest() :
		MessageEx(Category, Id)
	{
		sellerPid = 0;
		sellerServerId = 0;
		buyerPid = 0;
		purchaseId = 0;
		sellCounts = 0;
	}

	virtual const char *getName() const
	{
		return "MsgTrySellCrossPurchaseRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sellerPid;
		s << sellerServerId;
		s << buyerPid;
		s << purchaseId;
		s << sellCounts;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sellerPid;
		s >> sellerServerId;
		s >> buyerPid;
		s >> purchaseId;
		s >> sellCounts;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "sellerServerId", sellerServerId);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "purchaseId", purchaseId);
		lua::settable(L, -1, "sellCounts", sellCounts);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",sellerServerId=" << sellerServerId;
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",purchaseId=" << purchaseId;
		buffer << ",sellCounts=" << sellCounts;
	}

public:
	int sellerPid;
	int sellerServerId;
	int buyerPid;
	int purchaseId;
	int sellCounts;
};

class MsgTrySellCrossPurchaseResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 121 };

	MsgTrySellCrossPurchaseResponse() :
		MessageEx(Category, Id)
	{
		sellerPid = 0;
		buyerPid = 0;
		purchaseId = 0;
		sellCounts = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgTrySellCrossPurchaseResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sellerPid;
		s << buyerPid;
		s << purchaseId;
		s << sellCounts;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sellerPid;
		s >> buyerPid;
		s >> purchaseId;
		s >> sellCounts;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "purchaseId", purchaseId);
		lua::settable(L, -1, "sellCounts", sellCounts);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",purchaseId=" << purchaseId;
		buffer << ",sellCounts=" << sellCounts;
		buffer << ",errcode=" << errcode;
	}

public:
	int sellerPid;
	int buyerPid;
	int purchaseId;
	int sellCounts;
	int errcode;
};

class MsgSendBuyerPurchaseItemRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 122 };

	MsgSendBuyerPurchaseItemRequest() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		purchaseId = 0;
		sellerPid = 0;
		sellerServerId = 0;
		sellCounts = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendBuyerPurchaseItemRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 20;
		length += sizeof(short) + sellerName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << purchaseId;
		s << sellerPid;
		s << sellerName;
		s << sellerServerId;
		s << sellCounts;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> purchaseId;
		s >> sellerPid;
		s >> sellerName;
		s >> sellerServerId;
		s >> sellCounts;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "purchaseId", purchaseId);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "sellerName", sellerName);
		lua::settable(L, -1, "sellerServerId", sellerServerId);
		lua::settable(L, -1, "sellCounts", sellCounts);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",purchaseId=" << purchaseId;
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",sellerName=" << sellerName;
		buffer << ",sellerServerId=" << sellerServerId;
		buffer << ",sellCounts=" << sellCounts;
	}

public:
	int buyerPid;
	int purchaseId;
	int sellerPid;
	std::string sellerName;
	int sellerServerId;
	int sellCounts;
};

class MsgSendBuyerPurchaseItemResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 123 };

	MsgSendBuyerPurchaseItemResponse() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		sellerPid = 0;
		purchaseId = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendBuyerPurchaseItemResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << sellerPid;
		s << purchaseId;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> sellerPid;
		s >> purchaseId;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "sellerPid", sellerPid);
		lua::settable(L, -1, "purchaseId", purchaseId);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",sellerPid=" << sellerPid;
		buffer << ",purchaseId=" << purchaseId;
		buffer << ",errcode=" << errcode;
	}

public:
	int buyerPid;
	int sellerPid;
	int purchaseId;
	int errcode;
};

class MsgRmvCrossPurchaseRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 124 };

	MsgRmvCrossPurchaseRequest() :
		MessageEx(Category, Id)
	{
		buyerServerId = 0;
		buyerPid = 0;
		purchaseId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRmvCrossPurchaseRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerServerId;
		s << buyerPid;
		s << purchaseId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerServerId;
		s >> buyerPid;
		s >> purchaseId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerServerId", buyerServerId);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "purchaseId", purchaseId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerServerId=" << buyerServerId;
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",purchaseId=" << purchaseId;
	}

public:
	int buyerServerId;
	int buyerPid;
	int purchaseId;
};

class MsgRmvCrossPurchaseResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 125 };

	MsgRmvCrossPurchaseResponse() :
		MessageEx(Category, Id)
	{
		buyerPid = 0;
		purchaseId = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRmvCrossPurchaseResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << buyerPid;
		s << purchaseId;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> buyerPid;
		s >> purchaseId;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "buyerPid", buyerPid);
		lua::settable(L, -1, "purchaseId", purchaseId);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",buyerPid=" << buyerPid;
		buffer << ",purchaseId=" << purchaseId;
		buffer << ",errcode=" << errcode;
	}

public:
	int buyerPid;
	int purchaseId;
	int errcode;
};

class MsgSyncAllCrossPurchaseNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 126 };

	MsgSyncAllCrossPurchaseNotify() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgSyncAllCrossPurchaseNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < list.size(); ++i)
		{
			length += list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int list_vector_size = (int)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int list_vector_size = s.read_int32();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			CrossPurchase val;
			val.unserialize(s, true);
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<CrossPurchase> list;
};

class MsgPlayerChangeNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 128 };

	MsgPlayerChangeNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		lvl = 0;
	}

	virtual const char *getName() const
	{
		return "MsgPlayerChangeNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << lvl;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> lvl;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "lvl", lvl);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",lvl=" << lvl;
	}

public:
	int pid;
	int lvl;
};

class MsgCrossPlayerStateG2C : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 130 };

	MsgCrossPlayerStateG2C() :
		MessageEx(Category, Id)
	{
		pid = 0;
		state = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossPlayerStateG2C";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << state;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> state;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "state", state);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",state=" << state;
	}

public:
	int pid;
	int state;
};

struct CrossMap
{
public:
	CrossMap()
	{
		index = 0;
		map_id = 0;
	}

	size_t getLength(bool ex) const
	{
		return 6;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << index;
		s << map_id;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> index;
		s >> map_id;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "index", index);
		lua::settable(L, -1, "map_id", map_id);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "index=" << index;
		buffer << ",map_id=" << map_id;
	}

public:
	short index;
	int map_id;
};

class MsgGetBossCntInCrossMapRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 131 };

	MsgGetBossCntInCrossMapRequest() :
		MessageEx(Category, Id)
	{
		source_world_id = 0;
		warzone_line_id = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetBossCntInCrossMapRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 12;
		length += sizeof(int);
		for (size_t i = 0; i < cross_maps.size(); ++i)
		{
			length += cross_maps[i].getLength(true);
		}
		length += sizeof(short) + targetName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << source_world_id;
		s << warzone_line_id;
		s << pid;
		int cross_maps_vector_size = (int)cross_maps.size();
		s << cross_maps_vector_size;
		if (cross_maps_vector_size > 0)
		{
			for (auto it = cross_maps.begin(); it != cross_maps.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		s << targetName;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> source_world_id;
		s >> warzone_line_id;
		s >> pid;
		int cross_maps_vector_size = s.read_int32();
		cross_maps.clear();
		while (cross_maps_vector_size > 0)
		{
			cross_maps_vector_size--;
			CrossMap val;
			val.unserialize(s, true);
			cross_maps.push_back(val);
		}
		s >> targetName;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "source_world_id", source_world_id);
		lua::settable(L, -1, "warzone_line_id", warzone_line_id);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < cross_maps.size(); ++i)
		{
			cross_maps[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "cross_maps");
		lua::settable(L, -1, "targetName", targetName);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",source_world_id=" << source_world_id;
		buffer << ",warzone_line_id=" << warzone_line_id;
		buffer << ",pid=" << pid;
		buffer << ",cross_maps=[";
		for (size_t i = 0; i < cross_maps.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			cross_maps[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",targetName=" << targetName;
	}

public:
	int source_world_id;
	int warzone_line_id;
	int pid;
	std::vector<CrossMap> cross_maps;
	std::string targetName;
};

struct CrossMapBossInfo
{
public:
	CrossMapBossInfo()
	{
		mid = 0;
		count = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << mid;
		s << count;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> mid;
		s >> count;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "mid", mid);
		lua::settable(L, -1, "count", count);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "mid=" << mid;
		buffer << ",count=" << count;
	}

public:
	int mid;
	int count;
};

struct CrossMapBossCount
{
public:
	CrossMapBossCount()
	{
		index = 0;
		count = 0;
		sceneId = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 10;
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < boss_list.size(); ++i)
		{
			length += boss_list[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << index;
		s << count;
		s << sceneId;
		int boss_list_vector_size = ex ? (int)boss_list.size() : (short)boss_list.size();
		if (ex)
		{
			s << boss_list_vector_size;
		}
		else
		{
			s << (short)boss_list_vector_size;
		}
		if (boss_list_vector_size > 0)
		{
			for (auto it = boss_list.begin(); it != boss_list.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> index;
		s >> count;
		s >> sceneId;
		int boss_list_vector_size = ex ? s.read_int32() : s.read_int16();
		boss_list.clear();
		while (boss_list_vector_size > 0)
		{
			boss_list_vector_size--;
			CrossMapBossInfo val;
			val.unserialize(s, ex);
			boss_list.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "index", index);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "sceneId", sceneId);
		lua::newtable(lua::L);
		for (size_t i = 0; i < boss_list.size(); ++i)
		{
			boss_list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "boss_list");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "index=" << index;
		buffer << ",count=" << count;
		buffer << ",sceneId=" << sceneId;
		buffer << ",boss_list=[";
		for (size_t i = 0; i < boss_list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			boss_list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	short index;
	int count;
	int sceneId;
	std::vector<CrossMapBossInfo> boss_list;
};

class MsgGetBossCntInCrossMapNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 132 };

	MsgGetBossCntInCrossMapNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetBossCntInCrossMapNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < boss_cnts.size(); ++i)
		{
			length += boss_cnts[i].getLength(true);
		}
		length += sizeof(short) + targetName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		int boss_cnts_vector_size = (int)boss_cnts.size();
		s << boss_cnts_vector_size;
		if (boss_cnts_vector_size > 0)
		{
			for (auto it = boss_cnts.begin(); it != boss_cnts.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		s << targetName;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		int boss_cnts_vector_size = s.read_int32();
		boss_cnts.clear();
		while (boss_cnts_vector_size > 0)
		{
			boss_cnts_vector_size--;
			CrossMapBossCount val;
			val.unserialize(s, true);
			boss_cnts.push_back(val);
		}
		s >> targetName;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < boss_cnts.size(); ++i)
		{
			boss_cnts[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "boss_cnts");
		lua::settable(L, -1, "targetName", targetName);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",boss_cnts=[";
		for (size_t i = 0; i < boss_cnts.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			boss_cnts[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",targetName=" << targetName;
	}

public:
	int pid;
	std::vector<CrossMapBossCount> boss_cnts;
	std::string targetName;
};

class MsgServerDaysNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 133 };

	MsgServerDaysNotify() :
		MessageEx(Category, Id)
	{
		server_id = 0;
		server_days = 0;
	}

	virtual const char *getName() const
	{
		return "MsgServerDaysNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << server_id;
		s << server_days;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> server_id;
		s >> server_days;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "server_id", server_id);
		lua::settable(L, -1, "server_days", server_days);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",server_id=" << server_id;
		buffer << ",server_days=" << server_days;
	}

public:
	int server_id;
	int server_days;
};

struct SkillExpAdd
{
public:
	SkillExpAdd()
	{
		sid = 0;
		addexp = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << sid;
		s << addexp;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> sid;
		s >> addexp;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "addexp", addexp);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "sid=" << sid;
		buffer << ",addexp=" << addexp;
	}

public:
	int sid;
	int addexp;
};

class MsgSyncSkillExpAddToGameServer : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 134 };

	MsgSyncSkillExpAddToGameServer() :
		MessageEx(Category, Id)
	{
		pid = 0;
		opcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncSkillExpAddToGameServer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < skillList.size(); ++i)
		{
			length += skillList[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << opcode;
		int skillList_vector_size = (int)skillList.size();
		s << skillList_vector_size;
		if (skillList_vector_size > 0)
		{
			for (auto it = skillList.begin(); it != skillList.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> opcode;
		int skillList_vector_size = s.read_int32();
		skillList.clear();
		while (skillList_vector_size > 0)
		{
			skillList_vector_size--;
			SkillExpAdd val;
			val.unserialize(s, true);
			skillList.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "opcode", opcode);
		lua::newtable(lua::L);
		for (size_t i = 0; i < skillList.size(); ++i)
		{
			skillList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "skillList");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",opcode=" << opcode;
		buffer << ",skillList=[";
		for (size_t i = 0; i < skillList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			skillList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int opcode;
	std::vector<SkillExpAdd> skillList;
};

class MsgEnterGameGuajiRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 135 };

	MsgEnterGameGuajiRequest() :
		MessageEx(Category, Id)
	{
		sourceServerId = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgEnterGameGuajiRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << sourceServerId;
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> sourceServerId;
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sourceServerId", sourceServerId);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",sourceServerId=" << sourceServerId;
		buffer << ",pid=" << pid;
	}

public:
	int sourceServerId;
	int pid;
};

class MsgNotifyGameServerExpAdd : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 136 };

	MsgNotifyGameServerExpAdd() :
		MessageEx(Category, Id)
	{
		pid = 0;
		count = 0;
		opcode = 0;
		opdata = 0;
	}

	virtual const char *getName() const
	{
		return "MsgNotifyGameServerExpAdd";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << count;
		s << opcode;
		s << opdata;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> count;
		s >> opcode;
		s >> opdata;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "count", count);
		lua::settable(L, -1, "opcode", opcode);
		lua::settable(L, -1, "opdata", opdata);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",count=" << count;
		buffer << ",opcode=" << opcode;
		buffer << ",opdata=" << opdata;
	}

public:
	int pid;
	int count;
	int opcode;
	int opdata;
};

class MsgNotifyInitDreamNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 137 };

	MsgNotifyInitDreamNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgNotifyInitDreamNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
	}

public:
	int pid;
};

class MsgRemoveChatCrossRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 138 };

	MsgRemoveChatCrossRequest() :
		MessageEx(Category, Id)
	{
		src_server_id = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRemoveChatCrossRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << src_server_id;
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> src_server_id;
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "src_server_id", src_server_id);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",src_server_id=" << src_server_id;
		buffer << ",pid=" << pid;
	}

public:
	int src_server_id;
	int pid;
};

class MsgRemoveChatCrossNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 139 };

	MsgRemoveChatCrossNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRemoveChatCrossNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
	}

public:
	int pid;
};

class MsgSetCrossFlagNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 140 };

	MsgSetCrossFlagNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		flag = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSetCrossFlagNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << flag;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> flag;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "flag", flag);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",flag=" << flag;
	}

public:
	int pid;
	int flag;
};

class MsgSendSWZDZAwardNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 141 };

	MsgSendSWZDZAwardNotify() :
		MessageEx(Category, Id)
	{
		GuildID = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendSWZDZAwardNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << GuildID;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> GuildID;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "GuildID", GuildID);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",GuildID=" << GuildID;
	}

public:
	int GuildID;
};

class MsgSyncPlayerDeletedNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 152 };

	MsgSyncPlayerDeletedNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncPlayerDeletedNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << serverid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> serverid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverid", serverid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",serverid=" << serverid;
	}

public:
	int pid;
	int serverid;
};

class MsgSyncGuildDeletedNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 153 };

	MsgSyncGuildDeletedNotify() :
		MessageEx(Category, Id)
	{
		guildid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncGuildDeletedNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << guildid;
		s << serverid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> guildid;
		s >> serverid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "guildid", guildid);
		lua::settable(L, -1, "serverid", serverid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",guildid=" << guildid;
		buffer << ",serverid=" << serverid;
	}

public:
	int guildid;
	int serverid;
};

class MsgSyncPlayerRenameNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 154 };

	MsgSyncPlayerRenameNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncPlayerRenameNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(short) + newName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << serverid;
		s << newName;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> serverid;
		s >> newName;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverid", serverid);
		lua::settable(L, -1, "newName", newName);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",serverid=" << serverid;
		buffer << ",newName=" << newName;
	}

public:
	int pid;
	int serverid;
	std::string newName;
};

class MsgSyncGuildRenameNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 155 };

	MsgSyncGuildRenameNotify() :
		MessageEx(Category, Id)
	{
		guildid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncGuildRenameNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(short) + newName.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << guildid;
		s << serverid;
		s << newName;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> guildid;
		s >> serverid;
		s >> newName;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "guildid", guildid);
		lua::settable(L, -1, "serverid", serverid);
		lua::settable(L, -1, "newName", newName);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",guildid=" << guildid;
		buffer << ",serverid=" << serverid;
		buffer << ",newName=" << newName;
	}

public:
	int guildid;
	int serverid;
	std::string newName;
};

class MsgSendSWYAwardNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 164 };

	MsgSendSWYAwardNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		serverid = 0;
		rank = 0;
		rankType = 0;
		gid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendSWYAwardNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << serverid;
		s << rank;
		s << rankType;
		s << gid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> serverid;
		s >> rank;
		s >> rankType;
		s >> gid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverid", serverid);
		lua::settable(L, -1, "rank", rank);
		lua::settable(L, -1, "rankType", rankType);
		lua::settable(L, -1, "gid", gid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",serverid=" << serverid;
		buffer << ",rank=" << rank;
		buffer << ",rankType=" << rankType;
		buffer << ",gid=" << gid;
	}

public:
	int pid;
	int serverid;
	int rank;
	int rankType;
	int gid;
};

class MsgSendGuildBattleAwardNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 165 };

	MsgSendGuildBattleAwardNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		serverid = 0;
		rank = 0;
		rankType = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendGuildBattleAwardNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << serverid;
		s << rank;
		s << rankType;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> serverid;
		s >> rank;
		s >> rankType;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverid", serverid);
		lua::settable(L, -1, "rank", rank);
		lua::settable(L, -1, "rankType", rankType);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",serverid=" << serverid;
		buffer << ",rank=" << rank;
		buffer << ",rankType=" << rankType;
	}

public:
	int pid;
	int serverid;
	int rank;
	int rankType;
};

class MsgGSBroadcastAllGSRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 168 };

	MsgGSBroadcastAllGSRequest() :
		MessageEx(Category, Id)
	{
		showflag = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGSBroadcastAllGSRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(short) + basestring.size();
		length += sizeof(short) + TouchID.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << basestring;
		s << showflag;
		s << TouchID;
		s << serverid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> basestring;
		s >> showflag;
		s >> TouchID;
		s >> serverid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "basestring", basestring);
		lua::settable(L, -1, "showflag", showflag);
		lua::settable(L, -1, "TouchID", TouchID);
		lua::settable(L, -1, "serverid", serverid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",basestring=" << basestring;
		buffer << ",showflag=" << showflag;
		buffer << ",TouchID=" << TouchID;
		buffer << ",serverid=" << serverid;
	}

public:
	std::string basestring;
	int showflag;
	std::string TouchID;
	int serverid;
};

class MsgGSBroadcastAllGSResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 169 };

	MsgGSBroadcastAllGSResponse() :
		MessageEx(Category, Id)
	{
		showflag = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGSBroadcastAllGSResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(short) + basestring.size();
		length += sizeof(short) + TouchID.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << basestring;
		s << showflag;
		s << TouchID;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> basestring;
		s >> showflag;
		s >> TouchID;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "basestring", basestring);
		lua::settable(L, -1, "showflag", showflag);
		lua::settable(L, -1, "TouchID", TouchID);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",basestring=" << basestring;
		buffer << ",showflag=" << showflag;
		buffer << ",TouchID=" << TouchID;
	}

public:
	std::string basestring;
	int showflag;
	std::string TouchID;
};

class MsgSyncGuildMasterNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 170 };

	MsgSyncGuildMasterNotify() :
		MessageEx(Category, Id)
	{
		guildid = 0;
		serverid = 0;
		masterpid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncGuildMasterNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << guildid;
		s << serverid;
		s << masterpid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> guildid;
		s >> serverid;
		s >> masterpid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "guildid", guildid);
		lua::settable(L, -1, "serverid", serverid);
		lua::settable(L, -1, "masterpid", masterpid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",guildid=" << guildid;
		buffer << ",serverid=" << serverid;
		buffer << ",masterpid=" << masterpid;
	}

public:
	int guildid;
	int serverid;
	int masterpid;
};

class MsgSyncPlayerJobNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 175 };

	MsgSyncPlayerJobNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		serverid = 0;
		job = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncPlayerJobNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << serverid;
		s << job;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> serverid;
		s >> job;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverid", serverid);
		lua::settable(L, -1, "job", job);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",serverid=" << serverid;
		buffer << ",job=" << job;
	}

public:
	int pid;
	int serverid;
	int job;
};

class MsgSyncCrossActivityNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 176 };

	MsgSyncCrossActivityNotify() :
		MessageEx(Category, Id)
	{
		type = 0;
		reset = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncCrossActivityNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << type;
		s << reset;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> type;
		s >> reset;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "reset", reset);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",type=" << type;
		buffer << ",reset=" << reset;
	}

public:
	int type;
	int reset;
};

class MsgSyncWordDataToGSNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 177 };

	MsgSyncWordDataToGSNotify() :
		MessageEx(Category, Id)
	{
		serverId = 0;
		wprop = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSyncWordDataToGSNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 20;
		length += sizeof(short) + datas.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << serverId;
		s << wprop;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> serverId;
		s >> wprop;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "wprop", wprop);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",serverId=" << serverId;
		buffer << ",wprop=" << wprop;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
	}

public:
	int serverId;
	int wprop;
	int datax;
	int datay;
	int dataz;
	std::string datas;
};

class MsgChangeCsWordDataRequestFromGs : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 178 };

	MsgChangeCsWordDataRequestFromGs() :
		MessageEx(Category, Id)
	{
		wprop = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgChangeCsWordDataRequestFromGs";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 16;
		length += sizeof(short) + datas.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << wprop;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> wprop;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "wprop", wprop);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",wprop=" << wprop;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
	}

public:
	int wprop;
	int datax;
	int datay;
	int dataz;
	std::string datas;
};

class MsgRemoveCSGeneFromeGSNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 179 };

	MsgRemoveCSGeneFromeGSNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		serverid = 0;
		geneid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRemoveCSGeneFromeGSNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << serverid;
		s << geneid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> serverid;
		s >> geneid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverid", serverid);
		lua::settable(L, -1, "geneid", geneid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",serverid=" << serverid;
		buffer << ",geneid=" << geneid;
	}

public:
	int pid;
	int serverid;
	int geneid;
};

class MsgDoctorPlayerNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 180 };

	MsgDoctorPlayerNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		serverid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDoctorPlayerNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << serverid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> serverid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverid", serverid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",serverid=" << serverid;
	}

public:
	int pid;
	int serverid;
};

class MsgAddHYDScoreNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 181 };

	MsgAddHYDScoreNotify() :
		MessageEx(Category, Id)
	{
		pid = 0;
		eventId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgAddHYDScoreNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << eventId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> eventId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "eventId", eventId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",eventId=" << eventId;
	}

public:
	int pid;
	int eventId;
};

class MsgCS2GS : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 182 };

	MsgCS2GS() :
		MessageEx(Category, Id)
	{
		pid = 0;
		funcID = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCS2GS";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 20;
		length += sizeof(short) + datas.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << funcID;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> funcID;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "funcID", funcID);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",funcID=" << funcID;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
	}

public:
	int pid;
	int funcID;
	int datax;
	int datay;
	int dataz;
	std::string datas;
};

class MsgGS2CS : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 183 };

	MsgGS2CS() :
		MessageEx(Category, Id)
	{
		pid = 0;
		funcID = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGS2CS";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 20;
		length += sizeof(short) + datas.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << funcID;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> funcID;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "funcID", funcID);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",funcID=" << funcID;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
	}

public:
	int pid;
	int funcID;
	int datax;
	int datay;
	int dataz;
	std::string datas;
};

class MsgGetPlayerBaseInfoFromGSRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 191 };

	MsgGetPlayerBaseInfoFromGSRequest() :
		MessageEx(Category, Id)
	{
		srcPid = 0;
		srcServerId = 0;
		pid = 0;
		serverId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetPlayerBaseInfoFromGSRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << srcPid;
		s << srcServerId;
		s << pid;
		s << serverId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> srcPid;
		s >> srcServerId;
		s >> pid;
		s >> serverId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "srcPid", srcPid);
		lua::settable(L, -1, "srcServerId", srcServerId);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverId", serverId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",srcPid=" << srcPid;
		buffer << ",srcServerId=" << srcServerId;
		buffer << ",pid=" << pid;
		buffer << ",serverId=" << serverId;
	}

public:
	int srcPid;
	int srcServerId;
	int pid;
	int serverId;
};

class MsgGetPlayerBaseInfoFromGSResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 192 };

	MsgGetPlayerBaseInfoFromGSResponse() :
		MessageEx(Category, Id)
	{
		srcPid = 0;
		srcServerId = 0;
		pid = 0;
		gender = 0;
		job = 0;
		weapon = 0;
		dressWeapon = 0;
		cloth = 0;
		dressCloth = 0;
		hat = 0;
		shield = 0;
		guardLevel = 0;
		hunhuan = 0;
		jingling = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetPlayerBaseInfoFromGSResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 56;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << srcPid;
		s << srcServerId;
		s << pid;
		s << gender;
		s << job;
		s << weapon;
		s << dressWeapon;
		s << cloth;
		s << dressCloth;
		s << hat;
		s << shield;
		s << guardLevel;
		s << hunhuan;
		s << jingling;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> srcPid;
		s >> srcServerId;
		s >> pid;
		s >> gender;
		s >> job;
		s >> weapon;
		s >> dressWeapon;
		s >> cloth;
		s >> dressCloth;
		s >> hat;
		s >> shield;
		s >> guardLevel;
		s >> hunhuan;
		s >> jingling;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "srcPid", srcPid);
		lua::settable(L, -1, "srcServerId", srcServerId);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "weapon", weapon);
		lua::settable(L, -1, "dressWeapon", dressWeapon);
		lua::settable(L, -1, "cloth", cloth);
		lua::settable(L, -1, "dressCloth", dressCloth);
		lua::settable(L, -1, "hat", hat);
		lua::settable(L, -1, "shield", shield);
		lua::settable(L, -1, "guardLevel", guardLevel);
		lua::settable(L, -1, "hunhuan", hunhuan);
		lua::settable(L, -1, "jingling", jingling);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",srcPid=" << srcPid;
		buffer << ",srcServerId=" << srcServerId;
		buffer << ",pid=" << pid;
		buffer << ",gender=" << gender;
		buffer << ",job=" << job;
		buffer << ",weapon=" << weapon;
		buffer << ",dressWeapon=" << dressWeapon;
		buffer << ",cloth=" << cloth;
		buffer << ",dressCloth=" << dressCloth;
		buffer << ",hat=" << hat;
		buffer << ",shield=" << shield;
		buffer << ",guardLevel=" << guardLevel;
		buffer << ",hunhuan=" << hunhuan;
		buffer << ",jingling=" << jingling;
	}

public:
	int srcPid;
	int srcServerId;
	int pid;
	int gender;
	int job;
	int weapon;
	int dressWeapon;
	int cloth;
	int dressCloth;
	int hat;
	int shield;
	int guardLevel;
	int hunhuan;
	int jingling;
};

class MsgGetPlayerBaseInfoFromCSRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 193 };

	MsgGetPlayerBaseInfoFromCSRequest() :
		MessageEx(Category, Id)
	{
		srcPid = 0;
		srcServerId = 0;
		pid = 0;
		serverId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetPlayerBaseInfoFromCSRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << srcPid;
		s << srcServerId;
		s << pid;
		s << serverId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> srcPid;
		s >> srcServerId;
		s >> pid;
		s >> serverId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "srcPid", srcPid);
		lua::settable(L, -1, "srcServerId", srcServerId);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "serverId", serverId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",srcPid=" << srcPid;
		buffer << ",srcServerId=" << srcServerId;
		buffer << ",pid=" << pid;
		buffer << ",serverId=" << serverId;
	}

public:
	int srcPid;
	int srcServerId;
	int pid;
	int serverId;
};

class MsgGetPlayerBaseInfoFromCSResponse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 194 };

	MsgGetPlayerBaseInfoFromCSResponse() :
		MessageEx(Category, Id)
	{
		srcPid = 0;
		srcServerId = 0;
		pid = 0;
		gender = 0;
		job = 0;
		weapon = 0;
		dressWeapon = 0;
		cloth = 0;
		dressCloth = 0;
		hat = 0;
		shield = 0;
		guardLevel = 0;
		hunhuan = 0;
		jingling = 0;
	}

	virtual const char *getName() const
	{
		return "MsgGetPlayerBaseInfoFromCSResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 56;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << srcPid;
		s << srcServerId;
		s << pid;
		s << gender;
		s << job;
		s << weapon;
		s << dressWeapon;
		s << cloth;
		s << dressCloth;
		s << hat;
		s << shield;
		s << guardLevel;
		s << hunhuan;
		s << jingling;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> srcPid;
		s >> srcServerId;
		s >> pid;
		s >> gender;
		s >> job;
		s >> weapon;
		s >> dressWeapon;
		s >> cloth;
		s >> dressCloth;
		s >> hat;
		s >> shield;
		s >> guardLevel;
		s >> hunhuan;
		s >> jingling;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "srcPid", srcPid);
		lua::settable(L, -1, "srcServerId", srcServerId);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "weapon", weapon);
		lua::settable(L, -1, "dressWeapon", dressWeapon);
		lua::settable(L, -1, "cloth", cloth);
		lua::settable(L, -1, "dressCloth", dressCloth);
		lua::settable(L, -1, "hat", hat);
		lua::settable(L, -1, "shield", shield);
		lua::settable(L, -1, "guardLevel", guardLevel);
		lua::settable(L, -1, "hunhuan", hunhuan);
		lua::settable(L, -1, "jingling", jingling);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",srcPid=" << srcPid;
		buffer << ",srcServerId=" << srcServerId;
		buffer << ",pid=" << pid;
		buffer << ",gender=" << gender;
		buffer << ",job=" << job;
		buffer << ",weapon=" << weapon;
		buffer << ",dressWeapon=" << dressWeapon;
		buffer << ",cloth=" << cloth;
		buffer << ",dressCloth=" << dressCloth;
		buffer << ",hat=" << hat;
		buffer << ",shield=" << shield;
		buffer << ",guardLevel=" << guardLevel;
		buffer << ",hunhuan=" << hunhuan;
		buffer << ",jingling=" << jingling;
	}

public:
	int srcPid;
	int srcServerId;
	int pid;
	int gender;
	int job;
	int weapon;
	int dressWeapon;
	int cloth;
	int dressCloth;
	int hat;
	int shield;
	int guardLevel;
	int hunhuan;
	int jingling;
};

struct CrossDBRankData
{
public:
	CrossDBRankData()
	{
		datax = 0;
		datay = 0;
		dataz = 0;
		time = 0;
		pid = 0;
		gid = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 24;
		length += sizeof(short) + name.size();
		length += sizeof(short) + guildName.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << datax;
		s << datay;
		s << dataz;
		s << time;
		s << pid;
		s << gid;
		s << name;
		s << guildName;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> time;
		s >> pid;
		s >> gid;
		s >> name;
		s >> guildName;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "time", time);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "gid", gid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "guildName", guildName);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",time=" << time;
		buffer << ",pid=" << pid;
		buffer << ",gid=" << gid;
		buffer << ",name=" << name;
		buffer << ",guildName=" << guildName;
	}

public:
	int datax;
	int datay;
	int dataz;
	int time; //上榜时间 
	int pid;
	int gid;
	std::string name;
	std::string guildName;
};

class MsgSendPlayerGreyNameToGS : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 195 };

	MsgSendPlayerGreyNameToGS() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendPlayerGreyNameToGS";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
	}

public:
	int pid;
};

class MsgSendPlayerKillWhiteRoleToGS : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 196 };

	MsgSendPlayerKillWhiteRoleToGS() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendPlayerKillWhiteRoleToGS";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
	}

public:
	int pid;
};

class MsgSendGSRankToCS : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 197 };

	MsgSendGSRankToCS() :
		MessageEx(Category, Id)
	{
		type = 0;
		warZoomId = 0;
		serverId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendGSRankToCS";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 12;
		length += sizeof(int);
		for (size_t i = 0; i < list.size(); ++i)
		{
			length += list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << type;
		s << warZoomId;
		s << serverId;
		int list_vector_size = (int)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> type;
		s >> warZoomId;
		s >> serverId;
		int list_vector_size = s.read_int32();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			CrossDBRankData val;
			val.unserialize(s, true);
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "warZoomId", warZoomId);
		lua::settable(L, -1, "serverId", serverId);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",type=" << type;
		buffer << ",warZoomId=" << warZoomId;
		buffer << ",serverId=" << serverId;
		buffer << ",list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int type;
	int warZoomId;
	int serverId;
	std::vector<CrossDBRankData> list;
};

class MsgSendCSRankToGS : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 198 };

	MsgSendCSRankToGS() :
		MessageEx(Category, Id)
	{
		type = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendCSRankToGS";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < list.size(); ++i)
		{
			length += list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << type;
		int list_vector_size = (int)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> type;
		int list_vector_size = s.read_int32();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			CrossDBRankData val;
			val.unserialize(s, true);
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",type=" << type;
		buffer << ",list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int type;
	std::vector<CrossDBRankData> list;
};

class MsgLoadCSRankNotify : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_CROSS, Id = 199 };

	MsgLoadCSRankNotify() :
		MessageEx(Category, Id)
	{
		warZoomId = 0;
		serverId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgLoadCSRankNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << warZoomId;
		s << serverId;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> warZoomId;
		s >> serverId;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "warZoomId", warZoomId);
		lua::settable(L, -1, "serverId", serverId);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",warZoomId=" << warZoomId;
		buffer << ",serverId=" << serverId;
	}

public:
	int warZoomId;
	int serverId;
};

#endif	//_MSG_CROSS_H_INCLUDED
