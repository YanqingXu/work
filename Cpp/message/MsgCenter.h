//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _MSG_CENTER_H_INCLUDED
#define _MSG_CENTER_H_INCLUDED

#include "category.h"
#include "common/Message.h"

class MsgRegisterToCenterServer : public Message
{
public:
	enum { Category = MSG_CATEGORY_CENTER, Id = 1 };

	MsgRegisterToCenterServer() :
		Message(Category, Id)
	{
		serverId = 0;
		gameServerPort = 0;
		crossManagerServerPort = 0;
		dbAgentPort = 0;
		isCrossServer = 0;
		isCommonCrossServer = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgRegisterToCenterServer";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 22;
		length += sizeof(short) + gameServerAddr.size();
		length += sizeof(short) + crossManagerServerAddr.size();
		length += sizeof(short) + dbAgentAddr.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << serverId;
		s << gameServerAddr;
		s << gameServerPort;
		s << crossManagerServerAddr;
		s << crossManagerServerPort;
		s << dbAgentAddr;
		s << dbAgentPort;
		s << isCrossServer;
		s << isCommonCrossServer;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> serverId;
		s >> gameServerAddr;
		s >> gameServerPort;
		s >> crossManagerServerAddr;
		s >> crossManagerServerPort;
		s >> dbAgentAddr;
		s >> dbAgentPort;
		s >> isCrossServer;
		s >> isCommonCrossServer;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "gameServerAddr", gameServerAddr);
		lua::settable(L, -1, "gameServerPort", gameServerPort);
		lua::settable(L, -1, "crossManagerServerAddr", crossManagerServerAddr);
		lua::settable(L, -1, "crossManagerServerPort", crossManagerServerPort);
		lua::settable(L, -1, "dbAgentAddr", dbAgentAddr);
		lua::settable(L, -1, "dbAgentPort", dbAgentPort);
		lua::settable(L, -1, "isCrossServer", isCrossServer);
		lua::settable(L, -1, "isCommonCrossServer", isCommonCrossServer);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverId=" << serverId;
		buffer << ",gameServerAddr=" << gameServerAddr;
		buffer << ",gameServerPort=" << gameServerPort;
		buffer << ",crossManagerServerAddr=" << crossManagerServerAddr;
		buffer << ",crossManagerServerPort=" << crossManagerServerPort;
		buffer << ",dbAgentAddr=" << dbAgentAddr;
		buffer << ",dbAgentPort=" << dbAgentPort;
		buffer << ",isCrossServer=" << isCrossServer;
		buffer << ",isCommonCrossServer=" << isCommonCrossServer;
		buffer << ",errcode=" << errcode;
	}

public:
	int serverId;
	std::string gameServerAddr;
	int gameServerPort;
	std::string crossManagerServerAddr;
	int crossManagerServerPort;
	std::string dbAgentAddr;
	int dbAgentPort;
	short isCrossServer;
	short isCommonCrossServer;
	short errcode;
};

class MsgFindNewCrossServerNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_CENTER, Id = 2 };

	MsgFindNewCrossServerNotify() :
		Message(Category, Id)
	{
		serverId = 0;
		crossServerPort = 0;
		crossManagerServerPort = 0;
		isCommonCrossServer = 0;
	}

	virtual const char *getName() const
	{
		return "MsgFindNewCrossServerNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 16;
		length += sizeof(short) + crossServerAddr.size();
		length += sizeof(short) + crossManagerServerAddr.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << serverId;
		s << crossServerAddr;
		s << crossServerPort;
		s << crossManagerServerAddr;
		s << crossManagerServerPort;
		s << isCommonCrossServer;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> serverId;
		s >> crossServerAddr;
		s >> crossServerPort;
		s >> crossManagerServerAddr;
		s >> crossManagerServerPort;
		s >> isCommonCrossServer;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "crossServerAddr", crossServerAddr);
		lua::settable(L, -1, "crossServerPort", crossServerPort);
		lua::settable(L, -1, "crossManagerServerAddr", crossManagerServerAddr);
		lua::settable(L, -1, "crossManagerServerPort", crossManagerServerPort);
		lua::settable(L, -1, "isCommonCrossServer", isCommonCrossServer);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverId=" << serverId;
		buffer << ",crossServerAddr=" << crossServerAddr;
		buffer << ",crossServerPort=" << crossServerPort;
		buffer << ",crossManagerServerAddr=" << crossManagerServerAddr;
		buffer << ",crossManagerServerPort=" << crossManagerServerPort;
		buffer << ",isCommonCrossServer=" << isCommonCrossServer;
	}

public:
	int serverId;
	std::string crossServerAddr;
	int crossServerPort;
	std::string crossManagerServerAddr;
	int crossManagerServerPort;
	int isCommonCrossServer;
};

class MsgCrossSvrInfoReport : public Message
{
public:
	enum { Category = MSG_CATEGORY_CENTER, Id = 5 };

	MsgCrossSvrInfoReport() :
		Message(Category, Id)
	{
		serverId = 0;
		playerCnt = 0;
	}

	virtual const char *getName() const
	{
		return "MsgCrossSvrInfoReport";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << serverId;
		s << playerCnt;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> serverId;
		s >> playerCnt;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "playerCnt", playerCnt);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "serverId=" << serverId;
		buffer << ",playerCnt=" << playerCnt;
	}

public:
	int serverId;
	int playerCnt;
};

struct ServerInfo
{
public:
	ServerInfo()
	{
		serverId = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 4;
		length += sizeof(short) + serverName.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << serverId;
		s << serverName;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> serverId;
		s >> serverName;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "serverId", serverId);
		lua::settable(L, -1, "serverName", serverName);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "serverId=" << serverId;
		buffer << ",serverName=" << serverName;
	}

public:
	int serverId;
	std::string serverName;
};

struct WarZoneInfoDetail
{
public:
	WarZoneInfoDetail()
	{
		warZoneId = 0;
		warZonePreOpenTime = 0;
		warZoneOpenTime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < gameServerInfoList.size(); ++i)
		{
			length += gameServerInfoList[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << warZoneId;
		s << warZonePreOpenTime;
		s << warZoneOpenTime;
		int gameServerInfoList_vector_size = ex ? (int)gameServerInfoList.size() : (short)gameServerInfoList.size();
		if (ex)
		{
			s << gameServerInfoList_vector_size;
		}
		else
		{
			s << (short)gameServerInfoList_vector_size;
		}
		if (gameServerInfoList_vector_size > 0)
		{
			for (auto it = gameServerInfoList.begin(); it != gameServerInfoList.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> warZoneId;
		s >> warZonePreOpenTime;
		s >> warZoneOpenTime;
		int gameServerInfoList_vector_size = ex ? s.read_int32() : s.read_int16();
		gameServerInfoList.clear();
		while (gameServerInfoList_vector_size > 0)
		{
			gameServerInfoList_vector_size--;
			ServerInfo val;
			val.unserialize(s, ex);
			gameServerInfoList.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "warZoneId", warZoneId);
		lua::settable(L, -1, "warZonePreOpenTime", warZonePreOpenTime);
		lua::settable(L, -1, "warZoneOpenTime", warZoneOpenTime);
		lua::newtable(lua::L);
		for (size_t i = 0; i < gameServerInfoList.size(); ++i)
		{
			gameServerInfoList[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "gameServerInfoList");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "warZoneId=" << warZoneId;
		buffer << ",warZonePreOpenTime=" << warZonePreOpenTime;
		buffer << ",warZoneOpenTime=" << warZoneOpenTime;
		buffer << ",gameServerInfoList=[";
		for (size_t i = 0; i < gameServerInfoList.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			gameServerInfoList[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int warZoneId; //战区id 
	long long warZonePreOpenTime; //战区的预开启时间 
	long long warZoneOpenTime; //战区的正式开启时间 
	std::vector<ServerInfo> gameServerInfoList; //该战区内的所有游戏服信息 
};

class MsgWarZoneInfoNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_CENTER, Id = 6 };

	MsgWarZoneInfoNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgWarZoneInfoNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		for (size_t i = 0; i < list.size(); ++i)
		{
			length += list[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short list_vector_size = (short)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int list_vector_size = s.read_int16();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			WarZoneInfoDetail val;
			val.unserialize(s, false);
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<WarZoneInfoDetail> list;
};

class MsgWarZoneInfoUpdFinishedNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_CENTER, Id = 7 };

	MsgWarZoneInfoUpdFinishedNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgWarZoneInfoUpdFinishedNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 0;
	}

	virtual bool serialize(ByteStream &s) const
	{
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
	}

public:
};

class MsgSendCrossMailFromCenterNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_CENTER, Id = 8 };

	MsgSendCrossMailFromCenterNotify() :
		Message(Category, Id)
	{
		sourceServerId = 0;
		pid = 0;
		opcode = 0;
		ctime = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendCrossMailFromCenterNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 16;
		length += sizeof(short) + title.size();
		length += sizeof(short) + content.size();
		length += sizeof(short) + items.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << sourceServerId;
		s << pid;
		s << title;
		s << content;
		s << items;
		s << opcode;
		s << ctime;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> sourceServerId;
		s >> pid;
		s >> title;
		s >> content;
		s >> items;
		s >> opcode;
		s >> ctime;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sourceServerId", sourceServerId);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "title", title);
		lua::settable(L, -1, "content", content);
		lua::settable(L, -1, "items", items);
		lua::settable(L, -1, "opcode", opcode);
		lua::settable(L, -1, "ctime", ctime);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "sourceServerId=" << sourceServerId;
		buffer << ",pid=" << pid;
		buffer << ",title=" << title;
		buffer << ",content=" << content;
		buffer << ",items=" << items;
		buffer << ",opcode=" << opcode;
		buffer << ",ctime=" << ctime;
	}

public:
	int sourceServerId;
	int pid;
	std::string title;
	std::string content;
	std::string items;
	int opcode;
	int ctime;
};

class MsgSendCrossMailFromCenter : public Message
{
public:
	enum { Category = MSG_CATEGORY_CENTER, Id = 9 };

	MsgSendCrossMailFromCenter() :
		Message(Category, Id)
	{
		pid = 0;
		opcode = 0;
		ctime = 0;
	}

	virtual const char *getName() const
	{
		return "MsgSendCrossMailFromCenter";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 12;
		length += sizeof(short) + title.size();
		length += sizeof(short) + content.size();
		length += sizeof(short) + items.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << pid;
		s << title;
		s << content;
		s << items;
		s << opcode;
		s << ctime;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> pid;
		s >> title;
		s >> content;
		s >> items;
		s >> opcode;
		s >> ctime;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "title", title);
		lua::settable(L, -1, "content", content);
		lua::settable(L, -1, "items", items);
		lua::settable(L, -1, "opcode", opcode);
		lua::settable(L, -1, "ctime", ctime);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",title=" << title;
		buffer << ",content=" << content;
		buffer << ",items=" << items;
		buffer << ",opcode=" << opcode;
		buffer << ",ctime=" << ctime;
	}

public:
	int pid;
	std::string title;
	std::string content;
	std::string items;
	int opcode;
	int ctime;
};

#endif	//_MSG_CENTER_H_INCLUDED
