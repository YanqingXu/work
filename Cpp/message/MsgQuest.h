//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _MSG_QUEST_H_INCLUDED
#define _MSG_QUEST_H_INCLUDED

#include "category.h"
#include "common/Message.h"

struct QuestInfo
{
public:
	QuestInfo()
	{
		qid = 0;
		sid = 0;
		state = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	size_t getLength(bool ex) const
	{
		return 18;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << qid;
		s << sid;
		s << state;
		s << datax;
		s << datay;
		s << dataz;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> qid;
		s >> sid;
		s >> state;
		s >> datax;
		s >> datay;
		s >> dataz;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "qid", qid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "state", state);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "qid=" << qid;
		buffer << ",sid=" << sid;
		buffer << ",state=" << state;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
	}

public:
	short qid;
	short sid;
	short state;
	int datax;
	int datay;
	int dataz;
};

class MsgQuestUpdateListNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 1 };

	MsgQuestUpdateListNotify() :
		Message(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgQuestUpdateListNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 0;
		length += sizeof(short);
		for (size_t i = 0; i < quests.size(); ++i)
		{
			length += quests[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		short quests_vector_size = (short)quests.size();
		s << quests_vector_size;
		if (quests_vector_size > 0)
		{
			for (auto it = quests.begin(); it != quests.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		int quests_vector_size = s.read_int16();
		quests.clear();
		while (quests_vector_size > 0)
		{
			quests_vector_size--;
			QuestInfo val;
			val.unserialize(s, false);
			quests.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < quests.size(); ++i)
		{
			quests[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "quests");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "quests=[";
		for (size_t i = 0; i < quests.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			quests[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<QuestInfo> quests;
};

class MsgQuestUpdateNotify : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 2 };

	MsgQuestUpdateNotify() :
		Message(Category, Id)
	{
		opcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgQuestUpdateNotify";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 4;
		length += quest.getLength(false);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		quest.serialize(s, false);
		s << opcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		quest.unserialize(s, false);
		s >> opcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		quest.push(L);
		lua::settable(L, -1, "quest");
		lua::settable(L, -1, "opcode", opcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "quest={";
		quest.dump(buffer);
		buffer << "}";
		buffer << ",opcode=" << opcode;
	}

public:
	QuestInfo quest;
	int opcode;
};

class MsgQuestAcceptRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 3 };

	MsgQuestAcceptRequest() :
		Message(Category, Id)
	{
		qid = 0;
		sid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgQuestAcceptRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << qid;
		s << sid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> qid;
		s >> sid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "qid", qid);
		lua::settable(L, -1, "sid", sid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "qid=" << qid;
		buffer << ",sid=" << sid;
	}

public:
	short qid;
	short sid;
};

class MsgQuestAcceptResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 4 };

	MsgQuestAcceptResponse() :
		Message(Category, Id)
	{
		qid = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgQuestAcceptResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << qid;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> qid;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "qid", qid);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "qid=" << qid;
		buffer << ",errcode=" << errcode;
	}

public:
	short qid;
	short errcode;
};

class MsgQuestSubmitRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 5 };

	MsgQuestSubmitRequest() :
		Message(Category, Id)
	{
		qid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgQuestSubmitRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 2;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << qid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> qid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "qid", qid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "qid=" << qid;
	}

public:
	short qid;
};

class MsgQuestSubmitResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 6 };

	MsgQuestSubmitResponse() :
		Message(Category, Id)
	{
		qid = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgQuestSubmitResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << qid;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> qid;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "qid", qid);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "qid=" << qid;
		buffer << ",errcode=" << errcode;
	}

public:
	short qid;
	short errcode;
};

class MsgQuestRemoveRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 7 };

	MsgQuestRemoveRequest() :
		Message(Category, Id)
	{
		qid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgQuestRemoveRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 2;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << qid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> qid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "qid", qid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "qid=" << qid;
	}

public:
	short qid;
};

class MsgQuestRemoveResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 8 };

	MsgQuestRemoveResponse() :
		Message(Category, Id)
	{
		qid = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgQuestRemoveResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << qid;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> qid;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "qid", qid);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "qid=" << qid;
		buffer << ",errcode=" << errcode;
	}

public:
	short qid;
	short errcode;
};

struct npcFunction
{
public:
	npcFunction()
	{
		functionid = 0;
		data = 0;
		show = 0;
		numid = 0;
	}

	size_t getLength(bool ex) const
	{
		return 14;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << functionid;
		s << data;
		s << show;
		s << numid;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> functionid;
		s >> data;
		s >> show;
		s >> numid;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "functionid", functionid);
		lua::settable(L, -1, "data", data);
		lua::settable(L, -1, "show", show);
		lua::settable(L, -1, "numid", numid);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "functionid=" << functionid;
		buffer << ",data=" << data;
		buffer << ",show=" << show;
		buffer << ",numid=" << numid;
	}

public:
	short functionid;
	int data;
	int show;
	int numid;
};

class MsgClickNPCRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 9 };

	MsgClickNPCRequest() :
		Message(Category, Id)
	{
		NPCid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgClickNPCRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << NPCid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> NPCid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "NPCid", NPCid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "NPCid=" << NPCid;
	}

public:
	int NPCid;
};

class MsgClickNPCResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 10 };

	MsgClickNPCResponse() :
		Message(Category, Id)
	{
		NPCid = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgClickNPCResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = 6;
		length += sizeof(short);
		for (size_t i = 0; i < function.size(); ++i)
		{
			length += function[i].getLength(false);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << NPCid;
		s << errcode;
		short function_vector_size = (short)function.size();
		s << function_vector_size;
		if (function_vector_size > 0)
		{
			for (auto it = function.begin(); it != function.end(); ++it)
			{
				(*it).serialize(s, false);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> NPCid;
		s >> errcode;
		int function_vector_size = s.read_int16();
		function.clear();
		while (function_vector_size > 0)
		{
			function_vector_size--;
			npcFunction val;
			val.unserialize(s, false);
			function.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "NPCid", NPCid);
		lua::settable(L, -1, "errcode", errcode);
		lua::newtable(lua::L);
		for (size_t i = 0; i < function.size(); ++i)
		{
			function[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "function");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "NPCid=" << NPCid;
		buffer << ",errcode=" << errcode;
		buffer << ",function=[";
		for (size_t i = 0; i < function.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			function[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int NPCid;
	short errcode;
	std::vector<npcFunction> function;
};

class MsgClickNPCFunctionScriptRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 11 };

	MsgClickNPCFunctionScriptRequest() :
		Message(Category, Id)
	{
		NPCid = 0;
		data = 0;
	}

	virtual const char *getName() const
	{
		return "MsgClickNPCFunctionScriptRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << NPCid;
		s << data;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> NPCid;
		s >> data;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "NPCid", NPCid);
		lua::settable(L, -1, "data", data);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "NPCid=" << NPCid;
		buffer << ",data=" << data;
	}

public:
	int NPCid;
	int data;
};

class MsgClickNPCFunctionScriptResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 12 };

	MsgClickNPCFunctionScriptResponse() :
		Message(Category, Id)
	{
		NPCid = 0;
		data = 0;
		errcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgClickNPCFunctionScriptResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 10;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << NPCid;
		s << data;
		s << errcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> NPCid;
		s >> data;
		s >> errcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "NPCid", NPCid);
		lua::settable(L, -1, "data", data);
		lua::settable(L, -1, "errcode", errcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "NPCid=" << NPCid;
		buffer << ",data=" << data;
		buffer << ",errcode=" << errcode;
	}

public:
	int NPCid;
	int data;
	short errcode;
};

class MsgClickCMRequest : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 112 };

	MsgClickCMRequest() :
		Message(Category, Id)
	{
		id = 0;
		type = 0;
		code = 0;
	}

	virtual const char *getName() const
	{
		return "MsgClickCMRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << id;
		s << type;
		s << code;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> id;
		s >> type;
		s >> code;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "id", id);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "code", code);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "id=" << id;
		buffer << ",type=" << type;
		buffer << ",code=" << code;
	}

public:
	int id;
	int type;
	int code;
};

class MsgClickCMResponse : public Message
{
public:
	enum { Category = MSG_CATEGORY_QUEST, Id = 113 };

	MsgClickCMResponse() :
		Message(Category, Id)
	{
		errcode = 0;
		type = 0;
		code = 0;
		time = 0;
	}

	virtual const char *getName() const
	{
		return "MsgClickCMResponse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return 14;
	}

	virtual bool serialize(ByteStream &s) const
	{
		s << errcode;
		s << type;
		s << code;
		s << time;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		s >> errcode;
		s >> type;
		s >> code;
		s >> time;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "code", code);
		lua::settable(L, -1, "time", time);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		buffer << "errcode=" << errcode;
		buffer << ",type=" << type;
		buffer << ",code=" << code;
		buffer << ",time=" << time;
	}

public:
	short errcode;
	int type;
	int code;
	int time;
};

#endif	//_MSG_QUEST_H_INCLUDED
