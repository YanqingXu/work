//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _DB_MSG_PLAYER_H_INCLUDED
#define _DB_MSG_PLAYER_H_INCLUDED

#include "category.h"
#include "common/MessageEx.h"

class MsgDBUpdatePlayerName : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 1 };

	MsgDBUpdatePlayerName() :
		MessageEx(Category, Id)
	{
		pid = 0;
		flags = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerName";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 6;
		length += sizeof(short) + name.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << name;
		s << flags;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> name;
		s >> flags;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "flags", flags);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",flags=" << flags;
	}

public:
	int pid; //Íæ¼ÒID 
	std::string name;
	short flags;
};

class MsgDBUpdatePlayerLvlExp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 2 };

	MsgDBUpdatePlayerLvlExp() :
		MessageEx(Category, Id)
	{
		pid = 0;
		lvl = 0;
		exp = 0;
		reborn = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerLvlExp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << lvl;
		s << exp;
		s << reborn;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> lvl;
		s >> exp;
		s >> reborn;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "lvl", lvl);
		lua::settable(L, -1, "exp", exp);
		lua::settable(L, -1, "reborn", reborn);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",lvl=" << lvl;
		buffer << ",exp=" << exp;
		buffer << ",reborn=" << reborn;
	}

public:
	int pid;
	short lvl;
	long long exp;
	short reborn;
};

class MsgDBUpdatePlayerPositon : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 3 };

	MsgDBUpdatePlayerPositon() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sceneid = 0;
		posx = 0;
		posy = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerPositon";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sceneid;
		s << posx;
		s << posy;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sceneid;
		s >> posx;
		s >> posy;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sceneid", sceneid);
		lua::settable(L, -1, "posx", posx);
		lua::settable(L, -1, "posy", posy);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sceneid=" << sceneid;
		buffer << ",posx=" << posx;
		buffer << ",posy=" << posy;
	}

public:
	int pid;
	int sceneid;
	short posx;
	short posy;
};

class MsgDBUpdatePlayerLingFu : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 4 };

	MsgDBUpdatePlayerLingFu() :
		MessageEx(Category, Id)
	{
		pid = 0;
		lingfu = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerLingFu";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << lingfu;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> lingfu;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "lingfu", lingfu);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",lingfu=" << lingfu;
	}

public:
	int pid;
	int lingfu;
};

class MsgDBUpdatePlayerIngot : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 5 };

	MsgDBUpdatePlayerIngot() :
		MessageEx(Category, Id)
	{
		pid = 0;
		ingot = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerIngot";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << ingot;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> ingot;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "ingot", ingot);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",ingot=" << ingot;
	}

public:
	int pid;
	long long ingot;
};

class MsgDBUpdatePlayerBoundLingFu : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 6 };

	MsgDBUpdatePlayerBoundLingFu() :
		MessageEx(Category, Id)
	{
		pid = 0;
		boundlingfu = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerBoundLingFu";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << boundlingfu;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> boundlingfu;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "boundlingfu", boundlingfu);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",boundlingfu=" << boundlingfu;
	}

public:
	int pid;
	int boundlingfu;
};

class MsgDBUpdatePlayerBoundIngot : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 7 };

	MsgDBUpdatePlayerBoundIngot() :
		MessageEx(Category, Id)
	{
		pid = 0;
		boundingot = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerBoundIngot";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << boundingot;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> boundingot;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "boundingot", boundingot);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",boundingot=" << boundingot;
	}

public:
	int pid;
	long long boundingot;
};

struct exData
{
public:
	exData()
	{
		ctype = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << ctype;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> ctype;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ctype", ctype);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "ctype=" << ctype;
		buffer << ",data=" << data;
	}

public:
	int ctype;
	int data;
};

class MsgDBLoadPlayerProps : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 21 };

	MsgDBLoadPlayerProps() :
		MessageEx(Category, Id)
	{
		pid = 0;
		load_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerProps";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << load_id;
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> load_id;
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			exData val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "load_id", load_id);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",load_id=" << load_id;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int load_id;
	std::vector<exData> props;
};

class MsgDBAddPlayerProp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 22 };

	MsgDBAddPlayerProp() :
		MessageEx(Category, Id)
	{
		pid = 0;
		ctype = 0;
		data = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBAddPlayerProp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << ctype;
		s << data;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> ctype;
		s >> data;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "ctype", ctype);
		lua::settable(L, -1, "data", data);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",ctype=" << ctype;
		buffer << ",data=" << data;
	}

public:
	int pid;
	int ctype;
	int data;
};

class MsgDBUpdatePlayerProp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 23 };

	MsgDBUpdatePlayerProp() :
		MessageEx(Category, Id)
	{
		pid = 0;
		ctype = 0;
		data = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerProp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << ctype;
		s << data;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> ctype;
		s >> data;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "ctype", ctype);
		lua::settable(L, -1, "data", data);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",ctype=" << ctype;
		buffer << ",data=" << data;
	}

public:
	int pid;
	int ctype;
	int data;
};

class MsgDBUpdatePlayerGuildID : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 31 };

	MsgDBUpdatePlayerGuildID() :
		MessageEx(Category, Id)
	{
		pid = 0;
		gid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerGuildID";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << gid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> gid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "gid", gid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",gid=" << gid;
	}

public:
	int pid;
	int gid;
};

struct DBCooldown
{
public:
	DBCooldown()
	{
		ctype = 0;
		endtime = 0;
		flag = 0;
	}

	size_t getLength(bool ex) const
	{
		return 7;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << ctype;
		s << endtime;
		s << flag;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> ctype;
		s >> endtime;
		s >> flag;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "ctype", ctype);
		lua::settable(L, -1, "endtime", endtime);
		lua::settable(L, -1, "flag", flag);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "ctype=" << ctype;
		buffer << ",endtime=" << endtime;
		buffer << ",flag=" << flag;
	}

public:
	short ctype;
	int endtime;
	char flag;
};

class MsgDBLoadCoolDown : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 41 };

	MsgDBLoadCoolDown() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadCoolDown";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < CDlist.size(); ++i)
		{
			length += CDlist[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		int CDlist_vector_size = (int)CDlist.size();
		s << CDlist_vector_size;
		if (CDlist_vector_size > 0)
		{
			for (auto it = CDlist.begin(); it != CDlist.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		int CDlist_vector_size = s.read_int32();
		CDlist.clear();
		while (CDlist_vector_size > 0)
		{
			CDlist_vector_size--;
			DBCooldown val;
			val.unserialize(s, true);
			CDlist.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < CDlist.size(); ++i)
		{
			CDlist[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "CDlist");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",CDlist=[";
		for (size_t i = 0; i < CDlist.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			CDlist[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	std::vector<DBCooldown> CDlist;
};

class MsgDBUpdateCoolDown : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 42 };

	MsgDBUpdateCoolDown() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateCoolDown";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += CDinfo.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		CDinfo.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		CDinfo.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		CDinfo.push(L);
		lua::settable(L, -1, "CDinfo");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",CDinfo={";
		CDinfo.dump(buffer);
		buffer << "}";
	}

public:
	int pid;
	DBCooldown CDinfo;
};

struct DBPlayerEvent
{
public:
	DBPlayerEvent()
	{
		eid = 0;
		tindex = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
		ctime = 0;
	}

	size_t getLength(bool ex) const
	{
		return 24;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << eid;
		s << tindex;
		s << datax;
		s << datay;
		s << dataz;
		s << ctime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> eid;
		s >> tindex;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> ctime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "eid", eid);
		lua::settable(L, -1, "tindex", tindex);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "ctime", ctime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "eid=" << eid;
		buffer << ",tindex=" << tindex;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",ctime=" << ctime;
	}

public:
	int eid;
	int tindex;
	int datax;
	int datay;
	int dataz;
	int ctime;
};

class MsgDBLoadPlayerEvent : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 51 };

	MsgDBLoadPlayerEvent() :
		MessageEx(Category, Id)
	{
		pid = 0;
		load_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerEvent";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < events.size(); ++i)
		{
			length += events[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << load_id;
		int events_vector_size = (int)events.size();
		s << events_vector_size;
		if (events_vector_size > 0)
		{
			for (auto it = events.begin(); it != events.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> load_id;
		int events_vector_size = s.read_int32();
		events.clear();
		while (events_vector_size > 0)
		{
			events_vector_size--;
			DBPlayerEvent val;
			val.unserialize(s, true);
			events.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "load_id", load_id);
		lua::newtable(lua::L);
		for (size_t i = 0; i < events.size(); ++i)
		{
			events[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "events");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",load_id=" << load_id;
		buffer << ",events=[";
		for (size_t i = 0; i < events.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			events[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int load_id;
	std::vector<DBPlayerEvent> events;
};

class MsgDBUpdPlayerEvent : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 52 };

	MsgDBUpdPlayerEvent() :
		MessageEx(Category, Id)
	{
		pid = 0;
		eid = 0;
		tindex = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdPlayerEvent";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 24;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << eid;
		s << tindex;
		s << datax;
		s << datay;
		s << dataz;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> eid;
		s >> tindex;
		s >> datax;
		s >> datay;
		s >> dataz;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "eid", eid);
		lua::settable(L, -1, "tindex", tindex);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",eid=" << eid;
		buffer << ",tindex=" << tindex;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
	}

public:
	int pid;
	int eid;
	int tindex;
	int datax;
	int datay;
	int dataz;
};

class MsgDBDeletePlayerEvent : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 53 };

	MsgDBDeletePlayerEvent() :
		MessageEx(Category, Id)
	{
		pid = 0;
		eid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBDeletePlayerEvent";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << eid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> eid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "eid", eid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",eid=" << eid;
	}

public:
	int pid;
	int eid;
};

struct DBPlayerGene
{
public:
	DBPlayerGene()
	{
		geneid = 0;
		duration = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	size_t getLength(bool ex) const
	{
		return 20;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << geneid;
		s << duration;
		s << datax;
		s << datay;
		s << dataz;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> geneid;
		s >> duration;
		s >> datax;
		s >> datay;
		s >> dataz;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "geneid", geneid);
		lua::settable(L, -1, "duration", duration);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "geneid=" << geneid;
		buffer << ",duration=" << duration;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
	}

public:
	int geneid;
	int duration;
	int datax;
	int datay;
	int dataz;
};

class MsgDBLoadPlayerGene : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 61 };

	MsgDBLoadPlayerGene() :
		MessageEx(Category, Id)
	{
		pid = 0;
		load_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerGene";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < genes.size(); ++i)
		{
			length += genes[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << load_id;
		int genes_vector_size = (int)genes.size();
		s << genes_vector_size;
		if (genes_vector_size > 0)
		{
			for (auto it = genes.begin(); it != genes.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> load_id;
		int genes_vector_size = s.read_int32();
		genes.clear();
		while (genes_vector_size > 0)
		{
			genes_vector_size--;
			DBPlayerGene val;
			val.unserialize(s, true);
			genes.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "load_id", load_id);
		lua::newtable(lua::L);
		for (size_t i = 0; i < genes.size(); ++i)
		{
			genes[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "genes");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",load_id=" << load_id;
		buffer << ",genes=[";
		for (size_t i = 0; i < genes.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			genes[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int load_id;
	std::vector<DBPlayerGene> genes;
};

class MsgDBUpdPlayerGene : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 62 };

	MsgDBUpdPlayerGene() :
		MessageEx(Category, Id)
	{
		pid = 0;
		geneid = 0;
		duration = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdPlayerGene";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 24;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << geneid;
		s << duration;
		s << datax;
		s << datay;
		s << dataz;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> geneid;
		s >> duration;
		s >> datax;
		s >> datay;
		s >> dataz;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "geneid", geneid);
		lua::settable(L, -1, "duration", duration);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",geneid=" << geneid;
		buffer << ",duration=" << duration;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
	}

public:
	int pid;
	int geneid;
	int duration;
	int datax;
	int datay;
	int dataz;
};

class MsgDBRmvPlayerGene : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 63 };

	MsgDBRmvPlayerGene() :
		MessageEx(Category, Id)
	{
		pid = 0;
		geneid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBRmvPlayerGene";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << geneid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> geneid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "geneid", geneid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",geneid=" << geneid;
	}

public:
	int pid;
	int geneid;
};

struct DBSkillInfo
{
public:
	DBSkillInfo()
	{
		sid = 0;
		exp = 0;
		position = 0;
	}

	size_t getLength(bool ex) const
	{
		return 9;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << sid;
		s << exp;
		s << position;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> sid;
		s >> exp;
		s >> position;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "exp", exp);
		lua::settable(L, -1, "position", position);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "sid=" << sid;
		buffer << ",exp=" << exp;
		buffer << ",position=" << position;
	}

public:
	int sid;
	int exp;
	char position;
};

struct DBPlayerSkillInfo
{
public:
	DBPlayerSkillInfo()
	{
		sid = 0;
		lvl = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << sid;
		s << lvl;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> sid;
		s >> lvl;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "lvl", lvl);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "sid=" << sid;
		buffer << ",lvl=" << lvl;
	}

public:
	int sid;
	int lvl;
};

class MsgDBLoadSkill : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 71 };

	MsgDBLoadSkill() :
		MessageEx(Category, Id)
	{
		pid = 0;
		load_id = 0;
		load_reason = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadSkill";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 9;
		length += sizeof(int);
		for (size_t i = 0; i < skill_list.size(); ++i)
		{
			length += skill_list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int skill_list_vector_size = (int)skill_list.size();
		s << skill_list_vector_size;
		if (skill_list_vector_size > 0)
		{
			for (auto it = skill_list.begin(); it != skill_list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		s << pid;
		s << load_id;
		s << load_reason;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int skill_list_vector_size = s.read_int32();
		skill_list.clear();
		while (skill_list_vector_size > 0)
		{
			skill_list_vector_size--;
			DBPlayerSkillInfo val;
			val.unserialize(s, true);
			skill_list.push_back(val);
		}
		s >> pid;
		s >> load_id;
		s >> load_reason;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < skill_list.size(); ++i)
		{
			skill_list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "skill_list");
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "load_id", load_id);
		lua::settable(L, -1, "load_reason", load_reason);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",skill_list=[";
		for (size_t i = 0; i < skill_list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			skill_list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",pid=" << pid;
		buffer << ",load_id=" << load_id;
		buffer << ",load_reason=" << load_reason;
	}

public:
	std::vector<DBPlayerSkillInfo> skill_list;
	int pid;
	int load_id;
	char load_reason;
};

class MsgDBAddSkill : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 72 };

	MsgDBAddSkill() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sid = 0;
		level = 0;
		opcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBAddSkill";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sid;
		s << level;
		s << opcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sid;
		s >> level;
		s >> opcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "opcode", opcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",level=" << level;
		buffer << ",opcode=" << opcode;
	}

public:
	int pid;
	int sid;
	short level;
	short opcode;
};

class MsgDBRemoveSkill : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 73 };

	MsgDBRemoveSkill() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sid = 0;
		opcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBRemoveSkill";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 10;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sid;
		s << opcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sid;
		s >> opcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "opcode", opcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",opcode=" << opcode;
	}

public:
	int pid;
	int sid;
	short opcode;
};

class MsgDBUpdateSkillSidExp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 74 };

	MsgDBUpdateSkillSidExp() :
		MessageEx(Category, Id)
	{
		pid = 0;
		osid = 0;
		sid = 0;
		exp = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateSkillSidExp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 16;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << osid;
		s << sid;
		s << exp;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> osid;
		s >> sid;
		s >> exp;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "osid", osid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "exp", exp);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",osid=" << osid;
		buffer << ",sid=" << sid;
		buffer << ",exp=" << exp;
	}

public:
	int pid;
	int osid;
	int sid;
	int exp;
};

class MsgDBUpdateSkillPosition : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 75 };

	MsgDBUpdateSkillPosition() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sid = 0;
		position = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateSkillPosition";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 10;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sid;
		s << position;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sid;
		s >> position;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "position", position);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",position=" << position;
	}

public:
	int pid;
	int sid;
	short position;
};

class MsgDBLoadPetSkill : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 81 };

	MsgDBLoadPetSkill() :
		MessageEx(Category, Id)
	{
		pid = 0;
		load_id = 0;
		load_reason = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPetSkill";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 9;
		length += sizeof(int);
		for (size_t i = 0; i < skill_list.size(); ++i)
		{
			length += skill_list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int skill_list_vector_size = (int)skill_list.size();
		s << skill_list_vector_size;
		if (skill_list_vector_size > 0)
		{
			for (auto it = skill_list.begin(); it != skill_list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		s << pid;
		s << load_id;
		s << load_reason;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int skill_list_vector_size = s.read_int32();
		skill_list.clear();
		while (skill_list_vector_size > 0)
		{
			skill_list_vector_size--;
			DBSkillInfo val;
			val.unserialize(s, true);
			skill_list.push_back(val);
		}
		s >> pid;
		s >> load_id;
		s >> load_reason;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < skill_list.size(); ++i)
		{
			skill_list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "skill_list");
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "load_id", load_id);
		lua::settable(L, -1, "load_reason", load_reason);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",skill_list=[";
		for (size_t i = 0; i < skill_list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			skill_list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",pid=" << pid;
		buffer << ",load_id=" << load_id;
		buffer << ",load_reason=" << load_reason;
	}

public:
	std::vector<DBSkillInfo> skill_list;
	int pid;
	int load_id;
	char load_reason;
};

class MsgDBAddPetSkill : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 82 };

	MsgDBAddPetSkill() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sid = 0;
		exp = 0;
		position = 0;
		opcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBAddPetSkill";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 14;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sid;
		s << exp;
		s << position;
		s << opcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sid;
		s >> exp;
		s >> position;
		s >> opcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "exp", exp);
		lua::settable(L, -1, "position", position);
		lua::settable(L, -1, "opcode", opcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",exp=" << exp;
		buffer << ",position=" << position;
		buffer << ",opcode=" << opcode;
	}

public:
	int pid;
	int sid;
	short exp;
	short position;
	short opcode;
};

class MsgDBRemovePetSkill : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 83 };

	MsgDBRemovePetSkill() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sid = 0;
		opcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBRemovePetSkill";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 10;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sid;
		s << opcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sid;
		s >> opcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "opcode", opcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",opcode=" << opcode;
	}

public:
	int pid;
	int sid;
	short opcode;
};

class MsgDBUpdatePetSkill : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 84 };

	MsgDBUpdatePetSkill() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sid = 0;
		exp = 0;
		position = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePetSkill";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 14;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sid;
		s << exp;
		s << position;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sid;
		s >> exp;
		s >> position;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "exp", exp);
		lua::settable(L, -1, "position", position);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",exp=" << exp;
		buffer << ",position=" << position;
	}

public:
	int pid;
	int sid;
	int exp;
	short position;
};

class MsgDBCheckAppStoreCommentRewarded : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 94 };

	MsgDBCheckAppStoreCommentRewarded() :
		MessageEx(Category, Id)
	{
		aid = 0;
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBCheckAppStoreCommentRewarded";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return aid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << aid;
		s << pid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> aid;
		s >> pid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "aid", aid);
		lua::settable(L, -1, "pid", pid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",aid=" << aid;
		buffer << ",pid=" << pid;
	}

public:
	int aid;
	int pid;
};

struct DBdress
{
public:
	DBdress()
	{
		dressid = 0;
		status = 0;
		etime = 0;
		lvl = 0;
	}

	size_t getLength(bool ex) const
	{
		return 16;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << dressid;
		s << status;
		s << etime;
		s << lvl;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> dressid;
		s >> status;
		s >> etime;
		s >> lvl;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "dressid", dressid);
		lua::settable(L, -1, "status", status);
		lua::settable(L, -1, "etime", etime);
		lua::settable(L, -1, "lvl", lvl);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "dressid=" << dressid;
		buffer << ",status=" << status;
		buffer << ",etime=" << etime;
		buffer << ",lvl=" << lvl;
	}

public:
	int dressid;
	int status;
	int etime;
	int lvl;
};

struct DBPlayerStr
{
public:
	DBPlayerStr()
	{
		keyid = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 4;
		length += sizeof(short) + data.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << keyid;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> keyid;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "keyid", keyid);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "keyid=" << keyid;
		buffer << ",data=" << data;
	}

public:
	int keyid;
	std::string data;
};

class MsgDBSavePlayerDress : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 95 };

	MsgDBSavePlayerDress() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBSavePlayerDress";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += dress.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		dress.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		dress.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		dress.push(L);
		lua::settable(L, -1, "dress");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",dress={";
		dress.dump(buffer);
		buffer << "}";
	}

public:
	int pid;
	DBdress dress;
};

class MsgDBUpdatePlayerDress : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 96 };

	MsgDBUpdatePlayerDress() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerDress";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += dress.getLength(true);
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		dress.serialize(s, true);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		dress.unserialize(s, true);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		dress.push(L);
		lua::settable(L, -1, "dress");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",dress={";
		dress.dump(buffer);
		buffer << "}";
	}

public:
	int pid;
	DBdress dress;
};

class MsgDBLoadPlayerDress : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 97 };

	MsgDBLoadPlayerDress() :
		MessageEx(Category, Id)
	{
		pid = 0;
		load_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerDress";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < dressVec.size(); ++i)
		{
			length += dressVec[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << load_id;
		int dressVec_vector_size = (int)dressVec.size();
		s << dressVec_vector_size;
		if (dressVec_vector_size > 0)
		{
			for (auto it = dressVec.begin(); it != dressVec.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> load_id;
		int dressVec_vector_size = s.read_int32();
		dressVec.clear();
		while (dressVec_vector_size > 0)
		{
			dressVec_vector_size--;
			DBdress val;
			val.unserialize(s, true);
			dressVec.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "load_id", load_id);
		lua::newtable(lua::L);
		for (size_t i = 0; i < dressVec.size(); ++i)
		{
			dressVec[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "dressVec");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",load_id=" << load_id;
		buffer << ",dressVec=[";
		for (size_t i = 0; i < dressVec.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			dressVec[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int load_id;
	std::vector<DBdress> dressVec;
};

class MsgDBLoadPlayerStrData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 98 };

	MsgDBLoadPlayerStrData() :
		MessageEx(Category, Id)
	{
		pid = 0;
		load_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerStrData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < playerStrVec.size(); ++i)
		{
			length += playerStrVec[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << load_id;
		int playerStrVec_vector_size = (int)playerStrVec.size();
		s << playerStrVec_vector_size;
		if (playerStrVec_vector_size > 0)
		{
			for (auto it = playerStrVec.begin(); it != playerStrVec.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> load_id;
		int playerStrVec_vector_size = s.read_int32();
		playerStrVec.clear();
		while (playerStrVec_vector_size > 0)
		{
			playerStrVec_vector_size--;
			DBPlayerStr val;
			val.unserialize(s, true);
			playerStrVec.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "load_id", load_id);
		lua::newtable(lua::L);
		for (size_t i = 0; i < playerStrVec.size(); ++i)
		{
			playerStrVec[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "playerStrVec");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",load_id=" << load_id;
		buffer << ",playerStrVec=[";
		for (size_t i = 0; i < playerStrVec.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			playerStrVec[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int load_id;
	std::vector<DBPlayerStr> playerStrVec;
};

class MsgDBUpdatePlayerStrData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 99 };

	MsgDBUpdatePlayerStrData() :
		MessageEx(Category, Id)
	{
		pid = 0;
		keyid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerStrData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(short) + data.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << keyid;
		s << data;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> keyid;
		s >> data;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "keyid", keyid);
		lua::settable(L, -1, "data", data);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",keyid=" << keyid;
		buffer << ",data=" << data;
	}

public:
	int pid;
	int keyid;
	std::string data;
};

class MsgDBUpDateSkillLevel : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 100 };

	MsgDBUpDateSkillLevel() :
		MessageEx(Category, Id)
	{
		pid = 0;
		sid = 0;
		level = 0;
		opcode = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpDateSkillLevel";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << sid;
		s << level;
		s << opcode;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> sid;
		s >> level;
		s >> opcode;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "opcode", opcode);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",sid=" << sid;
		buffer << ",level=" << level;
		buffer << ",opcode=" << opcode;
	}

public:
	int pid;
	int sid;
	short level;
	short opcode;
};

struct RobbingInfo
{
public:
	RobbingInfo()
	{
		owner_id = 0;
		owner_lvl = 0;
		lode_lvl = 0;
		lode_index = 0;
		robber_id = 0;
		robber_power = 0;
		rob_time = 0;
		retake_time = 0;
		retake_result = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 36;
		length += sizeof(short) + owner_name.size();
		length += sizeof(short) + robber_name.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << owner_id;
		s << owner_name;
		s << owner_lvl;
		s << lode_lvl;
		s << lode_index;
		s << robber_id;
		s << robber_name;
		s << robber_power;
		s << rob_time;
		s << retake_time;
		s << retake_result;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> owner_id;
		s >> owner_name;
		s >> owner_lvl;
		s >> lode_lvl;
		s >> lode_index;
		s >> robber_id;
		s >> robber_name;
		s >> robber_power;
		s >> rob_time;
		s >> retake_time;
		s >> retake_result;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "owner_id", owner_id);
		lua::settable(L, -1, "owner_name", owner_name);
		lua::settable(L, -1, "owner_lvl", owner_lvl);
		lua::settable(L, -1, "lode_lvl", lode_lvl);
		lua::settable(L, -1, "lode_index", lode_index);
		lua::settable(L, -1, "robber_id", robber_id);
		lua::settable(L, -1, "robber_name", robber_name);
		lua::settable(L, -1, "robber_power", robber_power);
		lua::settable(L, -1, "rob_time", rob_time);
		lua::settable(L, -1, "retake_time", retake_time);
		lua::settable(L, -1, "retake_result", retake_result);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "owner_id=" << owner_id;
		buffer << ",owner_name=" << owner_name;
		buffer << ",owner_lvl=" << owner_lvl;
		buffer << ",lode_lvl=" << lode_lvl;
		buffer << ",lode_index=" << lode_index;
		buffer << ",robber_id=" << robber_id;
		buffer << ",robber_name=" << robber_name;
		buffer << ",robber_power=" << robber_power;
		buffer << ",rob_time=" << rob_time;
		buffer << ",retake_time=" << retake_time;
		buffer << ",retake_result=" << retake_result;
	}

public:
	int owner_id;
	std::string owner_name;
	int owner_lvl;
	int lode_lvl;
	int lode_index;
	int robber_id;
	std::string robber_name;
	int robber_power;
	int rob_time;
	int retake_time;
	int retake_result;
};

struct OtherEquipInfoDB
{
public:
	OtherEquipInfoDB()
	{
		pos = 0;
		sid = 0;
		iid = 0;
		bind = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 16;
		length += ex ? sizeof(int) : sizeof(short);
		length += props.size() * 4;
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pos;
		s << sid;
		s << iid;
		s << bind;
		int props_vector_size = ex ? (int)props.size() : (short)props.size();
		if (ex)
		{
			s << props_vector_size;
		}
		else
		{
			s << (short)props_vector_size;
		}
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pos;
		s >> sid;
		s >> iid;
		s >> bind;
		int props_vector_size = ex ? s.read_int32() : s.read_int16();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			int val;
			s >> val;
			props.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pos", pos);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "bind", bind);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, props[i]);
		}
		lua::settable(L, -2, "props");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pos=" << pos;
		buffer << ",sid=" << sid;
		buffer << ",iid=" << iid;
		buffer << ",bind=" << bind;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << props[i];
		}
		buffer << "]";
	}

public:
	int pos;
	int sid;
	int iid;
	int bind;
	std::vector<int> props;
};

struct OtherEntityPropDB
{
public:
	OtherEntityPropDB()
	{
		type = 0;
		value = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << type;
		s << value;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> type;
		s >> value;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "value", value);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "type=" << type;
		buffer << ",value=" << value;
	}

public:
	int type;
	int value;
};

struct OtherEntityStringPropDB
{
public:
	OtherEntityStringPropDB()
	{
		type = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 4;
		length += sizeof(short) + value.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << type;
		s << value;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> type;
		s >> value;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "value", value);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "type=" << type;
		buffer << ",value=" << value;
	}

public:
	int type;
	std::string value;
};

class MsgDBLoadPlayerEquipInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 104 };

	MsgDBLoadPlayerEquipInfo() :
		MessageEx(Category, Id)
	{
		errcode = 0;
		srcPid = 0;
		srcServerid = 0;
		pid = 0;
		gender = 0;
		clazz = 0;
		reborn = 0;
		level = 0;
		cloth = 0;
		weapon = 0;
		wings = 0;
		zhanli = 0;
		godLevel = 0;
		enhanceExLevel = 0;
		soulExLevel = 0;
		moshiLevel = 0;
		honor = 0;
		pkvalue = 0;
		rebornsoul = 0;
		stonepoint = 0;
		xiliansuit = 0;
		heji = 0;
		exMaxLvl = 0;
		hide_moguan = 0;
		dress_cloth = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerEquipInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 92;
		length += sizeof(short) + name.size();
		length += sizeof(short) + guild.size();
		length += sizeof(int);
		length += vcombat.size() * 4;
		length += sizeof(int);
		for (size_t i = 0; i < equips.size(); ++i)
		{
			length += equips[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < prop.size(); ++i)
		{
			length += prop[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < sprop.size(); ++i)
		{
			length += sprop[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << errcode;
		s << srcPid;
		s << srcServerid;
		s << pid;
		s << name;
		s << gender;
		s << clazz;
		s << reborn;
		s << level;
		s << cloth;
		s << weapon;
		s << wings;
		s << guild;
		s << zhanli;
		s << godLevel;
		s << enhanceExLevel;
		s << soulExLevel;
		s << moshiLevel;
		s << honor;
		s << pkvalue;
		s << rebornsoul;
		s << stonepoint;
		s << xiliansuit;
		s << heji;
		s << exMaxLvl;
		s << hide_moguan;
		s << dress_cloth;
		int vcombat_vector_size = (int)vcombat.size();
		s << vcombat_vector_size;
		if (vcombat_vector_size > 0)
		{
			for (auto it = vcombat.begin(); it != vcombat.end(); ++it)
			{
				s << *it;
			}
		}
		int equips_vector_size = (int)equips.size();
		s << equips_vector_size;
		if (equips_vector_size > 0)
		{
			for (auto it = equips.begin(); it != equips.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int prop_vector_size = (int)prop.size();
		s << prop_vector_size;
		if (prop_vector_size > 0)
		{
			for (auto it = prop.begin(); it != prop.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int sprop_vector_size = (int)sprop.size();
		s << sprop_vector_size;
		if (sprop_vector_size > 0)
		{
			for (auto it = sprop.begin(); it != sprop.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> errcode;
		s >> srcPid;
		s >> srcServerid;
		s >> pid;
		s >> name;
		s >> gender;
		s >> clazz;
		s >> reborn;
		s >> level;
		s >> cloth;
		s >> weapon;
		s >> wings;
		s >> guild;
		s >> zhanli;
		s >> godLevel;
		s >> enhanceExLevel;
		s >> soulExLevel;
		s >> moshiLevel;
		s >> honor;
		s >> pkvalue;
		s >> rebornsoul;
		s >> stonepoint;
		s >> xiliansuit;
		s >> heji;
		s >> exMaxLvl;
		s >> hide_moguan;
		s >> dress_cloth;
		int vcombat_vector_size = s.read_int32();
		vcombat.clear();
		while (vcombat_vector_size > 0)
		{
			vcombat_vector_size--;
			int val;
			s >> val;
			vcombat.push_back(val);
		}
		int equips_vector_size = s.read_int32();
		equips.clear();
		while (equips_vector_size > 0)
		{
			equips_vector_size--;
			OtherEquipInfoDB val;
			val.unserialize(s, true);
			equips.push_back(val);
		}
		int prop_vector_size = s.read_int32();
		prop.clear();
		while (prop_vector_size > 0)
		{
			prop_vector_size--;
			OtherEntityPropDB val;
			val.unserialize(s, true);
			prop.push_back(val);
		}
		int sprop_vector_size = s.read_int32();
		sprop.clear();
		while (sprop_vector_size > 0)
		{
			sprop_vector_size--;
			OtherEntityStringPropDB val;
			val.unserialize(s, true);
			sprop.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "errcode", errcode);
		lua::settable(L, -1, "srcPid", srcPid);
		lua::settable(L, -1, "srcServerid", srcServerid);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "clazz", clazz);
		lua::settable(L, -1, "reborn", reborn);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "cloth", cloth);
		lua::settable(L, -1, "weapon", weapon);
		lua::settable(L, -1, "wings", wings);
		lua::settable(L, -1, "guild", guild);
		lua::settable(L, -1, "zhanli", zhanli);
		lua::settable(L, -1, "godLevel", godLevel);
		lua::settable(L, -1, "enhanceExLevel", enhanceExLevel);
		lua::settable(L, -1, "soulExLevel", soulExLevel);
		lua::settable(L, -1, "moshiLevel", moshiLevel);
		lua::settable(L, -1, "honor", honor);
		lua::settable(L, -1, "pkvalue", pkvalue);
		lua::settable(L, -1, "rebornsoul", rebornsoul);
		lua::settable(L, -1, "stonepoint", stonepoint);
		lua::settable(L, -1, "xiliansuit", xiliansuit);
		lua::settable(L, -1, "heji", heji);
		lua::settable(L, -1, "exMaxLvl", exMaxLvl);
		lua::settable(L, -1, "hide_moguan", hide_moguan);
		lua::settable(L, -1, "dress_cloth", dress_cloth);
		lua::newtable(lua::L);
		for (size_t i = 0; i < vcombat.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, vcombat[i]);
		}
		lua::settable(L, -2, "vcombat");
		lua::newtable(lua::L);
		for (size_t i = 0; i < equips.size(); ++i)
		{
			equips[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "equips");
		lua::newtable(lua::L);
		for (size_t i = 0; i < prop.size(); ++i)
		{
			prop[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "prop");
		lua::newtable(lua::L);
		for (size_t i = 0; i < sprop.size(); ++i)
		{
			sprop[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "sprop");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",errcode=" << errcode;
		buffer << ",srcPid=" << srcPid;
		buffer << ",srcServerid=" << srcServerid;
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",gender=" << gender;
		buffer << ",clazz=" << clazz;
		buffer << ",reborn=" << reborn;
		buffer << ",level=" << level;
		buffer << ",cloth=" << cloth;
		buffer << ",weapon=" << weapon;
		buffer << ",wings=" << wings;
		buffer << ",guild=" << guild;
		buffer << ",zhanli=" << zhanli;
		buffer << ",godLevel=" << godLevel;
		buffer << ",enhanceExLevel=" << enhanceExLevel;
		buffer << ",soulExLevel=" << soulExLevel;
		buffer << ",moshiLevel=" << moshiLevel;
		buffer << ",honor=" << honor;
		buffer << ",pkvalue=" << pkvalue;
		buffer << ",rebornsoul=" << rebornsoul;
		buffer << ",stonepoint=" << stonepoint;
		buffer << ",xiliansuit=" << xiliansuit;
		buffer << ",heji=" << heji;
		buffer << ",exMaxLvl=" << exMaxLvl;
		buffer << ",hide_moguan=" << hide_moguan;
		buffer << ",dress_cloth=" << dress_cloth;
		buffer << ",vcombat=[";
		for (size_t i = 0; i < vcombat.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << vcombat[i];
		}
		buffer << "]";
		buffer << ",equips=[";
		for (size_t i = 0; i < equips.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			equips[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",prop=[";
		for (size_t i = 0; i < prop.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			prop[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",sprop=[";
		for (size_t i = 0; i < sprop.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			sprop[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	short errcode;
	int srcPid;
	int srcServerid;
	int pid;
	std::string name;
	char gender;
	char clazz;
	int reborn;
	int level;
	int cloth;
	int weapon;
	int wings;
	std::string guild;
	int zhanli;
	int godLevel;
	int enhanceExLevel;
	int soulExLevel;
	int moshiLevel;
	int honor;
	int pkvalue;
	int rebornsoul;
	int stonepoint;
	int xiliansuit;
	int heji;
	int exMaxLvl;
	int hide_moguan;
	int dress_cloth;
	std::vector<int> vcombat;
	std::vector<OtherEquipInfoDB> equips;
	std::vector<OtherEntityPropDB> prop;
	std::vector<OtherEntityStringPropDB> sprop;
};

struct DBOtherItemProp
{
public:
	DBOtherItemProp()
	{
		idx = 0;
		data = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << idx;
		s << data;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> idx;
		s >> data;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "data", data);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "idx=" << idx;
		buffer << ",data=" << data;
	}

public:
	int idx;
	int data;
};

struct DBOtherPlayerEquip
{
public:
	DBOtherPlayerEquip()
	{
		sid = 0;
		iid = 0;
		pos = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 12;
		length += sizeof(short) + firstowner.size();
		length += sizeof(short) + appraiser.size();
		length += ex ? sizeof(int) : sizeof(short);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(ex);
		}
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << sid;
		s << iid;
		s << pos;
		s << firstowner;
		s << appraiser;
		int props_vector_size = ex ? (int)props.size() : (short)props.size();
		if (ex)
		{
			s << props_vector_size;
		}
		else
		{
			s << (short)props_vector_size;
		}
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, ex);
			}
		}
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> sid;
		s >> iid;
		s >> pos;
		s >> firstowner;
		s >> appraiser;
		int props_vector_size = ex ? s.read_int32() : s.read_int16();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBOtherItemProp val;
			val.unserialize(s, ex);
			props.push_back(val);
		}
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "iid", iid);
		lua::settable(L, -1, "pos", pos);
		lua::settable(L, -1, "firstowner", firstowner);
		lua::settable(L, -1, "appraiser", appraiser);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "sid=" << sid;
		buffer << ",iid=" << iid;
		buffer << ",pos=" << pos;
		buffer << ",firstowner=" << firstowner;
		buffer << ",appraiser=" << appraiser;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int sid;
	int iid;
	int pos;
	std::string firstowner;
	std::string appraiser;
	std::vector<DBOtherItemProp> props;
};

struct DBOtherPlayerSkill
{
public:
	DBOtherPlayerSkill()
	{
		id = 0;
		level = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << id;
		s << level;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> id;
		s >> level;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "id", id);
		lua::settable(L, -1, "level", level);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "id=" << id;
		buffer << ",level=" << level;
	}

public:
	int id;
	int level;
};

class MsgDBLoadOtherPlayerInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 107 };

	MsgDBLoadOtherPlayerInfo() :
		MessageEx(Category, Id)
	{
		srcPid = 0;
		srcServerid = 0;
		pid = 0;
		gender = 0;
		level = 0;
		exp = 0;
		cloth = 0;
		weapon = 0;
		wings = 0;
		zhanli = 0;
		lingwen = 0;
		guildpost = 0;
		job = 0;
		reborn = 0;
		hunhuan = 0;
		jingling = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadOtherPlayerInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 65;
		length += sizeof(short) + name.size();
		length += sizeof(short) + guild.size();
		length += sizeof(int);
		for (size_t i = 0; i < equips.size(); ++i)
		{
			length += equips[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < prop.size(); ++i)
		{
			length += prop[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < sprop.size(); ++i)
		{
			length += sprop[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < skill.size(); ++i)
		{
			length += skill[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << srcPid;
		s << srcServerid;
		s << pid;
		s << name;
		s << gender;
		s << level;
		s << exp;
		s << cloth;
		s << weapon;
		s << wings;
		s << guild;
		s << zhanli;
		s << lingwen;
		s << guildpost;
		s << job;
		s << reborn;
		s << hunhuan;
		s << jingling;
		int equips_vector_size = (int)equips.size();
		s << equips_vector_size;
		if (equips_vector_size > 0)
		{
			for (auto it = equips.begin(); it != equips.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int prop_vector_size = (int)prop.size();
		s << prop_vector_size;
		if (prop_vector_size > 0)
		{
			for (auto it = prop.begin(); it != prop.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int sprop_vector_size = (int)sprop.size();
		s << sprop_vector_size;
		if (sprop_vector_size > 0)
		{
			for (auto it = sprop.begin(); it != sprop.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int skill_vector_size = (int)skill.size();
		s << skill_vector_size;
		if (skill_vector_size > 0)
		{
			for (auto it = skill.begin(); it != skill.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> srcPid;
		s >> srcServerid;
		s >> pid;
		s >> name;
		s >> gender;
		s >> level;
		s >> exp;
		s >> cloth;
		s >> weapon;
		s >> wings;
		s >> guild;
		s >> zhanli;
		s >> lingwen;
		s >> guildpost;
		s >> job;
		s >> reborn;
		s >> hunhuan;
		s >> jingling;
		int equips_vector_size = s.read_int32();
		equips.clear();
		while (equips_vector_size > 0)
		{
			equips_vector_size--;
			DBOtherPlayerEquip val;
			val.unserialize(s, true);
			equips.push_back(val);
		}
		int prop_vector_size = s.read_int32();
		prop.clear();
		while (prop_vector_size > 0)
		{
			prop_vector_size--;
			OtherEntityPropDB val;
			val.unserialize(s, true);
			prop.push_back(val);
		}
		int sprop_vector_size = s.read_int32();
		sprop.clear();
		while (sprop_vector_size > 0)
		{
			sprop_vector_size--;
			OtherEntityStringPropDB val;
			val.unserialize(s, true);
			sprop.push_back(val);
		}
		int skill_vector_size = s.read_int32();
		skill.clear();
		while (skill_vector_size > 0)
		{
			skill_vector_size--;
			DBOtherPlayerSkill val;
			val.unserialize(s, true);
			skill.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "srcPid", srcPid);
		lua::settable(L, -1, "srcServerid", srcServerid);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "exp", exp);
		lua::settable(L, -1, "cloth", cloth);
		lua::settable(L, -1, "weapon", weapon);
		lua::settable(L, -1, "wings", wings);
		lua::settable(L, -1, "guild", guild);
		lua::settable(L, -1, "zhanli", zhanli);
		lua::settable(L, -1, "lingwen", lingwen);
		lua::settable(L, -1, "guildpost", guildpost);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "reborn", reborn);
		lua::settable(L, -1, "hunhuan", hunhuan);
		lua::settable(L, -1, "jingling", jingling);
		lua::newtable(lua::L);
		for (size_t i = 0; i < equips.size(); ++i)
		{
			equips[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "equips");
		lua::newtable(lua::L);
		for (size_t i = 0; i < prop.size(); ++i)
		{
			prop[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "prop");
		lua::newtable(lua::L);
		for (size_t i = 0; i < sprop.size(); ++i)
		{
			sprop[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "sprop");
		lua::newtable(lua::L);
		for (size_t i = 0; i < skill.size(); ++i)
		{
			skill[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "skill");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",srcPid=" << srcPid;
		buffer << ",srcServerid=" << srcServerid;
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",gender=" << gender;
		buffer << ",level=" << level;
		buffer << ",exp=" << exp;
		buffer << ",cloth=" << cloth;
		buffer << ",weapon=" << weapon;
		buffer << ",wings=" << wings;
		buffer << ",guild=" << guild;
		buffer << ",zhanli=" << zhanli;
		buffer << ",lingwen=" << lingwen;
		buffer << ",guildpost=" << guildpost;
		buffer << ",job=" << job;
		buffer << ",reborn=" << reborn;
		buffer << ",hunhuan=" << hunhuan;
		buffer << ",jingling=" << jingling;
		buffer << ",equips=[";
		for (size_t i = 0; i < equips.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			equips[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",prop=[";
		for (size_t i = 0; i < prop.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			prop[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",sprop=[";
		for (size_t i = 0; i < sprop.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			sprop[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",skill=[";
		for (size_t i = 0; i < skill.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			skill[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int srcPid;
	int srcServerid;
	int pid;
	std::string name;
	char gender;
	int level;
	long long exp;
	int cloth;
	int weapon;
	int wings;
	std::string guild;
	int zhanli;
	int lingwen;
	int guildpost;
	int job;
	int reborn;
	int hunhuan;
	int jingling;
	std::vector<DBOtherPlayerEquip> equips;
	std::vector<OtherEntityPropDB> prop;
	std::vector<OtherEntityStringPropDB> sprop;
	std::vector<DBOtherPlayerSkill> skill;
};

struct DBSkillExp
{
public:
	DBSkillExp()
	{
		sid = 0;
		exp = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << sid;
		s << exp;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> sid;
		s >> exp;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "sid", sid);
		lua::settable(L, -1, "exp", exp);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "sid=" << sid;
		buffer << ",exp=" << exp;
	}

public:
	int sid;
	int exp;
};

class MsgDBUpdateSomeSkillExp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 108 };

	MsgDBUpdateSomeSkillExp() :
		MessageEx(Category, Id)
	{
		pid = 0;
		osid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateSomeSkillExp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < skillinfo.size(); ++i)
		{
			length += skillinfo[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << osid;
		int skillinfo_vector_size = (int)skillinfo.size();
		s << skillinfo_vector_size;
		if (skillinfo_vector_size > 0)
		{
			for (auto it = skillinfo.begin(); it != skillinfo.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> osid;
		int skillinfo_vector_size = s.read_int32();
		skillinfo.clear();
		while (skillinfo_vector_size > 0)
		{
			skillinfo_vector_size--;
			DBSkillExp val;
			val.unserialize(s, true);
			skillinfo.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "osid", osid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < skillinfo.size(); ++i)
		{
			skillinfo[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "skillinfo");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",osid=" << osid;
		buffer << ",skillinfo=[";
		for (size_t i = 0; i < skillinfo.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			skillinfo[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	int osid;
	std::vector<DBSkillExp> skillinfo;
};

class MsgDBUpdatePlayerClass : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 109 };

	MsgDBUpdatePlayerClass() :
		MessageEx(Category, Id)
	{
		pid = 0;
		job = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerClass";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << job;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> job;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "job", job);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",job=" << job;
	}

public:
	int pid;
	int job;
};

class MsgDBUpdatePlayerGender : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 110 };

	MsgDBUpdatePlayerGender() :
		MessageEx(Category, Id)
	{
		pid = 0;
		gender = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerGender";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 5;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << gender;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> gender;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "gender", gender);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",gender=" << gender;
	}

public:
	int pid; //Íæ¼ÒID 
	char gender;
};

class MsgLoadPlayerBaseInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 111 };

	MsgLoadPlayerBaseInfo() :
		MessageEx(Category, Id)
	{
		srcPid = 0;
		srcServerid = 0;
		pid = 0;
		gender = 0;
		job = 0;
		weapon = 0;
		dressWeapon = 0;
		cloth = 0;
		dressCloth = 0;
		hat = 0;
		shield = 0;
		guardLevel = 0;
		hunhuan = 0;
		jingling = 0;
	}

	virtual const char *getName() const
	{
		return "MsgLoadPlayerBaseInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 56;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << srcPid;
		s << srcServerid;
		s << pid;
		s << gender;
		s << job;
		s << weapon;
		s << dressWeapon;
		s << cloth;
		s << dressCloth;
		s << hat;
		s << shield;
		s << guardLevel;
		s << hunhuan;
		s << jingling;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> srcPid;
		s >> srcServerid;
		s >> pid;
		s >> gender;
		s >> job;
		s >> weapon;
		s >> dressWeapon;
		s >> cloth;
		s >> dressCloth;
		s >> hat;
		s >> shield;
		s >> guardLevel;
		s >> hunhuan;
		s >> jingling;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "srcPid", srcPid);
		lua::settable(L, -1, "srcServerid", srcServerid);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "weapon", weapon);
		lua::settable(L, -1, "dressWeapon", dressWeapon);
		lua::settable(L, -1, "cloth", cloth);
		lua::settable(L, -1, "dressCloth", dressCloth);
		lua::settable(L, -1, "hat", hat);
		lua::settable(L, -1, "shield", shield);
		lua::settable(L, -1, "guardLevel", guardLevel);
		lua::settable(L, -1, "hunhuan", hunhuan);
		lua::settable(L, -1, "jingling", jingling);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",srcPid=" << srcPid;
		buffer << ",srcServerid=" << srcServerid;
		buffer << ",pid=" << pid;
		buffer << ",gender=" << gender;
		buffer << ",job=" << job;
		buffer << ",weapon=" << weapon;
		buffer << ",dressWeapon=" << dressWeapon;
		buffer << ",cloth=" << cloth;
		buffer << ",dressCloth=" << dressCloth;
		buffer << ",hat=" << hat;
		buffer << ",shield=" << shield;
		buffer << ",guardLevel=" << guardLevel;
		buffer << ",hunhuan=" << hunhuan;
		buffer << ",jingling=" << jingling;
	}

public:
	int srcPid;
	int srcServerid;
	int pid;
	int gender;
	int job;
	int weapon;
	int dressWeapon;
	int cloth;
	int dressCloth;
	int hat;
	int shield;
	int guardLevel;
	int hunhuan;
	int jingling;
};

class MsgDBUpdatePlayerAllProp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 112 };

	MsgDBUpdatePlayerAllProp() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdatePlayerAllProp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			exData val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	std::vector<exData> props;
};

struct DBEventData
{
public:
	DBEventData()
	{
		eid = 0;
		tindex = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	size_t getLength(bool ex) const
	{
		return 20;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << eid;
		s << tindex;
		s << datax;
		s << datay;
		s << dataz;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> eid;
		s >> tindex;
		s >> datax;
		s >> datay;
		s >> dataz;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "eid", eid);
		lua::settable(L, -1, "tindex", tindex);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "eid=" << eid;
		buffer << ",tindex=" << tindex;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
	}

public:
	int eid;
	int tindex;
	int datax;
	int datay;
	int dataz;
};

class MsgDBSavePlayerAllEvent : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_PLAYER, Id = 113 };

	MsgDBSavePlayerAllEvent() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBSavePlayerAllEvent";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBEventData val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	std::vector<DBEventData> props;
};

#endif	//_DB_MSG_PLAYER_H_INCLUDED
