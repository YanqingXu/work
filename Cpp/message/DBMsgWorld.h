//
//Generated by lua
//2009-2012	(C) XianFeng Inc. Reserved
//

#ifndef _DB_MSG_WORLD_H_INCLUDED
#define _DB_MSG_WORLD_H_INCLUDED

#include "category.h"
#include "common/MessageEx.h"

struct DBWorldData
{
public:
	DBWorldData()
	{
		wid = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
		uptime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 20;
		length += sizeof(short) + datas.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << wid;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		s << uptime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> wid;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		s >> uptime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "wid", wid);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
		lua::settable(L, -1, "uptime", uptime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "wid=" << wid;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
		buffer << ",uptime=" << uptime;
	}

public:
	int wid;
	int datax;
	int datay;
	int dataz;
	std::string datas;
	int uptime;
};

class MsgDBLoadWorldData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 1 };

	MsgDBLoadWorldData() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadWorldData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < data.size(); ++i)
		{
			length += data[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int data_vector_size = (int)data.size();
		s << data_vector_size;
		if (data_vector_size > 0)
		{
			for (auto it = data.begin(); it != data.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int data_vector_size = s.read_int32();
		data.clear();
		while (data_vector_size > 0)
		{
			data_vector_size--;
			DBWorldData val;
			val.unserialize(s, true);
			data.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < data.size(); ++i)
		{
			data[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "data");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",data=[";
		for (size_t i = 0; i < data.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			data[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBWorldData> data;
};

class MsgDBUpdWorldData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 2 };

	MsgDBUpdWorldData() :
		MessageEx(Category, Id)
	{
		wid = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdWorldData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 16;
		length += sizeof(short) + datas.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << wid;
		s << datax;
		s << datay;
		s << dataz;
		s << datas;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> wid;
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> datas;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "wid", wid);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "datas", datas);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",wid=" << wid;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",datas=" << datas;
	}

public:
	int wid;
	int datax;
	int datay;
	int dataz;
	std::string datas;
};

class MsgDBServerID : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 3 };

	MsgDBServerID() :
		MessageEx(Category, Id)
	{
		server_id = 0;
		register_server_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBServerID";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 6;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << server_id;
		s << register_server_id;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> server_id;
		s >> register_server_id;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "server_id", server_id);
		lua::settable(L, -1, "register_server_id", register_server_id);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",server_id=" << server_id;
		buffer << ",register_server_id=" << register_server_id;
	}

public:
	int server_id;
	short register_server_id;
};

struct DBChannelProp
{
public:
	DBChannelProp()
	{
		cid = 0;
		id = 0;
		val = 0;
	}

	size_t getLength(bool ex) const
	{
		return 12;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << cid;
		s << id;
		s << val;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> cid;
		s >> id;
		s >> val;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "id", id);
		lua::settable(L, -1, "val", val);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "cid=" << cid;
		buffer << ",id=" << id;
		buffer << ",val=" << val;
	}

public:
	int cid;
	int id;
	int val;
};

class MsgDBLoadChannelProps : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 4 };

	MsgDBLoadChannelProps() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadChannelProps";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			DBChannelProp val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBChannelProp> props;
};

class MsgDBUpdateChannelProp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 5 };

	MsgDBUpdateChannelProp() :
		MessageEx(Category, Id)
	{
		cid = 0;
		id = 0;
		val = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateChannelProp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 12;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << cid;
		s << id;
		s << val;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> cid;
		s >> id;
		s >> val;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "cid", cid);
		lua::settable(L, -1, "id", id);
		lua::settable(L, -1, "val", val);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",cid=" << cid;
		buffer << ",id=" << id;
		buffer << ",val=" << val;
	}

public:
	int cid;
	int id;
	int val;
};

struct DBSwitch
{
public:
	DBSwitch()
	{
		id = 0;
		sub_id = 0;
		disabled = 0;
	}

	size_t getLength(bool ex) const
	{
		return 9;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << id;
		s << sub_id;
		s << disabled;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> id;
		s >> sub_id;
		s >> disabled;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "id", id);
		lua::settable(L, -1, "sub_id", sub_id);
		lua::settable(L, -1, "disabled", disabled);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "id=" << id;
		buffer << ",sub_id=" << sub_id;
		buffer << ",disabled=" << disabled;
	}

public:
	int id;
	int sub_id;
	char disabled;
};

class MsgDBLoadSwitch : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 108 };

	MsgDBLoadSwitch() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadSwitch";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < switchs.size(); ++i)
		{
			length += switchs[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int switchs_vector_size = (int)switchs.size();
		s << switchs_vector_size;
		if (switchs_vector_size > 0)
		{
			for (auto it = switchs.begin(); it != switchs.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int switchs_vector_size = s.read_int32();
		switchs.clear();
		while (switchs_vector_size > 0)
		{
			switchs_vector_size--;
			DBSwitch val;
			val.unserialize(s, true);
			switchs.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < switchs.size(); ++i)
		{
			switchs[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "switchs");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",switchs=[";
		for (size_t i = 0; i < switchs.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			switchs[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBSwitch> switchs;
};

class MsgDBEnableSwitch : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 109 };

	MsgDBEnableSwitch() :
		MessageEx(Category, Id)
	{
		id = 0;
		sub_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBEnableSwitch";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << id;
		s << sub_id;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> id;
		s >> sub_id;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "id", id);
		lua::settable(L, -1, "sub_id", sub_id);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",id=" << id;
		buffer << ",sub_id=" << sub_id;
	}

public:
	int id;
	int sub_id;
};

class MsgDBDisableSwitch : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 110 };

	MsgDBDisableSwitch() :
		MessageEx(Category, Id)
	{
		id = 0;
		sub_id = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBDisableSwitch";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << id;
		s << sub_id;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> id;
		s >> sub_id;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "id", id);
		lua::settable(L, -1, "sub_id", sub_id);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",id=" << id;
		buffer << ",sub_id=" << sub_id;
	}

public:
	int id;
	int sub_id;
};

struct DBWorldPlayerExData
{
public:
	DBWorldPlayerExData()
	{
		data = 0;
		pid = 0;
		gender = 0;
		clazz = 0;
		reborn = 0;
		level = 0;
		zhanli = 0;
		weapon = 0;
		cloth = 0;
		wings = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 34;
		length += sizeof(short) + name.size();
		length += sizeof(short) + guild.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << data;
		s << pid;
		s << name;
		s << gender;
		s << clazz;
		s << reborn;
		s << level;
		s << guild;
		s << zhanli;
		s << weapon;
		s << cloth;
		s << wings;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> data;
		s >> pid;
		s >> name;
		s >> gender;
		s >> clazz;
		s >> reborn;
		s >> level;
		s >> guild;
		s >> zhanli;
		s >> weapon;
		s >> cloth;
		s >> wings;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "data", data);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "clazz", clazz);
		lua::settable(L, -1, "reborn", reborn);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "guild", guild);
		lua::settable(L, -1, "zhanli", zhanli);
		lua::settable(L, -1, "weapon", weapon);
		lua::settable(L, -1, "cloth", cloth);
		lua::settable(L, -1, "wings", wings);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "data=" << data;
		buffer << ",pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",gender=" << gender;
		buffer << ",clazz=" << clazz;
		buffer << ",reborn=" << reborn;
		buffer << ",level=" << level;
		buffer << ",guild=" << guild;
		buffer << ",zhanli=" << zhanli;
		buffer << ",weapon=" << weapon;
		buffer << ",cloth=" << cloth;
		buffer << ",wings=" << wings;
	}

public:
	int data;
	int pid;
	std::string name;
	char gender;
	char clazz;
	int reborn;
	int level;
	std::string guild;
	int zhanli;
	int weapon;
	int cloth;
	int wings;
};

class MsgDBLoadTeams : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 124 };

	MsgDBLoadTeams() :
		MessageEx(Category, Id)
	{
		type = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadTeams";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < datas.size(); ++i)
		{
			length += datas[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << type;
		int datas_vector_size = (int)datas.size();
		s << datas_vector_size;
		if (datas_vector_size > 0)
		{
			for (auto it = datas.begin(); it != datas.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> type;
		int datas_vector_size = s.read_int32();
		datas.clear();
		while (datas_vector_size > 0)
		{
			datas_vector_size--;
			DBWorldPlayerExData val;
			val.unserialize(s, true);
			datas.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::newtable(lua::L);
		for (size_t i = 0; i < datas.size(); ++i)
		{
			datas[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "datas");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",type=" << type;
		buffer << ",datas=[";
		for (size_t i = 0; i < datas.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			datas[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int type;
	std::vector<DBWorldPlayerExData> datas;
};

struct DBWorldFireworks
{
public:
	DBWorldFireworks()
	{
		pid = 0;
		bless = 0;
		reborn = 0;
		lvl = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 16;
		length += sizeof(short) + name.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << name;
		s << bless;
		s << reborn;
		s << lvl;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> name;
		s >> bless;
		s >> reborn;
		s >> lvl;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "bless", bless);
		lua::settable(L, -1, "reborn", reborn);
		lua::settable(L, -1, "lvl", lvl);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",bless=" << bless;
		buffer << ",reborn=" << reborn;
		buffer << ",lvl=" << lvl;
	}

public:
	int pid;
	std::string name;
	int bless;
	int reborn;
	int lvl;
};

struct DBPlayerReward
{
public:
	DBPlayerReward()
	{
		idx = 0;
		type = 0;
		rewardid = 0;
		endtime = 0;
	}

	size_t getLength(bool ex) const
	{
		return 16;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << idx;
		s << type;
		s << rewardid;
		s << endtime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> idx;
		s >> type;
		s >> rewardid;
		s >> endtime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "rewardid", rewardid);
		lua::settable(L, -1, "endtime", endtime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "idx=" << idx;
		buffer << ",type=" << type;
		buffer << ",rewardid=" << rewardid;
		buffer << ",endtime=" << endtime;
	}

public:
	int idx;
	int type;
	int rewardid;
	int endtime;
};

class MsgDBLoadAuthRewardIDRequest : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 199 };

	MsgDBLoadAuthRewardIDRequest() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadAuthRewardIDRequest";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		length += rewardid.size() * 4;
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int rewardid_vector_size = (int)rewardid.size();
		s << rewardid_vector_size;
		if (rewardid_vector_size > 0)
		{
			for (auto it = rewardid.begin(); it != rewardid.end(); ++it)
			{
				s << *it;
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int rewardid_vector_size = s.read_int32();
		rewardid.clear();
		while (rewardid_vector_size > 0)
		{
			rewardid_vector_size--;
			int val;
			s >> val;
			rewardid.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < rewardid.size(); ++i)
		{
			lua::settable(L, -1, (int)i+1, rewardid[i]);
		}
		lua::settable(L, -2, "rewardid");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",rewardid=[";
		for (size_t i = 0; i < rewardid.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << rewardid[i];
		}
		buffer << "]";
	}

public:
	std::vector<int> rewardid;
};

class MsgDBLoadPlayerRewardData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 200 };

	MsgDBLoadPlayerRewardData() :
		MessageEx(Category, Id)
	{
		pid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerRewardData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < datas.size(); ++i)
		{
			length += datas[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		int datas_vector_size = (int)datas.size();
		s << datas_vector_size;
		if (datas_vector_size > 0)
		{
			for (auto it = datas.begin(); it != datas.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		int datas_vector_size = s.read_int32();
		datas.clear();
		while (datas_vector_size > 0)
		{
			datas_vector_size--;
			DBPlayerReward val;
			val.unserialize(s, true);
			datas.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < datas.size(); ++i)
		{
			datas[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "datas");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",datas=[";
		for (size_t i = 0; i < datas.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			datas[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int pid;
	std::vector<DBPlayerReward> datas;
};

class MsgDBInsertPlayerRewardData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 201 };

	MsgDBInsertPlayerRewardData() :
		MessageEx(Category, Id)
	{
		pid = 0;
		idx = 0;
		type = 0;
		rewardid = 0;
		endtime = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBInsertPlayerRewardData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 20;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << idx;
		s << type;
		s << rewardid;
		s << endtime;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> idx;
		s >> type;
		s >> rewardid;
		s >> endtime;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "idx", idx);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "rewardid", rewardid);
		lua::settable(L, -1, "endtime", endtime);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",idx=" << idx;
		buffer << ",type=" << type;
		buffer << ",rewardid=" << rewardid;
		buffer << ",endtime=" << endtime;
	}

public:
	int pid;
	int idx;
	int type;
	int rewardid;
	int endtime;
};

class MsgDBDeletePlayerRewardData : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 202 };

	MsgDBDeletePlayerRewardData() :
		MessageEx(Category, Id)
	{
		pid = 0;
		idx = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBDeletePlayerRewardData";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 8;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << idx;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> idx;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "idx", idx);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",idx=" << idx;
	}

public:
	int pid;
	int idx;
};

struct DBPlayersqldata
{
public:
	DBPlayersqldata()
	{
		pid = 0;
		datax = 0;
		datay = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 12;
		length += sizeof(short) + name.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << name;
		s << datax;
		s << datay;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> name;
		s >> datax;
		s >> datay;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
	}

public:
	int pid;
	std::string name;
	int datax;
	int datay;
};

class MsgDBLoadPlayerDataBySql : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 300 };

	MsgDBLoadPlayerDataBySql() :
		MessageEx(Category, Id)
	{
		dx = 0;
		dy = 0;
		dz = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPlayerDataBySql";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 12;
		length += sizeof(short) + sqlstr.size();
		length += sizeof(int);
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			length += loaddata[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << dx;
		s << dy;
		s << dz;
		s << sqlstr;
		int loaddata_vector_size = (int)loaddata.size();
		s << loaddata_vector_size;
		if (loaddata_vector_size > 0)
		{
			for (auto it = loaddata.begin(); it != loaddata.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> dx;
		s >> dy;
		s >> dz;
		s >> sqlstr;
		int loaddata_vector_size = s.read_int32();
		loaddata.clear();
		while (loaddata_vector_size > 0)
		{
			loaddata_vector_size--;
			DBPlayersqldata val;
			val.unserialize(s, true);
			loaddata.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "dx", dx);
		lua::settable(L, -1, "dy", dy);
		lua::settable(L, -1, "dz", dz);
		lua::settable(L, -1, "sqlstr", sqlstr);
		lua::newtable(lua::L);
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			loaddata[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "loaddata");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",dx=" << dx;
		buffer << ",dy=" << dy;
		buffer << ",dz=" << dz;
		buffer << ",sqlstr=" << sqlstr;
		buffer << ",loaddata=[";
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			loaddata[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int dx;
	int dy;
	int dz;
	std::string sqlstr;
	std::vector<DBPlayersqldata> loaddata;
};

struct DBPlayerInfo
{
public:
	DBPlayerInfo()
	{
		pid = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 4;
		length += sizeof(short) + name.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << name;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> name;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",name=" << name;
	}

public:
	int pid;
	std::string name;
};

class MsgDBLoadNextIDs : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 312 };

	MsgDBLoadNextIDs() :
		MessageEx(Category, Id)
	{
		next_pid = 0;
		next_gid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadNextIDs";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < infos.size(); ++i)
		{
			length += infos[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << next_pid;
		s << next_gid;
		int infos_vector_size = (int)infos.size();
		s << infos_vector_size;
		if (infos_vector_size > 0)
		{
			for (auto it = infos.begin(); it != infos.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> next_pid;
		s >> next_gid;
		int infos_vector_size = s.read_int32();
		infos.clear();
		while (infos_vector_size > 0)
		{
			infos_vector_size--;
			DBPlayerInfo val;
			val.unserialize(s, true);
			infos.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "next_pid", next_pid);
		lua::settable(L, -1, "next_gid", next_gid);
		lua::newtable(lua::L);
		for (size_t i = 0; i < infos.size(); ++i)
		{
			infos[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "infos");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",next_pid=" << next_pid;
		buffer << ",next_gid=" << next_gid;
		buffer << ",infos=[";
		for (size_t i = 0; i < infos.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			infos[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int next_pid;
	int next_gid;
	std::vector<DBPlayerInfo> infos;
};

class MsgDBLoadKfhdXfdb : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 313 };

	MsgDBLoadKfhdXfdb() :
		MessageEx(Category, Id)
	{
		index = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadKfhdXfdb";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			length += loaddata[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << index;
		int loaddata_vector_size = (int)loaddata.size();
		s << loaddata_vector_size;
		if (loaddata_vector_size > 0)
		{
			for (auto it = loaddata.begin(); it != loaddata.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> index;
		int loaddata_vector_size = s.read_int32();
		loaddata.clear();
		while (loaddata_vector_size > 0)
		{
			loaddata_vector_size--;
			DBPlayersqldata val;
			val.unserialize(s, true);
			loaddata.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "index", index);
		lua::newtable(lua::L);
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			loaddata[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "loaddata");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",index=" << index;
		buffer << ",loaddata=[";
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			loaddata[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int index;
	std::vector<DBPlayersqldata> loaddata;
};

class MsgDBLoadKfhdXfph : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 314 };

	MsgDBLoadKfhdXfph() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadKfhdXfph";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			length += loaddata[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int loaddata_vector_size = (int)loaddata.size();
		s << loaddata_vector_size;
		if (loaddata_vector_size > 0)
		{
			for (auto it = loaddata.begin(); it != loaddata.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int loaddata_vector_size = s.read_int32();
		loaddata.clear();
		while (loaddata_vector_size > 0)
		{
			loaddata_vector_size--;
			DBPlayersqldata val;
			val.unserialize(s, true);
			loaddata.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			loaddata[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "loaddata");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",loaddata=[";
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			loaddata[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBPlayersqldata> loaddata;
};

struct DBWorldActivityGuess
{
public:
	DBWorldActivityGuess()
	{
		pid = 0;
		datax = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 8;
		length += sizeof(short) + name.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << name;
		s << datax;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> name;
		s >> datax;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "datax", datax);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",datax=" << datax;
	}

public:
	int pid;
	std::string name;
	int datax;
};

class MsgDBActivityQmjc : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 317 };

	MsgDBActivityQmjc() :
		MessageEx(Category, Id)
	{
		guessResult = 0;
		guessTime = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBActivityQmjc";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 8;
		length += sizeof(int);
		for (size_t i = 0; i < datas.size(); ++i)
		{
			length += datas[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << guessResult;
		s << guessTime;
		int datas_vector_size = (int)datas.size();
		s << datas_vector_size;
		if (datas_vector_size > 0)
		{
			for (auto it = datas.begin(); it != datas.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> guessResult;
		s >> guessTime;
		int datas_vector_size = s.read_int32();
		datas.clear();
		while (datas_vector_size > 0)
		{
			datas_vector_size--;
			DBWorldActivityGuess val;
			val.unserialize(s, true);
			datas.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "guessResult", guessResult);
		lua::settable(L, -1, "guessTime", guessTime);
		lua::newtable(lua::L);
		for (size_t i = 0; i < datas.size(); ++i)
		{
			datas[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "datas");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",guessResult=" << guessResult;
		buffer << ",guessTime=" << guessTime;
		buffer << ",datas=[";
		for (size_t i = 0; i < datas.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			datas[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int guessResult;
	int guessTime;
	std::vector<DBWorldActivityGuess> datas;
};

class MsgDBLoadWorldContinueDayPlayerNum : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 319 };

	MsgDBLoadWorldContinueDayPlayerNum() :
		MessageEx(Category, Id)
	{
		type = 0;
		num = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadWorldContinueDayPlayerNum";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 6;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << type;
		s << num;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> type;
		s >> num;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "num", num);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",type=" << type;
		buffer << ",num=" << num;
	}

public:
	short type;
	int num;
};

struct DBCreateRoleCode
{
public:
	DBCreateRoleCode()
	{
		spid = 0;
		dpid = 0;
		state = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 12;
		length += sizeof(short) + code.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << code;
		s << spid;
		s << dpid;
		s << state;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> code;
		s >> spid;
		s >> dpid;
		s >> state;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "code", code);
		lua::settable(L, -1, "spid", spid);
		lua::settable(L, -1, "dpid", dpid);
		lua::settable(L, -1, "state", state);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "code=" << code;
		buffer << ",spid=" << spid;
		buffer << ",dpid=" << dpid;
		buffer << ",state=" << state;
	}

public:
	std::string code;
	int spid;
	int dpid;
	int state;
};

class MsgDBCreateRoleCodeLoad : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 325 };

	MsgDBCreateRoleCodeLoad() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBCreateRoleCodeLoad";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			length += loaddata[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int loaddata_vector_size = (int)loaddata.size();
		s << loaddata_vector_size;
		if (loaddata_vector_size > 0)
		{
			for (auto it = loaddata.begin(); it != loaddata.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int loaddata_vector_size = s.read_int32();
		loaddata.clear();
		while (loaddata_vector_size > 0)
		{
			loaddata_vector_size--;
			DBCreateRoleCode val;
			val.unserialize(s, true);
			loaddata.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			loaddata[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "loaddata");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",loaddata=[";
		for (size_t i = 0; i < loaddata.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			loaddata[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBCreateRoleCode> loaddata;
};

class MsgDBCreateRoleCodeAdd : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 326 };

	MsgDBCreateRoleCodeAdd() :
		MessageEx(Category, Id)
	{
		spid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBCreateRoleCodeAdd";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(short) + code.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << code;
		s << spid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> code;
		s >> spid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "code", code);
		lua::settable(L, -1, "spid", spid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",code=" << code;
		buffer << ",spid=" << spid;
	}

public:
	std::string code;
	int spid;
};

class MsgDBCreateRoleCodeUse : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 327 };

	MsgDBCreateRoleCodeUse() :
		MessageEx(Category, Id)
	{
		dpid = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBCreateRoleCodeUse";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(short) + code.size();
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << code;
		s << dpid;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> code;
		s >> dpid;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "code", code);
		lua::settable(L, -1, "dpid", dpid);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",code=" << code;
		buffer << ",dpid=" << dpid;
	}

public:
	std::string code;
	int dpid;
};

class MsgDBDeleteSomeOneProp : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 338 };

	MsgDBDeleteSomeOneProp() :
		MessageEx(Category, Id)
	{
		prop = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBDeleteSomeOneProp";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength() + 4;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << prop;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> prop;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "prop", prop);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",prop=" << prop;
	}

public:
	int prop;
};

struct DBLoadTgmjTower
{
public:
	DBLoadTgmjTower()
	{
		pid = 0;
		level = 0;
		round = 0;
		job = 0;
		reborn = 0;
		gender = 0;
		weapon = 0;
		cloth = 0;
		wings = 0;
		viplevel = 0;
		fishioncloth = 0;
		ranktime = 0;
		fashionweapon = 0;
		wing = 0;
		shield = 0;
		lingwen = 0;
		fabao = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 68;
		length += sizeof(short) + name.size();
		length += sizeof(short) + guildname.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << name;
		s << level;
		s << round;
		s << job;
		s << reborn;
		s << gender;
		s << guildname;
		s << weapon;
		s << cloth;
		s << wings;
		s << viplevel;
		s << fishioncloth;
		s << ranktime;
		s << fashionweapon;
		s << wing;
		s << shield;
		s << lingwen;
		s << fabao;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> name;
		s >> level;
		s >> round;
		s >> job;
		s >> reborn;
		s >> gender;
		s >> guildname;
		s >> weapon;
		s >> cloth;
		s >> wings;
		s >> viplevel;
		s >> fishioncloth;
		s >> ranktime;
		s >> fashionweapon;
		s >> wing;
		s >> shield;
		s >> lingwen;
		s >> fabao;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "round", round);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "reborn", reborn);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "guildname", guildname);
		lua::settable(L, -1, "weapon", weapon);
		lua::settable(L, -1, "cloth", cloth);
		lua::settable(L, -1, "wings", wings);
		lua::settable(L, -1, "viplevel", viplevel);
		lua::settable(L, -1, "fishioncloth", fishioncloth);
		lua::settable(L, -1, "ranktime", ranktime);
		lua::settable(L, -1, "fashionweapon", fashionweapon);
		lua::settable(L, -1, "wing", wing);
		lua::settable(L, -1, "shield", shield);
		lua::settable(L, -1, "lingwen", lingwen);
		lua::settable(L, -1, "fabao", fabao);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",level=" << level;
		buffer << ",round=" << round;
		buffer << ",job=" << job;
		buffer << ",reborn=" << reborn;
		buffer << ",gender=" << gender;
		buffer << ",guildname=" << guildname;
		buffer << ",weapon=" << weapon;
		buffer << ",cloth=" << cloth;
		buffer << ",wings=" << wings;
		buffer << ",viplevel=" << viplevel;
		buffer << ",fishioncloth=" << fishioncloth;
		buffer << ",ranktime=" << ranktime;
		buffer << ",fashionweapon=" << fashionweapon;
		buffer << ",wing=" << wing;
		buffer << ",shield=" << shield;
		buffer << ",lingwen=" << lingwen;
		buffer << ",fabao=" << fabao;
	}

public:
	int pid;
	std::string name;
	int level;
	int round;
	int job;
	int reborn;
	int gender;
	std::string guildname;
	int weapon;
	int cloth;
	int wings;
	int viplevel;
	int fishioncloth;
	int ranktime;
	int fashionweapon;
	int wing;
	int shield;
	int lingwen;
	int fabao;
};

class MsgDBClearSCDonate : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 359 };

	MsgDBClearSCDonate() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBClearSCDonate";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return false;
	}

	virtual size_t getLength() const
	{
		return __super::getLength();
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
	}

public:
};

struct DBWorldPlayerWxsyData
{
public:
	DBWorldPlayerWxsyData()
	{
		pid = 0;
		job = 0;
		level = 0;
		gender = 0;
		wings = 0;
		recGate = 0;
		ranktime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 28;
		length += sizeof(short) + name.size();
		length += sizeof(short) + guildname.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << name;
		s << job;
		s << level;
		s << gender;
		s << guildname;
		s << wings;
		s << recGate;
		s << ranktime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> name;
		s >> job;
		s >> level;
		s >> gender;
		s >> guildname;
		s >> wings;
		s >> recGate;
		s >> ranktime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "job", job);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "gender", gender);
		lua::settable(L, -1, "guildname", guildname);
		lua::settable(L, -1, "wings", wings);
		lua::settable(L, -1, "recGate", recGate);
		lua::settable(L, -1, "ranktime", ranktime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",job=" << job;
		buffer << ",level=" << level;
		buffer << ",gender=" << gender;
		buffer << ",guildname=" << guildname;
		buffer << ",wings=" << wings;
		buffer << ",recGate=" << recGate;
		buffer << ",ranktime=" << ranktime;
	}

public:
	int pid;
	std::string name;
	int job;
	int level;
	int gender;
	std::string guildname;
	int wings;
	int recGate;
	int ranktime;
};

struct DBPidData
{
public:
	DBPidData()
	{
		pid = 0;
		leavetime = 0;
		channelid = 0;
	}

	size_t getLength(bool ex) const
	{
		return 12;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << leavetime;
		s << channelid;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> leavetime;
		s >> channelid;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "leavetime", leavetime);
		lua::settable(L, -1, "channelid", channelid);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",leavetime=" << leavetime;
		buffer << ",channelid=" << channelid;
	}

public:
	int pid;
	int leavetime;
	int channelid;
};

class MsgDBLoadPidInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 369 };

	MsgDBLoadPidInfo() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadPidInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength();
		length += sizeof(int);
		for (size_t i = 0; i < pidinfos.size(); ++i)
		{
			length += pidinfos[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		int pidinfos_vector_size = (int)pidinfos.size();
		s << pidinfos_vector_size;
		if (pidinfos_vector_size > 0)
		{
			for (auto it = pidinfos.begin(); it != pidinfos.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		int pidinfos_vector_size = s.read_int32();
		pidinfos.clear();
		while (pidinfos_vector_size > 0)
		{
			pidinfos_vector_size--;
			DBPidData val;
			val.unserialize(s, true);
			pidinfos.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::newtable(lua::L);
		for (size_t i = 0; i < pidinfos.size(); ++i)
		{
			pidinfos[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "pidinfos");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pidinfos=[";
		for (size_t i = 0; i < pidinfos.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			pidinfos[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	std::vector<DBPidData> pidinfos;
};

struct wbpProps
{
public:
	wbpProps()
	{
		type = 0;
		value = 0;
	}

	size_t getLength(bool ex) const
	{
		return 8;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << type;
		s << value;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> type;
		s >> value;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "value", value);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "type=" << type;
		buffer << ",value=" << value;
	}

public:
	int type;
	int value;
};

struct wbpEvents
{
public:
	wbpEvents()
	{
		type = 0;
		datax = 0;
		datay = 0;
		dataz = 0;
	}

	size_t getLength(bool ex) const
	{
		return 16;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << type;
		s << datax;
		s << datay;
		s << dataz;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> type;
		s >> datax;
		s >> datay;
		s >> dataz;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "type=" << type;
		buffer << ",datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
	}

public:
	int type;
	int datax;
	int datay;
	int dataz;
};

class MsgDBWepPayPlayerInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 377 };

	MsgDBWepPayPlayerInfo() :
		MessageEx(Category, Id)
	{
		pid = 0;
		activityId = 0;
		datax = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBWepPayPlayerInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return pid;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 12;
		length += sizeof(int);
		for (size_t i = 0; i < props.size(); ++i)
		{
			length += props[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < events.size(); ++i)
		{
			length += events[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < backprops.size(); ++i)
		{
			length += backprops[i].getLength(true);
		}
		length += sizeof(int);
		for (size_t i = 0; i < backevents.size(); ++i)
		{
			length += backevents[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << pid;
		s << activityId;
		int props_vector_size = (int)props.size();
		s << props_vector_size;
		if (props_vector_size > 0)
		{
			for (auto it = props.begin(); it != props.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int events_vector_size = (int)events.size();
		s << events_vector_size;
		if (events_vector_size > 0)
		{
			for (auto it = events.begin(); it != events.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int backprops_vector_size = (int)backprops.size();
		s << backprops_vector_size;
		if (backprops_vector_size > 0)
		{
			for (auto it = backprops.begin(); it != backprops.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		int backevents_vector_size = (int)backevents.size();
		s << backevents_vector_size;
		if (backevents_vector_size > 0)
		{
			for (auto it = backevents.begin(); it != backevents.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		s << datax;
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> pid;
		s >> activityId;
		int props_vector_size = s.read_int32();
		props.clear();
		while (props_vector_size > 0)
		{
			props_vector_size--;
			wbpProps val;
			val.unserialize(s, true);
			props.push_back(val);
		}
		int events_vector_size = s.read_int32();
		events.clear();
		while (events_vector_size > 0)
		{
			events_vector_size--;
			wbpEvents val;
			val.unserialize(s, true);
			events.push_back(val);
		}
		int backprops_vector_size = s.read_int32();
		backprops.clear();
		while (backprops_vector_size > 0)
		{
			backprops_vector_size--;
			wbpProps val;
			val.unserialize(s, true);
			backprops.push_back(val);
		}
		int backevents_vector_size = s.read_int32();
		backevents.clear();
		while (backevents_vector_size > 0)
		{
			backevents_vector_size--;
			wbpEvents val;
			val.unserialize(s, true);
			backevents.push_back(val);
		}
		s >> datax;
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "activityId", activityId);
		lua::newtable(lua::L);
		for (size_t i = 0; i < props.size(); ++i)
		{
			props[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "props");
		lua::newtable(lua::L);
		for (size_t i = 0; i < events.size(); ++i)
		{
			events[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "events");
		lua::newtable(lua::L);
		for (size_t i = 0; i < backprops.size(); ++i)
		{
			backprops[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "backprops");
		lua::newtable(lua::L);
		for (size_t i = 0; i < backevents.size(); ++i)
		{
			backevents[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "backevents");
		lua::settable(L, -1, "datax", datax);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",pid=" << pid;
		buffer << ",activityId=" << activityId;
		buffer << ",props=[";
		for (size_t i = 0; i < props.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			props[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",events=[";
		for (size_t i = 0; i < events.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			events[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",backprops=[";
		for (size_t i = 0; i < backprops.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			backprops[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",backevents=[";
		for (size_t i = 0; i < backevents.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			backevents[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
		buffer << ",datax=" << datax;
	}

public:
	int pid;
	int activityId;
	std::vector<wbpProps> props;
	std::vector<wbpEvents> events;
	std::vector<wbpProps> backprops;
	std::vector<wbpEvents> backevents;
	int datax;
};

struct DBLoadPlayerSCDonate
{
public:
	DBLoadPlayerSCDonate()
	{
		pid = 0;
		svalue = 0;
		level = 0;
		ranktime = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 16;
		length += sizeof(short) + name.size();
		length += sizeof(short) + guildname.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << pid;
		s << name;
		s << svalue;
		s << level;
		s << guildname;
		s << ranktime;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> pid;
		s >> name;
		s >> svalue;
		s >> level;
		s >> guildname;
		s >> ranktime;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "svalue", svalue);
		lua::settable(L, -1, "level", level);
		lua::settable(L, -1, "guildname", guildname);
		lua::settable(L, -1, "ranktime", ranktime);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "pid=" << pid;
		buffer << ",name=" << name;
		buffer << ",svalue=" << svalue;
		buffer << ",level=" << level;
		buffer << ",guildname=" << guildname;
		buffer << ",ranktime=" << ranktime;
	}

public:
	int pid;
	std::string name;
	int svalue;
	int level;
	std::string guildname;
	int ranktime;
};

class MsgDBCreateSCTreasuryDropInfo : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 389 };

	MsgDBCreateSCTreasuryDropInfo() :
		MessageEx(Category, Id)
	{
	}

	virtual const char *getName() const
	{
		return "MsgDBCreateSCTreasuryDropInfo";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		return __super::getLength();
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
	}

public:
};

struct DBRankData
{
public:
	DBRankData()
	{
		datax = 0;
		datay = 0;
		dataz = 0;
		time = 0;
		pid = 0;
		gid = 0;
	}

	size_t getLength(bool ex) const
	{
		size_t length = 24;
		length += sizeof(short) + name.size();
		length += sizeof(short) + guildName.size();
		return length;
	}

	bool serialize(ByteStream &s, bool ex) const
	{
		s << datax;
		s << datay;
		s << dataz;
		s << time;
		s << pid;
		s << gid;
		s << name;
		s << guildName;
		return true;
	}

	bool unserialize(ByteStream &s, bool ex)
	{
		s >> datax;
		s >> datay;
		s >> dataz;
		s >> time;
		s >> pid;
		s >> gid;
		s >> name;
		s >> guildName;
		return true;
	}

	void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "datax", datax);
		lua::settable(L, -1, "datay", datay);
		lua::settable(L, -1, "dataz", dataz);
		lua::settable(L, -1, "time", time);
		lua::settable(L, -1, "pid", pid);
		lua::settable(L, -1, "gid", gid);
		lua::settable(L, -1, "name", name);
		lua::settable(L, -1, "guildName", guildName);
	}

	void dump(DumpBuffer &buffer)
	{
		buffer << "datax=" << datax;
		buffer << ",datay=" << datay;
		buffer << ",dataz=" << dataz;
		buffer << ",time=" << time;
		buffer << ",pid=" << pid;
		buffer << ",gid=" << gid;
		buffer << ",name=" << name;
		buffer << ",guildName=" << guildName;
	}

public:
	int datax;
	int datay;
	int dataz;
	int time; //上榜时间 
	int pid;
	int gid;
	std::string name;
	std::string guildName;
};

class MsgDBLoadRank : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 406 };

	MsgDBLoadRank() :
		MessageEx(Category, Id)
	{
		type = 0;
		history = 0;
		eventId = 0;
		minValue = 0;
		capacity = 0;
		total = 0;
		timePropId = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBLoadRank";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 28;
		length += sizeof(short) + dataxStr.size();
		length += sizeof(short) + datayStr.size();
		length += sizeof(short) + datazStr.size();
		length += sizeof(int);
		for (size_t i = 0; i < list.size(); ++i)
		{
			length += list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << type;
		s << history;
		s << eventId;
		s << minValue;
		s << capacity;
		s << total;
		s << timePropId;
		s << dataxStr;
		s << datayStr;
		s << datazStr;
		int list_vector_size = (int)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> type;
		s >> history;
		s >> eventId;
		s >> minValue;
		s >> capacity;
		s >> total;
		s >> timePropId;
		s >> dataxStr;
		s >> datayStr;
		s >> datazStr;
		int list_vector_size = s.read_int32();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			DBRankData val;
			val.unserialize(s, true);
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::settable(L, -1, "history", history);
		lua::settable(L, -1, "eventId", eventId);
		lua::settable(L, -1, "minValue", minValue);
		lua::settable(L, -1, "capacity", capacity);
		lua::settable(L, -1, "total", total);
		lua::settable(L, -1, "timePropId", timePropId);
		lua::settable(L, -1, "dataxStr", dataxStr);
		lua::settable(L, -1, "datayStr", datayStr);
		lua::settable(L, -1, "datazStr", datazStr);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",type=" << type;
		buffer << ",history=" << history;
		buffer << ",eventId=" << eventId;
		buffer << ",minValue=" << minValue;
		buffer << ",capacity=" << capacity;
		buffer << ",total=" << total;
		buffer << ",timePropId=" << timePropId;
		buffer << ",dataxStr=" << dataxStr;
		buffer << ",datayStr=" << datayStr;
		buffer << ",datazStr=" << datazStr;
		buffer << ",list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int type;
	int history;
	int eventId;
	int minValue; //上榜最低条件 
	int capacity; //排行榜长度 
	int total;
	int timePropId;
	std::string dataxStr;
	std::string datayStr;
	std::string datazStr;
	std::vector<DBRankData> list;
};

class MsgDBUpdateRankHistory : public MessageEx
{
public:
	enum { Category = MSG_CATEGORY_DB_WORLD, Id = 407 };

	MsgDBUpdateRankHistory() :
		MessageEx(Category, Id)
	{
		type = 0;
	}

	virtual const char *getName() const
	{
		return "MsgDBUpdateRankHistory";
	}

	virtual bool canSendToCrossFromClient() const
	{
		return false;
	}

	virtual int getSalt() const
	{
		return 0;
	}

	virtual bool getSendBack() const
	{
		return true;
	}

	virtual size_t getLength() const
	{
		size_t length = __super::getLength() + 4;
		length += sizeof(int);
		for (size_t i = 0; i < list.size(); ++i)
		{
			length += list[i].getLength(true);
		}
		return length;
	}

	virtual bool serialize(ByteStream &s) const
	{
		__super::serialize(s);
		s << type;
		int list_vector_size = (int)list.size();
		s << list_vector_size;
		if (list_vector_size > 0)
		{
			for (auto it = list.begin(); it != list.end(); ++it)
			{
				(*it).serialize(s, true);
			}
		}
		return true;
	}

	virtual bool unserialize(ByteStream &s)
	{
		__super::unserialize(s);
		s >> type;
		int list_vector_size = s.read_int32();
		list.clear();
		while (list_vector_size > 0)
		{
			list_vector_size--;
			DBRankData val;
			val.unserialize(s, true);
			list.push_back(val);
		}
		return true;
	}

	virtual void push(lua_State *L) const
	{
		lua::newtable(lua::L);
		lua::settable(L, -1, "type", type);
		lua::newtable(lua::L);
		for (size_t i = 0; i < list.size(); ++i)
		{
			list[i].push(L);
			lua::push(L, (int)i+1);
			lua::settable(L, -1);
		}
		lua::settable(L, -2, "list");
	}

	virtual void dump(DumpBuffer &buffer)
	{
		__super::dump(buffer);
		buffer << ",type=" << type;
		buffer << ",list=[";
		for (size_t i = 0; i < list.size(); ++i)
		{
			buffer << ((i == 0) ? "" : ",") << "{";
			list[i].dump(buffer);
			buffer << "}";
		}
		buffer << "]";
	}

public:
	int type;
	std::vector<DBRankData> list;
};

#endif	//_DB_MSG_WORLD_H_INCLUDED
